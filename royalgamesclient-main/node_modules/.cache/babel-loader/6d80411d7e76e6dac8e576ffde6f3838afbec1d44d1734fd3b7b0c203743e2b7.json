{"ast":null,"code":"import { SHAPES } from '@pixi/core';\nconst buildCircle = {\n  build(graphicsData) {\n    const points = graphicsData.points;\n    let x;\n    let y;\n    let dx;\n    let dy;\n    let rx;\n    let ry;\n    if (graphicsData.type === SHAPES.CIRC) {\n      const circle = graphicsData.shape;\n      x = circle.x;\n      y = circle.y;\n      rx = ry = circle.radius;\n      dx = dy = 0;\n    } else if (graphicsData.type === SHAPES.ELIP) {\n      const ellipse = graphicsData.shape;\n      x = ellipse.x;\n      y = ellipse.y;\n      rx = ellipse.width;\n      ry = ellipse.height;\n      dx = dy = 0;\n    } else {\n      const roundedRect = graphicsData.shape;\n      const halfWidth = roundedRect.width / 2;\n      const halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {\n      points.length = 0;\n      return;\n    }\n    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    points.length = m;\n    if (m === 0) {\n      return;\n    }\n    if (n === 0) {\n      points.length = 8;\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return;\n    }\n    let j1 = 0;\n    let j2 = n * 4 + (dx ? 2 : 0) + 2;\n    let j3 = j2;\n    let j4 = m;\n    {\n      const x0 = dx + rx;\n      const y0 = dy;\n      const x1 = x + x0;\n      const x2 = x - x0;\n      const y1 = y + y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j2] = y1;\n      points[--j2] = x2;\n      if (dy) {\n        const y2 = y - y0;\n        points[j3++] = x2;\n        points[j3++] = y2;\n        points[--j4] = y2;\n        points[--j4] = x1;\n      }\n    }\n    for (let i = 1; i < n; i++) {\n      const a = Math.PI / 2 * (i / n);\n      const x0 = dx + Math.cos(a) * rx;\n      const y0 = dy + Math.sin(a) * ry;\n      const x1 = x + x0;\n      const x2 = x - x0;\n      const y1 = y + y0;\n      const y2 = y - y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j2] = y1;\n      points[--j2] = x2;\n      points[j3++] = x2;\n      points[j3++] = y2;\n      points[--j4] = y2;\n      points[--j4] = x1;\n    }\n    {\n      const x0 = dx;\n      const y0 = dy + ry;\n      const x1 = x + x0;\n      const x2 = x - x0;\n      const y1 = y + y0;\n      const y2 = y - y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j4] = y2;\n      points[--j4] = x1;\n      if (dx) {\n        points[j1++] = x2;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x2;\n      }\n    }\n  },\n  triangulate(graphicsData, graphicsGeometry) {\n    const points = graphicsData.points;\n    const verts = graphicsGeometry.points;\n    const indices = graphicsGeometry.indices;\n    if (points.length === 0) {\n      return;\n    }\n    let vertPos = verts.length / 2;\n    const center = vertPos;\n    let x;\n    let y;\n    if (graphicsData.type !== SHAPES.RREC) {\n      const circle = graphicsData.shape;\n      x = circle.x;\n      y = circle.y;\n    } else {\n      const roundedRect = graphicsData.shape;\n      x = roundedRect.x + roundedRect.width / 2;\n      y = roundedRect.y + roundedRect.height / 2;\n    }\n    const matrix = graphicsData.matrix;\n    verts.push(graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x, graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y);\n    vertPos++;\n    verts.push(points[0], points[1]);\n    for (let i = 2; i < points.length; i += 2) {\n      verts.push(points[i], points[i + 1]);\n      indices.push(vertPos++, center, vertPos);\n    }\n    indices.push(center + 1, center, vertPos);\n  }\n};\nexport { buildCircle };","map":{"version":3,"mappings":";AAgBO,MAAMA,WAAkC;EAE3CC,MAAMC,YACN;IAEI,MAAMC,SAASD,YAAa;IAExB;IACA;IACA;IACA;IACA;IACA;IAEA,iBAAaE,IAAS,YAAOC,IACjC;MACI,MAAMC,SAASJ,YAAa;MAE5BK,IAAID,MAAO;MACXE,IAAIF,MAAO;MACXG,KAAKC,KAAKJ,MAAO;MACjBK,KAAKC,EAAK;IAAA,CAEL,uBAAaR,IAAS,YAAOS,IACtC;MACI,MAAMC,UAAUZ,YAAa;MAE7BK,IAAIO,OAAQ;MACZN,IAAIM,OAAQ;MACZL,KAAKK,OAAQ;MACbJ,KAAKI,OAAQ;MACbH,KAAKC,EAAK;IAAA,CAGd;MACI,MAAMG,cAAcb,YAAa;MAC3B,kBAAYa,YAAYC,KAAQ;MAChC,mBAAaD,YAAYE,MAAS;MAExCV,IAAIQ,YAAYR,CAAI;MACpBC,IAAIO,YAAYP,CAAI;MACpBC,KAAKC,EAAK,QAAKQ,GAAI,IAAGC,IAAK,KAAIJ,WAAY,SAAQI,IAAK,KAAIC,SAAW,YAAU,CAAC,CAAC;MACnFT,KAAKS,SAAY;MACjBR,KAAKS,UAAa;IAAA;IAGlB,YAAQ,CAAK,UAAM,KAAKV,EAAM,SAAKC,MAAM,CAC7C;MACIT,OAAOmB,MAAS;MAEhB;IAAA;IAIE,UAAIH,KAAKI,IAAK,OAAMJ,KAAKK,IAAK,MAAKd,EAAE,CAAC;IAC5C,MAAMe,IAAKC,CAAI,aAAW,CAAI,cAAW,CAAI;IAE7CvB,OAAOmB,MAAS;IAEhB,IAAIG,MAAM,CACV;MACI;IAAA;IAGJ,IAAIC,MAAM,CACV;MACIvB,OAAOmB,MAAS;MACTnB,YAAKA,MAAO,MAAKI,CAAI;MACrBJ,YAAKA,MAAO,MAAKK,CAAI;MACrBL,YAAKA,MAAO,MAAKI,CAAI;MACrBJ,YAAKA,MAAO,MAAKK,CAAI;MAE5B;IAAA;IAGJ,IAAImB,EAAK;IACT,IAAIC,EAAM,OAAI,CAAM,SAAK,IAAI,CAAK;IAClC,IAAIC,EAAK;IACT,IAAIC,EAAK;IAET;MACI,MAAMC,KAAKpB,EAAK;MAChB,MAAMqB,EAAK;MACX,MAAMC,KAAK1B,CAAI;MACf,MAAM2B,KAAK3B,CAAI;MACf,MAAM4B,KAAK3B,CAAI;MAEfL,OAAOwB,EAAQ;MACfxB,OAAOwB,EAAQ;MACfxB,OAAO,EAAEyB,EAAM;MACfzB,OAAO,EAAEyB,EAAM;MAEf,IAAIhB,EACJ;QACI,MAAMwB,KAAK5B,CAAI;QAEfL,OAAO0B,EAAQ;QACf1B,OAAO0B,EAAQ;QACf1B,OAAO,EAAE2B,EAAM;QACf3B,OAAO,EAAE2B,EAAM;MAAA;IACnB;IAGJ,SAASO,CAAI,MAAGA,CAAI,MAAGA,CACvB;MACI,MAAMC,CAAI,QAAKC,EAAK,QAASF;MAC7B,MAAMN,EAAK,QAAMZ,IAAK,KAAImB,CAAC,CAAI;MAC/B,MAAMN,EAAK,QAAMb,IAAK,KAAImB,CAAC,CAAI;MAC/B,MAAML,KAAK1B,CAAI;MACf,MAAM2B,KAAK3B,CAAI;MACf,MAAM4B,KAAK3B,CAAI;MACf,MAAM4B,KAAK5B,CAAI;MAEfL,OAAOwB,EAAQ;MACfxB,OAAOwB,EAAQ;MACfxB,OAAO,EAAEyB,EAAM;MACfzB,OAAO,EAAEyB,EAAM;MACfzB,OAAO0B,EAAQ;MACf1B,OAAO0B,EAAQ;MACf1B,OAAO,EAAE2B,EAAM;MACf3B,OAAO,EAAE2B,EAAM;IAAA;IAGnB;MACI,MAAMC,EAAK;MACX,MAAMC,KAAKpB,EAAK;MAChB,MAAMqB,KAAK1B,CAAI;MACf,MAAM2B,KAAK3B,CAAI;MACf,MAAM4B,KAAK3B,CAAI;MACf,MAAM4B,KAAK5B,CAAI;MAEfL,OAAOwB,EAAQ;MACfxB,OAAOwB,EAAQ;MACfxB,OAAO,EAAE2B,EAAM;MACf3B,OAAO,EAAE2B,EAAM;MAEf,IAAInB,EACJ;QACIR,OAAOwB,EAAQ;QACfxB,OAAOwB,EAAQ;QACfxB,OAAO,EAAE2B,EAAM;QACf3B,OAAO,EAAE2B,EAAM;MAAA;IACnB;EACJ,CACJ;EAEAU,YAAYtC,cAAcuC,gBAC1B;IACI,MAAMtC,SAASD,YAAa;IAC5B,MAAMwC,QAAQD,gBAAiB;IAC/B,MAAME,UAAUF,gBAAiB;IAE7B,WAAOnB,WAAW,CACtB;MACI;IAAA;IAGA,cAAUoB,MAAMpB,MAAS;IAC7B,MAAMsB,MAAS;IAEX;IACA;IAEA,iBAAaxC,IAAS,YAAOyC,IACjC;MACI,MAAMvC,SAASJ,YAAa;MAE5BK,IAAID,MAAO;MACXE,IAAIF,MAAO;IAAA,CAGf;MACI,MAAMS,cAAcb,YAAa;MAE7BK,gBAAYA,CAAK,eAAYS,KAAQ;MACrCR,gBAAYA,CAAK,eAAYS,MAAS;IAAA;IAG9C,MAAM6B,SAAS5C,YAAa;IAGtBwC,WACFxC,aAAa4C,MAAU,UAAOR,IAAI/B,CAAM,UAAOwC,CAAI,OAAKD,MAAO,MAAKvC,GACpEL,YAAa,UAAU4C,OAAOE,CAAI,OAAMF,OAAOG,CAAI,OAAKH,MAAO,MAAKtC,CAAC;IAEzE0C;IAEAR,MAAMS,IAAK,QAAO,CAAI,UAAO,CAAE;IAE/B,SAASd,IAAI,CAAG,MAAIlC,MAAO,SAAQkC,KAAK,CACxC;MACIK,MAAMS,IAAK,QAAOd,CAAI,UAAOA,IAAI,CAAE;MAG3BM,aAAKO,OAAW,YAAQA,OAAO;IAAA;IAG3CP,QAAQQ,IAAK,UAAS,CAAG,UAAQD,OAAO;EAAA;AAEhD","names":["buildCircle","build","graphicsData","points","type","CIRC","circle","x","y","rx","ry","dx","dy","ELIP","ellipse","roundedRect","width","height","max","Math","halfWidth","halfHeight","length","ceil","sqrt","m","n","j1","j2","j3","j4","x0","y0","x1","x2","y1","y2","i","a","PI","triangulate","graphicsGeometry","verts","indices","center","RREC","matrix","c","b","d","vertPos","push"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/graphics/src/utils/buildCircle.ts"],"sourcesContent":["// for type only\nimport { SHAPES } from '@pixi/core';\n\nimport type { Circle, Ellipse, RoundedRectangle } from '@pixi/core';\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\n\n/**\n * Builds a circle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildCircle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        // need to convert points to a nice regular data\n        const points = graphicsData.points;\n\n        let x;\n        let y;\n        let dx;\n        let dy;\n        let rx;\n        let ry;\n\n        if (graphicsData.type === SHAPES.CIRC)\n        {\n            const circle = graphicsData.shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n            rx = ry = circle.radius;\n            dx = dy = 0;\n        }\n        else if (graphicsData.type === SHAPES.ELIP)\n        {\n            const ellipse = graphicsData.shape as Ellipse;\n\n            x = ellipse.x;\n            y = ellipse.y;\n            rx = ellipse.width;\n            ry = ellipse.height;\n            dx = dy = 0;\n        }\n        else\n        {\n            const roundedRect = graphicsData.shape as RoundedRectangle;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n\n        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0))\n        {\n            points.length = 0;\n\n            return;\n        }\n\n        // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = (n * 8) + (dx ? 4 : 0) + (dy ? 4 : 0);\n\n        points.length = m;\n\n        if (m === 0)\n        {\n            return;\n        }\n\n        if (n === 0)\n        {\n            points.length = 8;\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n\n            return;\n        }\n\n        let j1 = 0;\n        let j2 = (n * 4) + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n\n        {\n            const x0 = dx + rx;\n            const y0 = dy;\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n\n            if (dy)\n            {\n                const y2 = y - y0;\n\n                points[j3++] = x2;\n                points[j3++] = y2;\n                points[--j4] = y2;\n                points[--j4] = x1;\n            }\n        }\n\n        for (let i = 1; i < n; i++)\n        {\n            const a = Math.PI / 2 * (i / n);\n            const x0 = dx + (Math.cos(a) * rx);\n            const y0 = dy + (Math.sin(a) * ry);\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        {\n            const x0 = dx;\n            const y0 = dy + ry;\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x1;\n\n            if (dx)\n            {\n                points[j1++] = x2;\n                points[j1++] = y1;\n                points[--j4] = y2;\n                points[--j4] = x2;\n            }\n        }\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        let vertPos = verts.length / 2;\n        const center = vertPos;\n\n        let x;\n        let y;\n\n        if (graphicsData.type !== SHAPES.RREC)\n        {\n            const circle = graphicsData.shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n        }\n        else\n        {\n            const roundedRect = graphicsData.shape as RoundedRectangle;\n\n            x = roundedRect.x + (roundedRect.width / 2);\n            y = roundedRect.y + (roundedRect.height / 2);\n        }\n\n        const matrix = graphicsData.matrix;\n\n        // Push center (special point)\n        verts.push(\n            graphicsData.matrix ? (matrix.a * x) + (matrix.c * y) + matrix.tx : x,\n            graphicsData.matrix ? (matrix.b * x) + (matrix.d * y) + matrix.ty : y);\n\n        vertPos++;\n\n        verts.push(points[0], points[1]);\n\n        for (let i = 2; i < points.length; i += 2)\n        {\n            verts.push(points[i], points[i + 1]);\n\n            // add some uvs\n            indices.push(vertPos++, center, vertPos);\n        }\n\n        indices.push(center + 1, center, vertPos);\n    },\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}