{"ast":null,"code":"import { Matrix } from '@pixi/math';\nimport { Program } from '../shader/Program.mjs';\nimport { Shader } from '../shader/Shader.mjs';\nimport { UniformGroup } from '../shader/UniformGroup.mjs';\nclass BatchShaderGenerator {\n  constructor(vertexSrc, fragTemplate) {\n    this.vertexSrc = vertexSrc;\n    this.fragTemplate = fragTemplate;\n    this.programCache = {};\n    this.defaultGroupCache = {};\n    if (!fragTemplate.includes(\"%count%\")) {\n      throw new Error('Fragment template must contain \"%count%\".');\n    }\n    if (!fragTemplate.includes(\"%forloop%\")) {\n      throw new Error('Fragment template must contain \"%forloop%\".');\n    }\n  }\n  generateShader(maxTextures) {\n    if (!this.programCache[maxTextures]) {\n      const sampleValues = new Int32Array(maxTextures);\n      for (let i = 0; i < maxTextures; i++) {\n        sampleValues[i] = i;\n      }\n      this.defaultGroupCache[maxTextures] = UniformGroup.from({\n        uSamplers: sampleValues\n      }, true);\n      let fragmentSrc = this.fragTemplate;\n      fragmentSrc = fragmentSrc.replace(/%count%/gi, \"\".concat(maxTextures));\n      fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));\n      this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);\n    }\n    const uniforms = {\n      tint: new Float32Array([1, 1, 1, 1]),\n      translationMatrix: new Matrix(),\n      default: this.defaultGroupCache[maxTextures]\n    };\n    return new Shader(this.programCache[maxTextures], uniforms);\n  }\n  generateSampleSrc(maxTextures) {\n    let src = \"\";\n    src += \"\\n\";\n    src += \"\\n\";\n    for (let i = 0; i < maxTextures; i++) {\n      if (i > 0) {\n        src += \"\\nelse \";\n      }\n      if (i < maxTextures - 1) {\n        src += \"if(vTextureId < \".concat(i, \".5)\");\n      }\n      src += \"\\n{\";\n      src += \"\\n\\tcolor = texture2D(uSamplers[\".concat(i, \"], vTextureCoord);\");\n      src += \"\\n}\";\n    }\n    src += \"\\n\";\n    src += \"\\n\";\n    return src;\n  }\n}\nexport { BatchShaderGenerator };","map":{"version":3,"mappings":";;;;AASO,MAAMA,oBACb;EAcIC,YAAYC,WAAmBC,YAC/B;IACI,KAAKD,SAAY;IACjB,KAAKC,YAAe;IAEpB,KAAKC,eAAe,EAAC;IACrB,KAAKC,oBAAoB,EAAC;IAE1B,IAAI,CAACF,aAAaG,QAAS,UAAS,CACpC;MACU,UAAIC,MAAM,2CAA2C;IAAA;IAG/D,IAAI,CAACJ,aAAaG,QAAS,YAAW,CACtC;MACU,UAAIC,MAAM,6CAA6C;IAAA;EACjE;EAGJC,eAAeC,WACf;IACQ,KAAC,IAAK,cAAaA,WACvB;MACU,qBAAe,IAAIC,WAAWD,WAAW;MAE/C,SAASE,CAAI,MAAGA,CAAI,gBAAaA,CACjC;QACIC,aAAaD,CAAK;MAAA;MAGjB,uBAAkBF,eAAeI,YAAa,MAAK;QAAEC,SAAW;MAAA,GAAgB,IAAI;MAEzF,IAAIC,cAAc,IAAK;MAEvBA,cAAcA,WAAY,SAAQ,WAAa,YAAGN,WAAa;MAC/DM,cAAcA,YAAYC,OAAQ,gBAAe,IAAK,mBAAkBP,WAAW,CAAC;MAEpF,KAAKL,aAAaK,WAAe,QAAIQ,OAAQ,MAAKf,WAAWa,WAAW;IAAA;IAG5E,MAAMG,QAAW;MACbC,MAAM,IAAIC,YAAa,EAAC,GAAG,CAAG,KAAG,CAAC,CAAC;MACnCC,mBAAmB,IAAIC,MAAO;MAC9BC,SAAS,KAAKlB,iBAAkB;IAAA,CACpC;IAEA,OAAO,IAAImB,OAAO,IAAK,cAAaf,cAAcS,QAAQ;EAAA;EAG9DO,kBAAkBhB,WAClB;IACI,IAAIiB,GAAM;IAEHA;IACAA;IAEP,SAASf,CAAI,MAAGA,CAAI,gBAAaA,CACjC;MACI,IAAIA,IAAI,CACR;QACWe;MAAA;MAGP,QAAIjB,cAAc,CACtB;QACIiB,iCAA0Bf;MAAA;MAGvBe;MACAA,iDAAmCf;MACnCe;IAAA;IAGJA;IACAA;IAEA;EAAA;AAEf","names":["BatchShaderGenerator","constructor","vertexSrc","fragTemplate","programCache","defaultGroupCache","includes","Error","generateShader","maxTextures","Int32Array","i","sampleValues","UniformGroup","uSamplers","fragmentSrc","replace","Program","uniforms","tint","Float32Array","translationMatrix","Matrix","default","Shader","generateSampleSrc","src"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/core/src/batch/BatchShaderGenerator.ts"],"sourcesContent":["import { Matrix } from '@pixi/math';\nimport { Program } from '../shader/Program';\nimport { Shader } from '../shader/Shader';\nimport { UniformGroup } from '../shader/UniformGroup';\n\n/**\n * Helper that generates batching multi-texture shader. Use it with your new BatchRenderer\n * @memberof PIXI\n */\nexport class BatchShaderGenerator\n{\n    /** Reference to the vertex shader source. */\n    public vertexSrc: string;\n\n    /** Reference to the fragment shader template. Must contain \"%count%\" and \"%forloop%\". */\n    public fragTemplate: string;\n\n    programCache: {[key: number]: Program};\n    defaultGroupCache: {[key: number]: UniformGroup};\n\n    /**\n     * @param vertexSrc - Vertex shader\n     * @param fragTemplate - Fragment shader template\n     */\n    constructor(vertexSrc: string, fragTemplate: string)\n    {\n        this.vertexSrc = vertexSrc;\n        this.fragTemplate = fragTemplate;\n\n        this.programCache = {};\n        this.defaultGroupCache = {};\n\n        if (!fragTemplate.includes('%count%'))\n        {\n            throw new Error('Fragment template must contain \"%count%\".');\n        }\n\n        if (!fragTemplate.includes('%forloop%'))\n        {\n            throw new Error('Fragment template must contain \"%forloop%\".');\n        }\n    }\n\n    generateShader(maxTextures: number): Shader\n    {\n        if (!this.programCache[maxTextures])\n        {\n            const sampleValues = new Int32Array(maxTextures);\n\n            for (let i = 0; i < maxTextures; i++)\n            {\n                sampleValues[i] = i;\n            }\n\n            this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);\n\n            let fragmentSrc = this.fragTemplate;\n\n            fragmentSrc = fragmentSrc.replace(/%count%/gi, `${maxTextures}`);\n            fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));\n\n            this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);\n        }\n\n        const uniforms = {\n            tint: new Float32Array([1, 1, 1, 1]),\n            translationMatrix: new Matrix(),\n            default: this.defaultGroupCache[maxTextures],\n        };\n\n        return new Shader(this.programCache[maxTextures], uniforms);\n    }\n\n    generateSampleSrc(maxTextures: number): string\n    {\n        let src = '';\n\n        src += '\\n';\n        src += '\\n';\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i > 0)\n            {\n                src += '\\nelse ';\n            }\n\n            if (i < maxTextures - 1)\n            {\n                src += `if(vTextureId < ${i}.5)`;\n            }\n\n            src += '\\n{';\n            src += `\\n\\tcolor = texture2D(uSamplers[${i}], vTextureCoord);`;\n            src += '\\n}';\n        }\n\n        src += '\\n';\n        src += '\\n';\n\n        return src;\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}