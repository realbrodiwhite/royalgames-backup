{"ast":null,"code":"import { utils } from '@pixi/core';\nimport { generateFillStyle } from './generateFillStyle.mjs';\nfunction drawGlyph(canvas, context, metrics, x, y, resolution, style) {\n  const char = metrics.text;\n  const fontProperties = metrics.fontProperties;\n  context.translate(x, y);\n  context.scale(resolution, resolution);\n  const tx = style.strokeThickness / 2;\n  const ty = -(style.strokeThickness / 2);\n  context.font = style.toFontString();\n  context.lineWidth = style.strokeThickness;\n  context.textBaseline = style.textBaseline;\n  context.lineJoin = style.lineJoin;\n  context.miterLimit = style.miterLimit;\n  context.fillStyle = generateFillStyle(canvas, context, style, resolution, [char], metrics);\n  context.strokeStyle = style.stroke;\n  if (style.dropShadow) {\n    const dropShadowColor = style.dropShadowColor;\n    const rgb = utils.hex2rgb(typeof dropShadowColor === \"number\" ? dropShadowColor : utils.string2hex(dropShadowColor));\n    const dropShadowBlur = style.dropShadowBlur * resolution;\n    const dropShadowDistance = style.dropShadowDistance * resolution;\n    context.shadowColor = \"rgba(\".concat(rgb[0] * 255, \",\").concat(rgb[1] * 255, \",\").concat(rgb[2] * 255, \",\").concat(style.dropShadowAlpha, \")\");\n    context.shadowBlur = dropShadowBlur;\n    context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;\n    context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;\n  } else {\n    context.shadowColor = \"black\";\n    context.shadowBlur = 0;\n    context.shadowOffsetX = 0;\n    context.shadowOffsetY = 0;\n  }\n  if (style.stroke && style.strokeThickness) {\n    context.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);\n  }\n  if (style.fill) {\n    context.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);\n  }\n  context.setTransform(1, 0, 0, 1, 0, 0);\n  context.fillStyle = \"rgba(0, 0, 0, 0)\";\n}\nexport { drawGlyph };","map":{"version":3,"mappings":";;AAqBO,mBACHA,QACAC,OACA,WACAC,CACA,KACAC,YACAC,KAEJ;EACI,MAAMC,OAAOC,OAAQ;EACrB,MAAMC,iBAAiBD,OAAQ;EAEvBL,kBAAUC,GAAGM,CAAC;EACdP,cAAME,YAAYA,UAAU;EAE9B,WAAKC,MAAMK,eAAkB;EAC7B,WAAK,EAAEL,MAAMK,eAAkB;EAE7BR,eAAOG,MAAMM,YAAa;EAClCT,QAAQU,YAAYP,KAAM;EAC1BH,QAAQW,eAAeR,KAAM;EAC7BH,QAAQY,WAAWT,KAAM;EACzBH,QAAQa,aAAaV,KAAM;EAGnBH,oBAAYc,kBAAkBf,MAAQ,WAASI,OAAOD,UAAY,GAACE,IAAI,GAAGC,OAAO;EACzFL,QAAQe,cAAcZ,KAAM;EAE5B,IAAIA,MAAMa,UACV;IACI,MAAMC,kBAAkBd,KAAM;IACxB,YAAMe,KAAM,SAAQ,OAAOD,oBAAoB,WAAWA,eAAkB,SAAME,UAAW,gBAAe,CAAC;IAC7G,uBAAiBhB,MAAMiB,cAAiB;IACxC,2BAAqBjB,MAAMkB,kBAAqB;IAE9CrB,qCAAsBsB,IAAI,CAAK,qBAAOA,GAAI,MAAK,GAAO,kBAAI,CAAK,qBAAOnB,KAAM;IACpFH,QAAQuB,UAAa;IACrBvB,QAAQwB,aAAgB,QAAKC,GAAI,OAAMC,eAAe,CAAI;IAC1D1B,QAAQ2B,aAAgB,QAAKC,GAAI,OAAMF,eAAe,CAAI;EAAA,CAG9D;IACI1B,QAAQ6B,WAAc;IACtB7B,QAAQuB,UAAa;IACrBvB,QAAQwB,aAAgB;IACxBxB,QAAQ2B,aAAgB;EAAA;EAGxB,UAAMG,MAAU,UAAMtB,eAC1B;IACIR,QAAQ+B,WAAW3B,IAAM,MAAI4B,KAAK3B,OAAQ,cAAaC,eAAe2B,OAAO;EAAA;EAEjF,IAAI9B,MAAM+B,IACV;IACIlC,QAAQmC,SAAS/B,IAAM,MAAI4B,KAAK3B,OAAQ,cAAaC,eAAe2B,OAAO;EAAA;EAG/EjC,QAAQoC,aAAa,CAAG,KAAG,CAAG,KAAG,GAAG,CAAC;EAErCpC,QAAQqC,SAAY;AACxB","names":["canvas","context","x","resolution","style","char","metrics","fontProperties","y","strokeThickness","toFontString","lineWidth","textBaseline","lineJoin","miterLimit","generateFillStyle","strokeStyle","dropShadow","dropShadowColor","utils","string2hex","dropShadowBlur","dropShadowDistance","rgb","shadowBlur","shadowOffsetX","cos","dropShadowAngle","shadowOffsetY","sin","shadowColor","stroke","strokeText","ty","descent","fill","fillText","setTransform","fillStyle"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/text-bitmap/src/utils/drawGlyph.ts"],"sourcesContent":["import { utils } from '@pixi/core';\nimport { generateFillStyle } from './generateFillStyle';\n\nimport type { ICanvas, ICanvasRenderingContext2D } from '@pixi/core';\nimport type { TextMetrics, TextStyle } from '@pixi/text';\n\n// TODO: Prevent code duplication b/w drawGlyph & Text#updateText\n\n/**\n * Draws the glyph `metrics.text` on the given canvas.\n *\n * Ignored because not directly exposed.\n * @ignore\n * @param {PIXI.ICanvas} canvas\n * @param {PIXI.ICanvasRenderingContext2D} context\n * @param {TextMetrics} metrics\n * @param {number} x\n * @param {number} y\n * @param {number} resolution\n * @param {TextStyle} style\n */\nexport function drawGlyph(\n    canvas: ICanvas,\n    context: ICanvasRenderingContext2D,\n    metrics: TextMetrics,\n    x: number,\n    y: number,\n    resolution: number,\n    style: TextStyle\n): void\n{\n    const char = metrics.text;\n    const fontProperties = metrics.fontProperties;\n\n    context.translate(x, y);\n    context.scale(resolution, resolution);\n\n    const tx = style.strokeThickness / 2;\n    const ty = -(style.strokeThickness / 2);\n\n    context.font = style.toFontString();\n    context.lineWidth = style.strokeThickness;\n    context.textBaseline = style.textBaseline;\n    context.lineJoin = style.lineJoin;\n    context.miterLimit = style.miterLimit;\n\n    // set canvas text styles\n    context.fillStyle = generateFillStyle(canvas, context, style, resolution, [char], metrics);\n    context.strokeStyle = style.stroke as string;\n\n    if (style.dropShadow)\n    {\n        const dropShadowColor = style.dropShadowColor;\n        const rgb = utils.hex2rgb(typeof dropShadowColor === 'number' ? dropShadowColor : utils.string2hex(dropShadowColor));\n        const dropShadowBlur = style.dropShadowBlur * resolution;\n        const dropShadowDistance = style.dropShadowDistance * resolution;\n\n        context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${style.dropShadowAlpha})`;\n        context.shadowBlur = dropShadowBlur;\n        context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;\n        context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;\n    }\n    else\n    {\n        context.shadowColor = 'black';\n        context.shadowBlur = 0;\n        context.shadowOffsetX = 0;\n        context.shadowOffsetY = 0;\n    }\n\n    if (style.stroke && style.strokeThickness)\n    {\n        context.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);\n    }\n    if (style.fill)\n    {\n        context.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);\n    }\n\n    context.setTransform(1, 0, 0, 1, 0, 0); // defaults needed for older browsers (e.g. Opera 29)\n\n    context.fillStyle = 'rgba(0, 0, 0, 0)';\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}