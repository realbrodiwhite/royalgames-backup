{"ast":null,"code":"import { BLEND_MODES } from '@pixi/constants';\nfunction mapPremultipliedBlendModes() {\n  const pm = [];\n  const npm = [];\n  for (let i = 0; i < 32; i++) {\n    pm[i] = i;\n    npm[i] = i;\n  }\n  pm[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL;\n  pm[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD;\n  pm[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN;\n  npm[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM;\n  npm[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM;\n  npm[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;\n  const array = [];\n  array.push(npm);\n  array.push(pm);\n  return array;\n}\nconst premultiplyBlendMode = mapPremultipliedBlendModes();\nfunction correctBlendMode(blendMode, premultiplied) {\n  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];\n}\nfunction premultiplyRgba(rgb, alpha, out, premultiply) {\n  out = out || new Float32Array(4);\n  if (premultiply || premultiply === void 0) {\n    out[0] = rgb[0] * alpha;\n    out[1] = rgb[1] * alpha;\n    out[2] = rgb[2] * alpha;\n  } else {\n    out[0] = rgb[0];\n    out[1] = rgb[1];\n    out[2] = rgb[2];\n  }\n  out[3] = alpha;\n  return out;\n}\nfunction premultiplyTint(tint, alpha) {\n  if (alpha === 1) {\n    return (alpha * 255 << 24) + tint;\n  }\n  if (alpha === 0) {\n    return 0;\n  }\n  let R = tint >> 16 & 255;\n  let G = tint >> 8 & 255;\n  let B = tint & 255;\n  R = R * alpha + 0.5 | 0;\n  G = G * alpha + 0.5 | 0;\n  B = B * alpha + 0.5 | 0;\n  return (alpha * 255 << 24) + (R << 16) + (G << 8) + B;\n}\nfunction premultiplyTintToRgba(tint, alpha, out, premultiply) {\n  out = out || new Float32Array(4);\n  out[0] = (tint >> 16 & 255) / 255;\n  out[1] = (tint >> 8 & 255) / 255;\n  out[2] = (tint & 255) / 255;\n  if (premultiply || premultiply === void 0) {\n    out[0] *= alpha;\n    out[1] *= alpha;\n    out[2] *= alpha;\n  }\n  out[3] = alpha;\n  return out;\n}\nexport { correctBlendMode, premultiplyBlendMode, premultiplyRgba, premultiplyTint, premultiplyTintToRgba };","map":{"version":3,"mappings":";AASA,SACAA;EACI,MAAMC,KAAK,EAAC;EACZ,MAAMC,MAAM,EAAC;EAEb,SAASC,CAAI,MAAGA,CAAI,OAAIA,CACxB;IACIF,GAAGE,CAAK;IACRD,IAAIC,CAAK;EAAA;EAGVF,eAAYG,cAAcC,WAAY;EACtCJ,eAAYK,WAAWD,WAAY;EACnCJ,eAAYM,cAAcF,WAAY;EAErCH,gBAAYM,UAAUH,WAAY;EAClCH,gBAAYO,OAAOJ,WAAY;EAC/BH,gBAAYQ,UAAUL,WAAY;EAEtC,MAAMM,QAAoB,EAAC;EAE3BA,MAAMC,KAAKV,GAAG;EACdS,MAAMC,KAAKX,EAAE;EAEN;AACX;AAOO,MAAMY,uBAAuBb,0BAA2B;AAUxD,0BAA0Bc,WAAmBC,aACpD;EACW,4BAAqBA,aAAgB,OAAI,CAAG;AACvD;AAaI,8BACAC,KACA,OACAC,WAEJ;EACUC,aAAO,IAAIC,aAAa,CAAC;EAC3B,mBAAeF,gBAAgB,KACnC;IACQC,SAAKE,IAAI,CAAK;IACdF,SAAKE,IAAI,CAAK;IACdF,SAAKE,IAAI,CAAK;EAAA,CAGtB;IACIF,IAAI,KAAKE,GAAI;IACbF,IAAI,KAAKE,GAAI;IACbF,IAAI,KAAKE,GAAI;EAAA;EAEjBF,IAAI,CAAK;EAEF;AACX;AAUO,yBAAyBG,MAAcL,KAC9C;EACI,IAAIA,UAAU,CACd;IACY,gBAAQ,OAAO,EAAM;EAAA;EAEjC,IAAIA,UAAU,CACd;IACW;EAAA;EAEP,QAAMK,QAAQ,EAAM;EACpB,QAAMA,QAAQ,CAAK;EACvB,IAAIC,IAAKD,IAAO;EAEVE,QAAIP,QAAS,GAAO;EACpBQ,QAAIR,QAAS,GAAO;EACpBM,QAAIN,QAAS,GAAO;EAE1B,OAAQ,SAAQ,GAAO,WAAYO,iBAAY,CAAK;AACxD;AAYsC,qCAAcP,KAAe,OAAmBC,WACtF;EACUC,aAAO,IAAIC,aAAa,CAAC;EAC3BD,SAAO,CAAQG,aAAM,GAAQ;EAC7BH,SAAO,CAAQG,YAAK,GAAQ;EAC5BH,SAAM,QAAO,GAAQ;EACrB,mBAAeD,gBAAgB,KACnC;IACIC,IAAI,CAAM;IACVA,IAAI,CAAM;IACVA,IAAI,CAAM;EAAA;EAEdA,IAAI,CAAK;EAEF;AACX","names":["mapPremultipliedBlendModes","pm","npm","i","NORMAL_NPM","BLEND_MODES","ADD_NPM","SCREEN_NPM","NORMAL","ADD","SCREEN","array","push","premultiplyBlendMode","blendMode","premultiplied","alpha","premultiply","out","Float32Array","rgb","tint","B","R","G"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/utils/src/color/premultiply.ts"],"sourcesContent":["import { BLEND_MODES } from '@pixi/constants';\n\n/**\n * Corrects PixiJS blend, takes premultiplied alpha into account\n * @memberof PIXI.utils\n * @function mapPremultipliedBlendModes\n * @private\n * @returns {Array<number[]>} Mapped modes.\n */\nfunction mapPremultipliedBlendModes(): number[][]\n{\n    const pm = [];\n    const npm = [];\n\n    for (let i = 0; i < 32; i++)\n    {\n        pm[i] = i;\n        npm[i] = i;\n    }\n\n    pm[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL;\n    pm[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD;\n    pm[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN;\n\n    npm[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM;\n    npm[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM;\n    npm[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;\n\n    const array: number[][] = [];\n\n    array.push(npm);\n    array.push(pm);\n\n    return array;\n}\n\n/**\n * maps premultiply flag and blendMode to adjusted blendMode\n * @memberof PIXI.utils\n * @type {Array<number[]>}\n */\nexport const premultiplyBlendMode = mapPremultipliedBlendModes();\n\n/**\n * changes blendMode according to texture format\n * @memberof PIXI.utils\n * @function correctBlendMode\n * @param {number} blendMode - supposed blend mode\n * @param {boolean} premultiplied - whether source is premultiplied\n * @returns {number} true blend mode for this texture\n */\nexport function correctBlendMode(blendMode: number, premultiplied: boolean): number\n{\n    return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];\n}\n\n/**\n * combines rgb and alpha to out array\n * @memberof PIXI.utils\n * @function premultiplyRgba\n * @param {Float32Array|number[]} rgb - input rgb\n * @param {number} alpha - alpha param\n * @param {Float32Array} [out] - output\n * @param {boolean} [premultiply=true] - do premultiply it\n * @returns {Float32Array} vec4 rgba\n */\nexport function premultiplyRgba(\n    rgb: Float32Array | number[],\n    alpha: number,\n    out?: Float32Array,\n    premultiply?: boolean\n): Float32Array\n{\n    out = out || new Float32Array(4);\n    if (premultiply || premultiply === undefined)\n    {\n        out[0] = rgb[0] * alpha;\n        out[1] = rgb[1] * alpha;\n        out[2] = rgb[2] * alpha;\n    }\n    else\n    {\n        out[0] = rgb[0];\n        out[1] = rgb[1];\n        out[2] = rgb[2];\n    }\n    out[3] = alpha;\n\n    return out;\n}\n\n/**\n * premultiplies tint\n * @memberof PIXI.utils\n * @function premultiplyTint\n * @param {number} tint - integer RGB\n * @param {number} alpha - floating point alpha (0.0-1.0)\n * @returns {number} tint multiplied by alpha\n */\nexport function premultiplyTint(tint: number, alpha: number): number\n{\n    if (alpha === 1.0)\n    {\n        return (alpha * 255 << 24) + tint;\n    }\n    if (alpha === 0.0)\n    {\n        return 0;\n    }\n    let R = ((tint >> 16) & 0xFF);\n    let G = ((tint >> 8) & 0xFF);\n    let B = (tint & 0xFF);\n\n    R = ((R * alpha) + 0.5) | 0;\n    G = ((G * alpha) + 0.5) | 0;\n    B = ((B * alpha) + 0.5) | 0;\n\n    return (alpha * 255 << 24) + (R << 16) + (G << 8) + B;\n}\n\n/**\n * converts integer tint and float alpha to vec4 form, premultiplies by default\n * @memberof PIXI.utils\n * @function premultiplyTintToRgba\n * @param {number} tint - input tint\n * @param {number} alpha - alpha param\n * @param {Float32Array} [out] - output\n * @param {boolean} [premultiply=true] - do premultiply it\n * @returns {Float32Array} vec4 rgba\n */\nexport function premultiplyTintToRgba(tint: number, alpha: number, out: Float32Array, premultiply?: boolean): Float32Array\n{\n    out = out || new Float32Array(4);\n    out[0] = ((tint >> 16) & 0xFF) / 255.0;\n    out[1] = ((tint >> 8) & 0xFF) / 255.0;\n    out[2] = (tint & 0xFF) / 255.0;\n    if (premultiply || premultiply === undefined)\n    {\n        out[0] *= alpha;\n        out[1] *= alpha;\n        out[2] *= alpha;\n    }\n    out[3] = alpha;\n\n    return out;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}