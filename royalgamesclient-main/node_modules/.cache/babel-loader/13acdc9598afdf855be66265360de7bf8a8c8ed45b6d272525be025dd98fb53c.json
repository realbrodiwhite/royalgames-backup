{"ast":null,"code":"import { utils, ALPHA_MODES, MIPMAP_MODES, Rectangle, Texture, settings, BaseTexture } from '@pixi/core';\nimport { TextStyle, TextMetrics } from '@pixi/text';\nimport { BitmapFontData } from './BitmapFontData.mjs';\nimport { autoDetectFormat } from './formats/index.mjs';\nimport './utils/index.mjs';\nimport { resolveCharacters } from './utils/resolveCharacters.mjs';\nimport { drawGlyph } from './utils/drawGlyph.mjs';\nimport { extractCharCode } from './utils/extractCharCode.mjs';\nconst _BitmapFont = class {\n  constructor(data, textures, ownsTextures) {\n    var _distanceField$fieldT, _distanceField$fieldT2;\n    const [info] = data.info;\n    const [common] = data.common;\n    const [page] = data.page;\n    const [distanceField] = data.distanceField;\n    const res = utils.getResolutionOfUrl(page.file);\n    const pageTextures = {};\n    this._ownsTextures = ownsTextures;\n    this.font = info.face;\n    this.size = info.size;\n    this.lineHeight = common.lineHeight / res;\n    this.chars = {};\n    this.pageTextures = pageTextures;\n    for (let i = 0; i < data.page.length; i++) {\n      const {\n        id,\n        file\n      } = data.page[i];\n      pageTextures[id] = textures instanceof Array ? textures[i] : textures[file];\n      if (distanceField !== null && distanceField !== void 0 && distanceField.fieldType && distanceField.fieldType !== \"none\") {\n        pageTextures[id].baseTexture.alphaMode = ALPHA_MODES.NO_PREMULTIPLIED_ALPHA;\n        pageTextures[id].baseTexture.mipmap = MIPMAP_MODES.OFF;\n      }\n    }\n    for (let i = 0; i < data.char.length; i++) {\n      const {\n        id,\n        page: page2\n      } = data.char[i];\n      let {\n        x,\n        y,\n        width,\n        height,\n        xoffset,\n        yoffset,\n        xadvance\n      } = data.char[i];\n      x /= res;\n      y /= res;\n      width /= res;\n      height /= res;\n      xoffset /= res;\n      yoffset /= res;\n      xadvance /= res;\n      const rect = new Rectangle(x + pageTextures[page2].frame.x / res, y + pageTextures[page2].frame.y / res, width, height);\n      this.chars[id] = {\n        xOffset: xoffset,\n        yOffset: yoffset,\n        xAdvance: xadvance,\n        kerning: {},\n        texture: new Texture(pageTextures[page2].baseTexture, rect),\n        page: page2\n      };\n    }\n    for (let i = 0; i < data.kerning.length; i++) {\n      let {\n        first,\n        second,\n        amount\n      } = data.kerning[i];\n      first /= res;\n      second /= res;\n      amount /= res;\n      if (this.chars[second]) {\n        this.chars[second].kerning[first] = amount;\n      }\n    }\n    this.distanceFieldRange = distanceField === null || distanceField === void 0 ? void 0 : distanceField.distanceRange;\n    this.distanceFieldType = (_distanceField$fieldT = distanceField === null || distanceField === void 0 ? void 0 : (_distanceField$fieldT2 = distanceField.fieldType) === null || _distanceField$fieldT2 === void 0 ? void 0 : _distanceField$fieldT2.toLowerCase()) !== null && _distanceField$fieldT !== void 0 ? _distanceField$fieldT : \"none\";\n  }\n  destroy() {\n    for (const id in this.chars) {\n      this.chars[id].texture.destroy();\n      this.chars[id].texture = null;\n    }\n    for (const id in this.pageTextures) {\n      if (this._ownsTextures) {\n        this.pageTextures[id].destroy(true);\n      }\n      this.pageTextures[id] = null;\n    }\n    this.chars = null;\n    this.pageTextures = null;\n  }\n  static install(data, textures, ownsTextures) {\n    let fontData;\n    if (data instanceof BitmapFontData) {\n      fontData = data;\n    } else {\n      const format = autoDetectFormat(data);\n      if (!format) {\n        throw new Error(\"Unrecognized data format for font.\");\n      }\n      fontData = format.parse(data);\n    }\n    if (textures instanceof Texture) {\n      textures = [textures];\n    }\n    const font = new _BitmapFont(fontData, textures, ownsTextures);\n    _BitmapFont.available[font.font] = font;\n    return font;\n  }\n  static uninstall(name) {\n    const font = _BitmapFont.available[name];\n    if (!font) {\n      throw new Error(\"No font found named '\".concat(name, \"'\"));\n    }\n    font.destroy();\n    delete _BitmapFont.available[name];\n  }\n  static from(name, textStyle, options) {\n    if (!name) {\n      throw new Error(\"[BitmapFont] Property `name` is required.\");\n    }\n    const {\n      chars,\n      padding,\n      resolution,\n      textureWidth,\n      textureHeight,\n      ...baseOptions\n    } = Object.assign({}, _BitmapFont.defaultOptions, options);\n    const charsList = resolveCharacters(chars);\n    const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n    const lineWidth = textureWidth;\n    const fontData = new BitmapFontData();\n    fontData.info[0] = {\n      face: style.fontFamily,\n      size: style.fontSize\n    };\n    fontData.common[0] = {\n      lineHeight: style.fontSize\n    };\n    let positionX = 0;\n    let positionY = 0;\n    let canvas;\n    let context;\n    let baseTexture;\n    let maxCharHeight = 0;\n    const baseTextures = [];\n    const textures = [];\n    for (let i = 0; i < charsList.length; i++) {\n      if (!canvas) {\n        canvas = settings.ADAPTER.createCanvas();\n        canvas.width = textureWidth;\n        canvas.height = textureHeight;\n        context = canvas.getContext(\"2d\");\n        baseTexture = new BaseTexture(canvas, {\n          resolution,\n          ...baseOptions\n        });\n        baseTextures.push(baseTexture);\n        textures.push(new Texture(baseTexture));\n        fontData.page.push({\n          id: textures.length - 1,\n          file: \"\"\n        });\n      }\n      const character = charsList[i];\n      const metrics = TextMetrics.measureText(character, style, false, canvas);\n      const width = metrics.width;\n      const height = Math.ceil(metrics.height);\n      const textureGlyphWidth = Math.ceil((style.fontStyle === \"italic\" ? 2 : 1) * width);\n      if (positionY >= textureHeight - height * resolution) {\n        if (positionY === 0) {\n          throw new Error(\"[BitmapFont] textureHeight \".concat(textureHeight, \"px is too small (fontFamily: '\").concat(style.fontFamily, \"', fontSize: \").concat(style.fontSize, \"px, char: '\").concat(character, \"')\"));\n        }\n        --i;\n        canvas = null;\n        context = null;\n        baseTexture = null;\n        positionY = 0;\n        positionX = 0;\n        maxCharHeight = 0;\n        continue;\n      }\n      maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);\n      if (textureGlyphWidth * resolution + positionX >= lineWidth) {\n        if (positionX === 0) {\n          throw new Error(\"[BitmapFont] textureWidth \".concat(textureWidth, \"px is too small (fontFamily: '\").concat(style.fontFamily, \"', fontSize: \").concat(style.fontSize, \"px, char: '\").concat(character, \"')\"));\n        }\n        --i;\n        positionY += maxCharHeight * resolution;\n        positionY = Math.ceil(positionY);\n        positionX = 0;\n        maxCharHeight = 0;\n        continue;\n      }\n      drawGlyph(canvas, context, metrics, positionX, positionY, resolution, style);\n      const id = extractCharCode(metrics.text);\n      fontData.char.push({\n        id,\n        page: textures.length - 1,\n        x: positionX / resolution,\n        y: positionY / resolution,\n        width: textureGlyphWidth,\n        height,\n        xoffset: 0,\n        yoffset: 0,\n        xadvance: width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0)\n      });\n      positionX += (textureGlyphWidth + 2 * padding) * resolution;\n      positionX = Math.ceil(positionX);\n    }\n    for (let i = 0, len = charsList.length; i < len; i++) {\n      const first = charsList[i];\n      for (let j = 0; j < len; j++) {\n        const second = charsList[j];\n        const c1 = context.measureText(first).width;\n        const c2 = context.measureText(second).width;\n        const total = context.measureText(first + second).width;\n        const amount = total - (c1 + c2);\n        if (amount) {\n          fontData.kerning.push({\n            first: extractCharCode(first),\n            second: extractCharCode(second),\n            amount\n          });\n        }\n      }\n    }\n    const font = new _BitmapFont(fontData, textures, true);\n    if (_BitmapFont.available[name] !== void 0) {\n      _BitmapFont.uninstall(name);\n    }\n    _BitmapFont.available[name] = font;\n    return font;\n  }\n};\nlet BitmapFont = _BitmapFont;\nBitmapFont.ALPHA = [[\"a\", \"z\"], [\"A\", \"Z\"], \" \"];\nBitmapFont.NUMERIC = [[\"0\", \"9\"]];\nBitmapFont.ALPHANUMERIC = [[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \" \"];\nBitmapFont.ASCII = [[\" \", \"~\"]];\nBitmapFont.defaultOptions = {\n  resolution: 1,\n  textureWidth: 512,\n  textureHeight: 512,\n  padding: 4,\n  chars: _BitmapFont.ALPHANUMERIC\n};\nBitmapFont.available = {};\nexport { BitmapFont };","map":{"version":3,"mappings":"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","names":["_BitmapFont","constructor","data","ownsTextures","info","common","page","distanceField","res","getResolutionOfUrl","file","pageTextures","_ownsTextures","font","size","lineHeight","chars","i","length","id","Array","textures","baseTexture","ALPHA_MODES","MIPMAP_MODES","char","x","y","width","height","xoffset","yoffset","xadvance","rect","Rectangle","page2","frame","xOffset","yOffset","xAdvance","kerning","texture","Texture","first","second","amount","distanceFieldRange","distanceFieldType","fieldType","_distanceField$fieldT2","toLowerCase","destroy","install","BitmapFontData","fontData","autoDetectFormat","format","Error","parse","uninstall","name","available","from","options","padding","resolution","textureWidth","textureHeight","Object","assign","defaultOptions","resolveCharacters","style","textStyle","TextStyle","lineWidth","face","positionX","positionY","maxCharHeight","baseTextures","canvas","ADAPTER","createCanvas","context","getContext","BaseTexture","baseOptions","push","character","charsList","metrics","TextMetrics","ceil","Math","fontStyle","fontFamily","fontSize","max","descent","drawGlyph","extractCharCode","text","dropShadow","dropShadowDistance","stroke","strokeThickness","len","j","c1","measureText","c2","total","BitmapFont","ALPHA","NUMERIC","ASCII"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/text-bitmap/src/BitmapFont.ts"],"sourcesContent":["import { ALPHA_MODES, BaseTexture, MIPMAP_MODES, Rectangle, settings, Texture, utils } from '@pixi/core';\nimport { TextMetrics, TextStyle } from '@pixi/text';\nimport { BitmapFontData } from './BitmapFontData';\nimport { autoDetectFormat } from './formats';\nimport { drawGlyph, extractCharCode, resolveCharacters } from './utils';\n\nimport type { IBaseTextureOptions, ICanvas, ICanvasRenderingContext2D, SCALE_MODES } from '@pixi/core';\nimport type { ITextStyle } from '@pixi/text';\n\nexport interface IBitmapFontCharacter\n{\n    xOffset: number;\n    yOffset: number;\n    xAdvance: number;\n    texture: Texture;\n    page: number;\n    kerning: utils.Dict<number>;\n}\n\ntype BaseOptions = Pick<IBaseTextureOptions, 'scaleMode' | 'mipmap' | 'anisotropicLevel' | 'alphaMode'>;\n\n/** @memberof PIXI */\nexport interface IBitmapFontOptions extends BaseOptions\n{\n    /**\n     * Characters included in the font set. You can also use ranges.\n     * For example, `[['a', 'z'], ['A', 'Z'], \"!@#$%^&*()~{}[] \"]`.\n     * Don't forget to include spaces ' ' in your character set!\n     * @default PIXI.BitmapFont.ALPHANUMERIC\n     */\n    chars?: string | (string | string[])[];\n\n    /**\n     * Render resolution for glyphs.\n     * @default 1\n     */\n    resolution?: number;\n\n    /**\n     * Padding between glyphs on texture atlas. Lower values could mean more visual artifacts\n     * and bleeding from other glyphs, larger values increase the space required on the texture.\n     * @default 4\n     */\n    padding?: number;\n\n    /**\n     * Optional width of atlas, smaller values to reduce memory.\n     * @default 512\n     */\n    textureWidth?: number;\n\n    /**\n     * Optional height of atlas, smaller values to reduce memory.\n     * @default 512\n     */\n    textureHeight?: number;\n\n    /**\n     * If mipmapping is enabled for texture. For instance, by default PixiJS only enables mipmapping\n     * on Power-of-Two textures. If your textureWidth or textureHeight are not power-of-two, you\n     * may consider enabling mipmapping to get better quality with lower font sizes. Note:\n     * for MSDF/SDF fonts, mipmapping is not supported.\n     * @default PIXI.BaseTexture.defaultOptions.mipmap\n     */\n    mipmap?: MIPMAP_MODES;\n\n    /**\n     * Anisotropic filtering level of texture.\n     * @default PIXI.BaseTexture.defaultOptions.anisotropicLevel\n     */\n    anisotropicLevel?: number;\n\n    /**\n     * Default scale mode, linear, nearest. Nearest can be helpful for bitmap-style fonts.\n     * @default PIXI.BaseTexture.defaultOptions.scaleMode\n     */\n    scaleMode?: SCALE_MODES;\n\n    /**\n     * Pre multiply the image alpha.  Note: for MSDF/SDF fonts, alphaMode is not supported.\n     * @default PIXI.BaseTexture.defaultOptions.alphaMode\n     */\n    alphaMode?: ALPHA_MODES;\n}\n\n/**\n * BitmapFont represents a typeface available for use with the BitmapText class. Use the `install`\n * method for adding a font to be used.\n * @memberof PIXI\n */\nexport class BitmapFont\n{\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    public static readonly ALPHA = [['a', 'z'], ['A', 'Z'], ' '];\n\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    public static readonly NUMERIC = [['0', '9']];\n\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    public static readonly ALPHANUMERIC = [['a', 'z'], ['A', 'Z'], ['0', '9'], ' '];\n\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    public static readonly ASCII = [[' ', '~']];\n\n    /**\n     * Collection of default options when using `BitmapFont.from`.\n     * @property {number} [resolution=1] -\n     * @property {number} [textureWidth=512] -\n     * @property {number} [textureHeight=512] -\n     * @property {number} [padding=4] -\n     * @property {string|string[]|string[][]} chars = PIXI.BitmapFont.ALPHANUMERIC\n     */\n    public static readonly defaultOptions: IBitmapFontOptions = {\n        resolution: 1,\n        textureWidth: 512,\n        textureHeight: 512,\n        padding: 4,\n        chars: BitmapFont.ALPHANUMERIC,\n    };\n\n    /** Collection of available/installed fonts. */\n    public static readonly available: utils.Dict<BitmapFont> = {};\n\n    /** The name of the font face. */\n    public readonly font: string;\n\n    /** The size of the font face in pixels. */\n    public readonly size: number;\n\n    /** The line-height of the font face in pixels. */\n    public readonly lineHeight: number;\n\n    /** The map of characters by character code. */\n    public readonly chars: utils.Dict<IBitmapFontCharacter>;\n\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    public readonly pageTextures: utils.Dict<Texture>;\n\n    /** The range of the distance field in pixels. */\n    public readonly distanceFieldRange: number;\n\n    /** The kind of distance field for this font or \"none\". */\n    public readonly distanceFieldType: string;\n\n    private _ownsTextures: boolean;\n\n    /**\n     * @param data\n     * @param textures\n     * @param ownsTextures - Setting to `true` will destroy page textures\n     *        when the font is uninstalled.\n     */\n    constructor(data: BitmapFontData, textures: Texture[] | utils.Dict<Texture>, ownsTextures?: boolean)\n    {\n        const [info] = data.info;\n        const [common] = data.common;\n        const [page] = data.page;\n        const [distanceField] = data.distanceField;\n        const res = utils.getResolutionOfUrl(page.file);\n        const pageTextures: utils.Dict<Texture> = {};\n\n        this._ownsTextures = ownsTextures;\n        this.font = info.face;\n        this.size = info.size;\n        this.lineHeight = common.lineHeight / res;\n        this.chars = {};\n        this.pageTextures = pageTextures;\n\n        // Convert the input Texture, Textures or object\n        // into a page Texture lookup by \"id\"\n        for (let i = 0; i < data.page.length; i++)\n        {\n            const { id, file } = data.page[i];\n\n            pageTextures[id] = textures instanceof Array\n                ? textures[i] : textures[file];\n\n            // only MSDF and SDF fonts need no-premultiplied-alpha\n            if (distanceField?.fieldType && distanceField.fieldType !== 'none')\n            {\n                pageTextures[id].baseTexture.alphaMode = ALPHA_MODES.NO_PREMULTIPLIED_ALPHA;\n                pageTextures[id].baseTexture.mipmap = MIPMAP_MODES.OFF;\n            }\n        }\n\n        // parse letters\n        for (let i = 0; i < data.char.length; i++)\n        {\n            const { id, page } = data.char[i];\n            let { x, y, width, height, xoffset, yoffset, xadvance } = data.char[i];\n\n            x /= res;\n            y /= res;\n            width /= res;\n            height /= res;\n            xoffset /= res;\n            yoffset /= res;\n            xadvance /= res;\n\n            const rect = new Rectangle(\n                x + (pageTextures[page].frame.x / res),\n                y + (pageTextures[page].frame.y / res),\n                width,\n                height\n            );\n\n            this.chars[id] = {\n                xOffset: xoffset,\n                yOffset: yoffset,\n                xAdvance: xadvance,\n                kerning: {},\n                texture: new Texture(\n                    pageTextures[page].baseTexture,\n                    rect\n                ),\n                page,\n            };\n        }\n\n        // parse kernings\n        for (let i = 0; i < data.kerning.length; i++)\n        {\n            let { first, second, amount } = data.kerning[i];\n\n            first /= res;\n            second /= res;\n            amount /= res;\n\n            if (this.chars[second])\n            {\n                this.chars[second].kerning[first] = amount;\n            }\n        }\n\n        // Store distance field information\n        this.distanceFieldRange = distanceField?.distanceRange;\n        this.distanceFieldType = distanceField?.fieldType?.toLowerCase() ?? 'none';\n    }\n\n    /** Remove references to created glyph textures. */\n    public destroy(): void\n    {\n        for (const id in this.chars)\n        {\n            this.chars[id].texture.destroy();\n            this.chars[id].texture = null;\n        }\n\n        for (const id in this.pageTextures)\n        {\n            if (this._ownsTextures)\n            {\n                this.pageTextures[id].destroy(true);\n            }\n\n            this.pageTextures[id] = null;\n        }\n\n        // Set readonly null.\n        (this as any).chars = null;\n        (this as any).pageTextures = null;\n    }\n\n    /**\n     * Register a new bitmap font.\n     * @param data - The\n     *        characters map that could be provided as xml or raw string.\n     * @param textures - List of textures for each page.\n     * @param ownsTextures - Set to `true` to destroy page textures\n     *        when the font is uninstalled. By default fonts created with\n     *        `BitmapFont.from` or from the `BitmapFontLoader` are `true`.\n     * @returns {PIXI.BitmapFont} Result font object with font, size, lineHeight\n     *         and char fields.\n     */\n    public static install(\n        data: string | XMLDocument | BitmapFontData,\n        textures: Texture | Texture[] | utils.Dict<Texture>,\n        ownsTextures?: boolean\n    ): BitmapFont\n    {\n        let fontData;\n\n        if (data instanceof BitmapFontData)\n        {\n            fontData = data;\n        }\n        else\n        {\n            const format = autoDetectFormat(data);\n\n            if (!format)\n            {\n                throw new Error('Unrecognized data format for font.');\n            }\n\n            fontData = format.parse(data as any);\n        }\n\n        // Single texture, convert to list\n        if (textures instanceof Texture)\n        {\n            textures = [textures];\n        }\n\n        const font = new BitmapFont(fontData, textures, ownsTextures);\n\n        BitmapFont.available[font.font] = font;\n\n        return font;\n    }\n\n    /**\n     * Remove bitmap font by name.\n     * @param name - Name of the font to uninstall.\n     */\n    public static uninstall(name: string): void\n    {\n        const font = BitmapFont.available[name];\n\n        if (!font)\n        {\n            throw new Error(`No font found named '${name}'`);\n        }\n\n        font.destroy();\n        delete BitmapFont.available[name];\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set. This does not support\n     * kernings yet. With `style` properties, only the following non-layout properties are used:\n     *\n     * - {@link PIXI.TextStyle#dropShadow|dropShadow}\n     * - {@link PIXI.TextStyle#dropShadowDistance|dropShadowDistance}\n     * - {@link PIXI.TextStyle#dropShadowColor|dropShadowColor}\n     * - {@link PIXI.TextStyle#dropShadowBlur|dropShadowBlur}\n     * - {@link PIXI.TextStyle#dropShadowAngle|dropShadowAngle}\n     * - {@link PIXI.TextStyle#fill|fill}\n     * - {@link PIXI.TextStyle#fillGradientStops|fillGradientStops}\n     * - {@link PIXI.TextStyle#fillGradientType|fillGradientType}\n     * - {@link PIXI.TextStyle#fontFamily|fontFamily}\n     * - {@link PIXI.TextStyle#fontSize|fontSize}\n     * - {@link PIXI.TextStyle#fontVariant|fontVariant}\n     * - {@link PIXI.TextStyle#fontWeight|fontWeight}\n     * - {@link PIXI.TextStyle#lineJoin|lineJoin}\n     * - {@link PIXI.TextStyle#miterLimit|miterLimit}\n     * - {@link PIXI.TextStyle#stroke|stroke}\n     * - {@link PIXI.TextStyle#strokeThickness|strokeThickness}\n     * - {@link PIXI.TextStyle#textBaseline|textBaseline}\n     * @param name - The name of the custom font to use with BitmapText.\n     * @param textStyle - Style options to render with BitmapFont.\n     * @param options - Setup options for font or name of the font.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFont, BitmapText } from 'pixi.js';\n     *\n     * BitmapFont.from('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText('This is the title', { fontName: 'TitleFont' });\n     */\n    public static from(name: string, textStyle?: TextStyle | Partial<ITextStyle>, options?: IBitmapFontOptions): BitmapFont\n    {\n        if (!name)\n        {\n            throw new Error('[BitmapFont] Property `name` is required.');\n        }\n\n        const {\n            chars,\n            padding,\n            resolution,\n            textureWidth,\n            textureHeight,\n            ...baseOptions\n        } = Object.assign({}, BitmapFont.defaultOptions, options);\n\n        const charsList = resolveCharacters(chars);\n        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n        const lineWidth = textureWidth;\n        const fontData = new BitmapFontData();\n\n        fontData.info[0] = {\n            face: style.fontFamily as string,\n            size: style.fontSize as number,\n        };\n        fontData.common[0] = {\n            lineHeight: style.fontSize as number,\n        };\n\n        let positionX = 0;\n        let positionY = 0;\n\n        let canvas: ICanvas;\n        let context: ICanvasRenderingContext2D;\n        let baseTexture: BaseTexture;\n        let maxCharHeight = 0;\n        const baseTextures: BaseTexture[] = [];\n        const textures: Texture[] = [];\n\n        for (let i = 0; i < charsList.length; i++)\n        {\n            if (!canvas)\n            {\n                canvas = settings.ADAPTER.createCanvas();\n                canvas.width = textureWidth;\n                canvas.height = textureHeight;\n\n                context = canvas.getContext('2d');\n                baseTexture = new BaseTexture(canvas, { resolution, ...baseOptions });\n\n                baseTextures.push(baseTexture);\n                textures.push(new Texture(baseTexture));\n\n                fontData.page.push({\n                    id: textures.length - 1,\n                    file: '',\n                });\n            }\n\n            // Measure glyph dimensions\n            const character = charsList[i];\n            const metrics = TextMetrics.measureText(character, style, false, canvas);\n            const width = metrics.width;\n            const height = Math.ceil(metrics.height);\n\n            // This is ugly - but italics are given more space so they don't overlap\n            const textureGlyphWidth = Math.ceil((style.fontStyle === 'italic' ? 2 : 1) * width);\n\n            // Can't fit char anymore: next canvas please!\n            if (positionY >= textureHeight - (height * resolution))\n            {\n                if (positionY === 0)\n                {\n                    // We don't want user debugging an infinite loop (or do we? :)\n                    throw new Error(`[BitmapFont] textureHeight ${textureHeight}px is too small `\n                        + `(fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);\n                }\n\n                --i;\n\n                // Create new atlas once current has filled up\n                canvas = null;\n                context = null;\n                baseTexture = null;\n                positionY = 0;\n                positionX = 0;\n                maxCharHeight = 0;\n\n                continue;\n            }\n\n            maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);\n\n            // Wrap line once full row has been rendered\n            if ((textureGlyphWidth * resolution) + positionX >= lineWidth)\n            {\n                if (positionX === 0)\n                {\n                    // Avoid infinite loop (There can be some very wide char like '\\uFDFD'!)\n                    throw new Error(`[BitmapFont] textureWidth ${textureWidth}px is too small `\n                        + `(fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);\n                }\n\n                --i;\n                positionY += maxCharHeight * resolution;\n                positionY = Math.ceil(positionY);\n                positionX = 0;\n                maxCharHeight = 0;\n\n                continue;\n            }\n\n            drawGlyph(canvas, context, metrics, positionX, positionY, resolution, style);\n\n            // Unique (numeric) ID mapping to this glyph\n            const id = extractCharCode(metrics.text);\n\n            // Create a texture holding just the glyph\n            fontData.char.push({\n                id,\n                page: textures.length - 1,\n                x: positionX / resolution,\n                y: positionY / resolution,\n                width: textureGlyphWidth,\n                height,\n                xoffset: 0,\n                yoffset: 0,\n                xadvance: width\n                        - (style.dropShadow ? style.dropShadowDistance : 0)\n                        - (style.stroke ? style.strokeThickness : 0),\n            });\n\n            positionX += (textureGlyphWidth + (2 * padding)) * resolution;\n            positionX = Math.ceil(positionX);\n        }\n\n        // Brute-force kerning info, this can be expensive b/c it's an O(n²),\n        // but we're using measureText which is native and fast.\n        for (let i = 0, len = charsList.length; i < len; i++)\n        {\n            const first = charsList[i];\n\n            for (let j = 0; j < len; j++)\n            {\n                const second = charsList[j];\n                const c1 = context.measureText(first).width;\n                const c2 = context.measureText(second).width;\n                const total = context.measureText(first + second).width;\n                const amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    fontData.kerning.push({\n                        first: extractCharCode(first),\n                        second: extractCharCode(second),\n                        amount,\n                    });\n                }\n            }\n        }\n\n        const font = new BitmapFont(fontData, textures, true);\n\n        // Make it easier to replace a font\n        if (BitmapFont.available[name] !== undefined)\n        {\n            BitmapFont.uninstall(name);\n        }\n\n        BitmapFont.available[name] = font;\n\n        return font;\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}