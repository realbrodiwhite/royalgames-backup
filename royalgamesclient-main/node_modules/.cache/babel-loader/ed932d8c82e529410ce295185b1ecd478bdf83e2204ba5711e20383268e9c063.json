{"ast":null,"code":"import { ALPHA_MODES } from '@pixi/constants';\nimport { determineCrossOrigin } from '@pixi/utils';\nimport { Resource } from './Resource.mjs';\nclass BaseImageResource extends Resource {\n  constructor(source) {\n    const sourceAny = source;\n    const width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;\n    const height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;\n    super(width, height);\n    this.source = source;\n    this.noSubImage = false;\n  }\n  static crossOrigin(element, url, crossorigin) {\n    if (crossorigin === void 0 && !url.startsWith(\"data:\")) {\n      element.crossOrigin = determineCrossOrigin(url);\n    } else if (crossorigin !== false) {\n      element.crossOrigin = typeof crossorigin === \"string\" ? crossorigin : \"anonymous\";\n    }\n  }\n  upload(renderer, baseTexture, glTexture, source) {\n    const gl = renderer.gl;\n    const width = baseTexture.realWidth;\n    const height = baseTexture.realHeight;\n    source = source || this.source;\n    if (typeof HTMLImageElement !== \"undefined\" && source instanceof HTMLImageElement) {\n      if (!source.complete || source.naturalWidth === 0) {\n        return false;\n      }\n    } else if (typeof HTMLVideoElement !== \"undefined\" && source instanceof HTMLVideoElement) {\n      if (source.readyState <= 1 && source.buffered.length === 0) {\n        return false;\n      }\n    }\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);\n    if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {\n      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);\n    } else {\n      glTexture.width = width;\n      glTexture.height = height;\n      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);\n    }\n    return true;\n  }\n  update() {\n    if (this.destroyed) {\n      return;\n    }\n    const source = this.source;\n    const width = source.naturalWidth || source.videoWidth || source.width;\n    const height = source.naturalHeight || source.videoHeight || source.height;\n    this.resize(width, height);\n    super.update();\n  }\n  dispose() {\n    this.source = null;\n  }\n}\nexport { BaseImageResource };","map":{"version":3,"mappings":";;;AAYO,MAAMA,0BAA0BC,QACvC;EAmBIC,YAAYC,MACZ;IACI,MAAMC,SAAY;IAClB,MAAMC,KAAQ,aAAUC,YAAgB,cAAUC,cAAcH,SAAU;IAC1E,MAAMI,MAAS,aAAUC,aAAiB,cAAUC,eAAeN,SAAU;IAE7E,MAAMC,OAAOG,MAAM;IAEnB,KAAKL,MAAS;IACd,KAAKQ,UAAa;EAAA;EAStB,OAAOC,YAAYC,OAA8C,OAAaC,WAC9E;IACI,IAAIA,gBAAgB,KAAa,MAACC,GAAI,YAAW,OAAO,CACxD;MACYF,sBAAcG,qBAAqBD,GAAG;IAAA,CAClD,UACSD,gBAAgB,KACzB;MACID,QAAQD,WAAc,UAAOE,WAAgB,gBAAWA,WAAc;IAAA;EAC1E;EAWJG,MAASA,CAAOC,QAAoB,eAA0BC,WAAsBhB,MACpF;IACI,MAAMiB,KAAKF,QAAS;IACpB,MAAMb,QAAQgB,WAAY;IAC1B,MAAMb,SAASa,WAAY;IAE3BlB,SAASA,UAAU,IAAK;IAExB,IAAI,OAAOmB,qBAAqB,WAAe,sBAAkBA,gBACjE;MACI,IAAI,CAACnB,OAAOoB,QAAY,WAAOjB,iBAAiB,CAChD;QACW;MAAA;IACX,CAEK,iBAAOkB,gBAAqB,oBAAerB,kBAAkBqB,gBACtE;MACI,IAAIrB,OAAOsB,UAAc,SAAKtB,MAAO,UAASuB,WAAW,CACzD;QACW;MAAA;IACX;IAGJN,GAAGO,YAAYP,EAAG,iCAAgCC,WAAY,eAAcO,YAAYC,MAAM;IAE9F,IAAI,CAAC,KAAKlB,UACH,gBAAYmB,MAAW,QAAGC,UAC1B,cAAU1B,KAAU,cACpBc,SAAU,YAAWX,MAC5B;MACOY,iBAAcA,EAAG,aAAY,CAAG,KAAG,GAAGC,WAAY,SAAQF,SAAU,OAAMhB,MAAM;IAAA,CAGvF;MACIgB,UAAUd,KAAQ;MAClBc,UAAUX,MAAS;MAEhBY,cAAWC,WAAY,SAAQ,CAAG,YAAUW,gBAAgBX,WAAY,SAAQF,SAAU,OAAMhB,MAAM;IAAA;IAGtG;EAAA;EAOX8B,MACAA;IACI,IAAI,KAAKC,SACT;MACI;IAAA;IAGJ,MAAM/B,SAAS,IAAK;IAEpB,MAAME,KAAQ,UAAOC,YAAgB,WAAOC,cAAcJ,MAAO;IACjE,MAAMK,MAAS,UAAOC,aAAiB,WAAOC,eAAeP,MAAO;IAE/D,YAAOE,OAAOG,MAAM;IAEzB,MAAMyB,MAAO;EAAA;EAIjBE,OACAA;IACI,KAAKhC,MAAS;EAAA;AAEtB","names":["BaseImageResource","Resource","constructor","source","sourceAny","width","naturalWidth","videoWidth","height","naturalHeight","videoHeight","noSubImage","crossOrigin","element","crossorigin","url","determineCrossOrigin","upload","renderer","glTexture","gl","baseTexture","HTMLImageElement","complete","HTMLVideoElement","readyState","length","pixelStorei","ALPHA_MODES","UNPACK","target","TEXTURE_2D","internalFormat","update","destroyed","dispose"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/core/src/textures/resources/BaseImageResource.ts"],"sourcesContent":["import { ALPHA_MODES } from '@pixi/constants';\nimport { determineCrossOrigin } from '@pixi/utils';\nimport { Resource } from './Resource';\n\nimport type { Renderer } from '../../Renderer';\nimport type { BaseTexture, ImageSource } from '../BaseTexture';\nimport type { GLTexture } from '../GLTexture';\n\n/**\n * Base for all the image/canvas resources.\n * @memberof PIXI\n */\nexport class BaseImageResource extends Resource\n{\n    /**\n     * The source element.\n     * @member {HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas}\n     * @readonly\n     */\n    public source: ImageSource;\n\n    /**\n     * If set to `true`, will force `texImage2D` over `texSubImage2D` for uploading.\n     * Certain types of media (e.g. video) using `texImage2D` is more performant.\n     * @default false\n     * @private\n     */\n    public noSubImage: boolean;\n\n    /**\n     * @param {HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas} source\n     */\n    constructor(source: ImageSource)\n    {\n        const sourceAny = source as any;\n        const width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;\n        const height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;\n\n        super(width, height);\n\n        this.source = source;\n        this.noSubImage = false;\n    }\n\n    /**\n     * Set cross origin based detecting the url and the crossorigin\n     * @param element - Element to apply crossOrigin\n     * @param url - URL to check\n     * @param crossorigin - Cross origin value to use\n     */\n    static crossOrigin(element: HTMLImageElement | HTMLVideoElement, url: string, crossorigin?: boolean | string): void\n    {\n        if (crossorigin === undefined && !url.startsWith('data:'))\n        {\n            element.crossOrigin = determineCrossOrigin(url);\n        }\n        else if (crossorigin !== false)\n        {\n            element.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';\n        }\n    }\n\n    /**\n     * Upload the texture to the GPU.\n     * @param renderer - Upload to the renderer\n     * @param baseTexture - Reference to parent texture\n     * @param glTexture\n     * @param {HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas} [source] - (optional)\n     * @returns - true is success\n     */\n    override upload(renderer: Renderer, baseTexture: BaseTexture, glTexture: GLTexture, source?: ImageSource): boolean\n    {\n        const gl = renderer.gl;\n        const width = baseTexture.realWidth;\n        const height = baseTexture.realHeight;\n\n        source = source || this.source;\n\n        if (typeof HTMLImageElement !== 'undefined' && source instanceof HTMLImageElement)\n        {\n            if (!source.complete || source.naturalWidth === 0)\n            {\n                return false;\n            }\n        }\n        else if (typeof HTMLVideoElement !== 'undefined' && source instanceof HTMLVideoElement)\n        {\n            if (source.readyState <= 1 && source.buffered.length === 0)\n            {\n                return false;\n            }\n        }\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);\n\n        if (!this.noSubImage\n            && baseTexture.target === gl.TEXTURE_2D\n            && glTexture.width === width\n            && glTexture.height === height)\n        {\n            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);\n        }\n        else\n        {\n            glTexture.width = width;\n            glTexture.height = height;\n\n            gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);\n        }\n\n        return true;\n    }\n\n    /**\n     * Checks if source width/height was changed, resize can cause extra baseTexture update.\n     * Triggers one update in any case.\n     */\n    override update(): void\n    {\n        if (this.destroyed)\n        {\n            return;\n        }\n\n        const source = this.source as any;\n\n        const width = source.naturalWidth || source.videoWidth || source.width;\n        const height = source.naturalHeight || source.videoHeight || source.height;\n\n        this.resize(width, height);\n\n        super.update();\n    }\n\n    /** Destroy this {@link BaseImageResource} */\n    override dispose(): void\n    {\n        this.source = null;\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}