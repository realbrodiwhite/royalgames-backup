{"ast":null,"code":"import { BitmapFontData } from '../BitmapFontData.mjs';\nclass XMLFormat {\n  static test(data) {\n    const xml = data;\n    return \"getElementsByTagName\" in xml && xml.getElementsByTagName(\"page\").length && xml.getElementsByTagName(\"info\")[0].getAttribute(\"face\") !== null;\n  }\n  static parse(xml) {\n    const data = new BitmapFontData();\n    const info = xml.getElementsByTagName(\"info\");\n    const common = xml.getElementsByTagName(\"common\");\n    const page = xml.getElementsByTagName(\"page\");\n    const char = xml.getElementsByTagName(\"char\");\n    const kerning = xml.getElementsByTagName(\"kerning\");\n    const distanceField = xml.getElementsByTagName(\"distanceField\");\n    for (let i = 0; i < info.length; i++) {\n      data.info.push({\n        face: info[i].getAttribute(\"face\"),\n        size: parseInt(info[i].getAttribute(\"size\"), 10)\n      });\n    }\n    for (let i = 0; i < common.length; i++) {\n      data.common.push({\n        lineHeight: parseInt(common[i].getAttribute(\"lineHeight\"), 10)\n      });\n    }\n    for (let i = 0; i < page.length; i++) {\n      data.page.push({\n        id: parseInt(page[i].getAttribute(\"id\"), 10) || 0,\n        file: page[i].getAttribute(\"file\")\n      });\n    }\n    for (let i = 0; i < char.length; i++) {\n      const letter = char[i];\n      data.char.push({\n        id: parseInt(letter.getAttribute(\"id\"), 10),\n        page: parseInt(letter.getAttribute(\"page\"), 10) || 0,\n        x: parseInt(letter.getAttribute(\"x\"), 10),\n        y: parseInt(letter.getAttribute(\"y\"), 10),\n        width: parseInt(letter.getAttribute(\"width\"), 10),\n        height: parseInt(letter.getAttribute(\"height\"), 10),\n        xoffset: parseInt(letter.getAttribute(\"xoffset\"), 10),\n        yoffset: parseInt(letter.getAttribute(\"yoffset\"), 10),\n        xadvance: parseInt(letter.getAttribute(\"xadvance\"), 10)\n      });\n    }\n    for (let i = 0; i < kerning.length; i++) {\n      data.kerning.push({\n        first: parseInt(kerning[i].getAttribute(\"first\"), 10),\n        second: parseInt(kerning[i].getAttribute(\"second\"), 10),\n        amount: parseInt(kerning[i].getAttribute(\"amount\"), 10)\n      });\n    }\n    for (let i = 0; i < distanceField.length; i++) {\n      data.distanceField.push({\n        fieldType: distanceField[i].getAttribute(\"fieldType\"),\n        distanceRange: parseInt(distanceField[i].getAttribute(\"distanceRange\"), 10)\n      });\n    }\n    return data;\n  }\n}\nexport { XMLFormat };","map":{"version":3,"mappings":";AAMO,MAAMA,SACb;EAMI,OAAOC,KAAKC,IACZ;IACI,MAAMC,GAAM;IAEZ,OAAO,sBAA0B,WAC1BA,GAAI,sBAAqB,MAAM,CAAE,WACjCA,GAAI,sBAAqB,MAAM,EAAE,CAAG,eAAa,MAAM,CAAM;EAAA;EAQxE,OAAOC,MAAMD,GACb;IACU,aAAO,IAAIE,cAAe;IAC1B,aAAOF,GAAI,sBAAqB,MAAM;IACtC,eAASA,GAAI,sBAAqB,QAAQ;IAC1C,aAAOA,GAAI,sBAAqB,MAAM;IACtC,aAAOA,GAAI,sBAAqB,MAAM;IACtC,gBAAUA,GAAI,sBAAqB,SAAS;IAC5C,sBAAgBA,GAAI,sBAAqB,eAAe;IAE9D,SAASG,CAAI,MAAGA,CAAI,QAAKC,QAAQD,CACjC;MACIJ,KAAKM,KAAKC,IAAK;QACXC,IAAM,OAAKJ,CAAG,eAAa,MAAM;QACjCK,MAAMC,QAAS,MAAKN,GAAGO,YAAa,OAAM,GAAG,EAAE;MAAA,CAClD;IAAA;IAGL,SAASP,CAAI,MAAGA,CAAI,UAAOC,QAAQD,CACnC;MACIJ,KAAKY,OAAOL,IAAK;QACbM,YAAYH,QAAS,QAAON,GAAGO,YAAa,aAAY,GAAG,EAAE;MAAA,CAChE;IAAA;IAGL,SAASP,CAAI,MAAGA,CAAI,QAAKC,QAAQD,CACjC;MACIJ,KAAKc,KAAKP,IAAK;QACXQ,IAAIL,SAASI,IAAK,IAAGH,aAAa,IAAI,GAAG,EAAE,CAAK;QAChDK,IAAM,OAAKZ,CAAG,eAAa,MAAM;MAAA,CACpC;IAAA;IAGL,SAASA,CAAI,MAAGA,CAAI,QAAKC,QAAQD,CACjC;MACI,MAAMa,SAASC,IAAK;MAEpBlB,KAAKkB,KAAKX,IAAK;QACXQ,IAAIL,QAAS,QAAOC,YAAa,KAAI,GAAG,EAAE;QAC1CG,MAAMJ,QAAS,QAAOC,aAAa,MAAM,GAAG,EAAE,CAAK;QACnDQ,GAAGT,QAAS,QAAOC,YAAa,IAAG,GAAG,EAAE;QACxCS,GAAGV,QAAS,QAAOC,YAAa,IAAG,GAAG,EAAE;QACxCU,OAAOX,QAAS,QAAOC,YAAa,QAAO,GAAG,EAAE;QAChDW,QAAQZ,QAAS,QAAOC,YAAa,SAAQ,GAAG,EAAE;QAClDY,SAASb,QAAS,QAAOC,YAAa,UAAS,GAAG,EAAE;QACpDa,SAASd,QAAS,QAAOC,YAAa,UAAS,GAAG,EAAE;QACpDc,UAAUf,QAAS,QAAOC,YAAa,WAAU,GAAG,EAAE;MAAA,CACzD;IAAA;IAGL,SAASP,CAAI,MAAGA,CAAI,WAAQC,QAAQD,CACpC;MACIJ,KAAK0B,QAAQnB,IAAK;QACdoB,OAAOjB,QAAS,SAAQN,GAAGO,YAAa,QAAO,GAAG,EAAE;QACpDiB,QAAQlB,QAAS,SAAQN,GAAGO,YAAa,SAAQ,GAAG,EAAE;QACtDkB,QAAQnB,QAAS,SAAQN,GAAGO,YAAa,SAAQ,GAAG,EAAE;MAAA,CACzD;IAAA;IAGL,SAASP,CAAI,MAAGA,CAAI,iBAAcC,QAAQD,CAC1C;MACIJ,KAAK8B,cAAcvB,IAAK;QACpBwB,SAAW,gBAAc3B,CAAG,eAAa,WAAW;QACpD4B,eAAetB,QAAS,eAAcN,GAAGO,YAAa,gBAAe,GAAG,EAAE;MAAA,CAC7E;IAAA;IAGE;EAAA;AAEf","names":["XMLFormat","test","data","xml","parse","BitmapFontData","i","length","info","push","face","size","parseInt","getAttribute","common","lineHeight","page","id","file","letter","char","x","y","width","height","xoffset","yoffset","xadvance","kerning","first","second","amount","distanceField","fieldType","distanceRange"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/text-bitmap/src/formats/XMLFormat.ts"],"sourcesContent":["import { BitmapFontData } from '../BitmapFontData';\n\n/**\n * BitmapFont format that's XML-based.\n * @private\n */\nexport class XMLFormat\n{\n    /**\n     * Check if resource refers to xml font data.\n     * @param data\n     * @returns - True if resource could be treated as font data, false otherwise.\n     */\n    static test(data: unknown): boolean\n    {\n        const xml = data as Document;\n\n        return 'getElementsByTagName' in xml\n            && xml.getElementsByTagName('page').length\n            && xml.getElementsByTagName('info')[0].getAttribute('face') !== null;\n    }\n\n    /**\n     * Convert the XML into BitmapFontData that we can use.\n     * @param xml\n     * @returns - Data to use for BitmapFont\n     */\n    static parse(xml: Document): BitmapFontData\n    {\n        const data = new BitmapFontData();\n        const info = xml.getElementsByTagName('info');\n        const common = xml.getElementsByTagName('common');\n        const page = xml.getElementsByTagName('page');\n        const char = xml.getElementsByTagName('char');\n        const kerning = xml.getElementsByTagName('kerning');\n        const distanceField = xml.getElementsByTagName('distanceField');\n\n        for (let i = 0; i < info.length; i++)\n        {\n            data.info.push({\n                face: info[i].getAttribute('face'),\n                size: parseInt(info[i].getAttribute('size'), 10),\n            });\n        }\n\n        for (let i = 0; i < common.length; i++)\n        {\n            data.common.push({\n                lineHeight: parseInt(common[i].getAttribute('lineHeight'), 10),\n            });\n        }\n\n        for (let i = 0; i < page.length; i++)\n        {\n            data.page.push({\n                id: parseInt(page[i].getAttribute('id'), 10) || 0,\n                file: page[i].getAttribute('file'),\n            });\n        }\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const letter = char[i];\n\n            data.char.push({\n                id: parseInt(letter.getAttribute('id'), 10),\n                page: parseInt(letter.getAttribute('page'), 10) || 0,\n                x: parseInt(letter.getAttribute('x'), 10),\n                y: parseInt(letter.getAttribute('y'), 10),\n                width: parseInt(letter.getAttribute('width'), 10),\n                height: parseInt(letter.getAttribute('height'), 10),\n                xoffset: parseInt(letter.getAttribute('xoffset'), 10),\n                yoffset: parseInt(letter.getAttribute('yoffset'), 10),\n                xadvance: parseInt(letter.getAttribute('xadvance'), 10),\n            });\n        }\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            data.kerning.push({\n                first: parseInt(kerning[i].getAttribute('first'), 10),\n                second: parseInt(kerning[i].getAttribute('second'), 10),\n                amount: parseInt(kerning[i].getAttribute('amount'), 10),\n            });\n        }\n\n        for (let i = 0; i < distanceField.length; i++)\n        {\n            data.distanceField.push({\n                fieldType: distanceField[i].getAttribute('fieldType'),\n                distanceRange: parseInt(distanceField[i].getAttribute('distanceRange'), 10),\n            });\n        }\n\n        return data;\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}