{"ast":null,"code":"import { ExtensionType, extensions } from '@pixi/extensions';\nimport { Matrix, Rectangle } from '@pixi/math';\nimport { settings } from '@pixi/settings';\nimport { AbstractMaskSystem } from './AbstractMaskSystem.mjs';\nconst tempMatrix = new Matrix();\nconst rectPool = [];\nconst _ScissorSystem = class extends AbstractMaskSystem {\n  constructor(renderer) {\n    super(renderer);\n    this.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;\n  }\n  getStackLength() {\n    const maskData = this.maskStack[this.maskStack.length - 1];\n    if (maskData) {\n      return maskData._scissorCounter;\n    }\n    return 0;\n  }\n  calcScissorRect(maskData) {\n    var _rectPool$pop;\n    if (maskData._scissorRectLocal) {\n      return;\n    }\n    const prevData = maskData._scissorRect;\n    const {\n      maskObject\n    } = maskData;\n    const {\n      renderer\n    } = this;\n    const renderTextureSystem = renderer.renderTexture;\n    const rect = maskObject.getBounds(true, (_rectPool$pop = rectPool.pop()) !== null && _rectPool$pop !== void 0 ? _rectPool$pop : new Rectangle());\n    this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);\n    if (prevData) {\n      rect.fit(prevData);\n    }\n    maskData._scissorRectLocal = rect;\n  }\n  static isMatrixRotated(matrix) {\n    if (!matrix) {\n      return false;\n    }\n    const {\n      a,\n      b,\n      c,\n      d\n    } = matrix;\n    return (Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4);\n  }\n  testScissor(maskData) {\n    const {\n      maskObject\n    } = maskData;\n    if (!maskObject.isFastRect || !maskObject.isFastRect()) {\n      return false;\n    }\n    if (_ScissorSystem.isMatrixRotated(maskObject.worldTransform)) {\n      return false;\n    }\n    if (_ScissorSystem.isMatrixRotated(this.renderer.projection.transform)) {\n      return false;\n    }\n    this.calcScissorRect(maskData);\n    const rect = maskData._scissorRectLocal;\n    return rect.width > 0 && rect.height > 0;\n  }\n  roundFrameToPixels(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {\n    if (_ScissorSystem.isMatrixRotated(transform)) {\n      return;\n    }\n    transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();\n    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);\n    this.renderer.filter.transformAABB(transform, frame);\n    frame.fit(bindingDestinationFrame);\n    frame.x = Math.round(frame.x * resolution);\n    frame.y = Math.round(frame.y * resolution);\n    frame.width = Math.round(frame.width * resolution);\n    frame.height = Math.round(frame.height * resolution);\n  }\n  push(maskData) {\n    if (!maskData._scissorRectLocal) {\n      this.calcScissorRect(maskData);\n    }\n    const {\n      gl\n    } = this.renderer;\n    if (!maskData._scissorRect) {\n      gl.enable(gl.SCISSOR_TEST);\n    }\n    maskData._scissorCounter++;\n    maskData._scissorRect = maskData._scissorRectLocal;\n    this._useCurrent();\n  }\n  pop(maskData) {\n    const {\n      gl\n    } = this.renderer;\n    if (maskData) {\n      rectPool.push(maskData._scissorRectLocal);\n    }\n    if (this.getStackLength() > 0) {\n      this._useCurrent();\n    } else {\n      gl.disable(gl.SCISSOR_TEST);\n    }\n  }\n  _useCurrent() {\n    const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;\n    let y;\n    if (this.renderer.renderTexture.current) {\n      y = rect.y;\n    } else {\n      y = this.renderer.height - rect.height - rect.y;\n    }\n    this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);\n  }\n};\nlet ScissorSystem = _ScissorSystem;\nScissorSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"scissor\"\n};\nextensions.add(ScissorSystem);\nexport { ScissorSystem };","map":{"version":3,"mappings":"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","names":["tempMatrix","Matrix","rectPool","_ScissorSystem","AbstractMaskSystem","constructor","renderer","glConst","ADAPTER","getStackLength","maskData","maskStack","length","calcScissorRect","_scissorRectLocal","prevData","maskObject","renderTextureSystem","getBounds","pop","Rectangle","roundFrameToPixels","current","sourceFrame","destinationFrame","projection","transform","rect","fit","isMatrixRotated","matrix","a","b","c","d","abs","Math","testScissor","isFastRect","height","resolution","bindingDestinationFrame","identity","bindingSourceFrame","width","translate","x","y","filter","frame","round","push","gl","_scissorRect","SCISSOR_TEST","_useCurrent","scissor","ScissorSystem","extension","type","ExtensionType","name","extensions","add"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/core/src/mask/ScissorSystem.ts"],"sourcesContent":["import { extensions, ExtensionType } from '@pixi/extensions';\nimport { Matrix, Rectangle } from '@pixi/math';\nimport { settings } from '@pixi/settings';\nimport { AbstractMaskSystem } from './AbstractMaskSystem';\n\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { Renderer } from '../Renderer';\nimport type { MaskData } from './MaskData';\n\nconst tempMatrix = new Matrix();\nconst rectPool: Rectangle[] = [];\n\n/**\n * System plugin to the renderer to manage scissor masking.\n *\n * Scissor masking discards pixels outside of a rectangle called the scissor box. The scissor box is in the framebuffer\n * viewport's space; however, the mask's rectangle is projected from world-space to viewport space automatically\n * by this system.\n * @memberof PIXI\n */\nexport class ScissorSystem extends AbstractMaskSystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'scissor',\n    };\n\n    /**\n     * @param {PIXI.Renderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        this.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;\n    }\n\n    getStackLength(): number\n    {\n        const maskData = this.maskStack[this.maskStack.length - 1];\n\n        if (maskData)\n        {\n            return maskData._scissorCounter;\n        }\n\n        return 0;\n    }\n\n    /**\n     * evaluates _boundsTransformed, _scissorRect for MaskData\n     * @param maskData\n     */\n    calcScissorRect(maskData: MaskData): void\n    {\n        if (maskData._scissorRectLocal)\n        {\n            return;\n        }\n\n        const prevData = maskData._scissorRect;\n        const { maskObject } = maskData;\n        const { renderer } = this;\n        const renderTextureSystem = renderer.renderTexture;\n        const rect = maskObject.getBounds(true, rectPool.pop() ?? new Rectangle());\n\n        this.roundFrameToPixels(rect,\n            renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,\n            renderTextureSystem.sourceFrame,\n            renderTextureSystem.destinationFrame,\n            renderer.projection.transform);\n\n        if (prevData)\n        {\n            rect.fit(prevData);\n        }\n        maskData._scissorRectLocal = rect;\n    }\n\n    private static isMatrixRotated(matrix: Matrix)\n    {\n        if (!matrix)\n        {\n            return false;\n        }\n        const { a, b, c, d } = matrix;\n\n        // Skip if skew/rotation present in matrix, except for multiple of 90° rotation. If rotation\n        // is a multiple of 90°, then either pair of (b,c) or (a,d) will be (0,0).\n        return ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4)\n            && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4));\n    }\n\n    /**\n     * Test, whether the object can be scissor mask with current renderer projection.\n     * Calls \"calcScissorRect()\" if its true.\n     * @param maskData - mask data\n     * @returns whether Whether the object can be scissor mask\n     */\n    public testScissor(maskData: MaskData): boolean\n    {\n        const { maskObject } = maskData;\n\n        if (!maskObject.isFastRect || !maskObject.isFastRect())\n        {\n            return false;\n        }\n        if (ScissorSystem.isMatrixRotated(maskObject.worldTransform))\n        {\n            return false;\n        }\n        if (ScissorSystem.isMatrixRotated(this.renderer.projection.transform))\n        {\n            return false;\n        }\n\n        this.calcScissorRect(maskData);\n\n        const rect = maskData._scissorRectLocal;\n\n        return rect.width > 0 && rect.height > 0;\n    }\n\n    private roundFrameToPixels(\n        frame: Rectangle,\n        resolution: number,\n        bindingSourceFrame: Rectangle,\n        bindingDestinationFrame: Rectangle,\n        transform?: Matrix,\n    )\n    {\n        if (ScissorSystem.isMatrixRotated(transform))\n        {\n            return;\n        }\n\n        transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();\n\n        // Get forward transform from world space to screen space\n        transform\n            .translate(-bindingSourceFrame.x, -bindingSourceFrame.y)\n            .scale(\n                bindingDestinationFrame.width / bindingSourceFrame.width,\n                bindingDestinationFrame.height / bindingSourceFrame.height)\n            .translate(bindingDestinationFrame.x, bindingDestinationFrame.y);\n\n        // Convert frame to screen space\n        (this.renderer.filter as any).transformAABB(transform, frame);\n\n        frame.fit(bindingDestinationFrame);\n        frame.x = Math.round(frame.x * resolution);\n        frame.y = Math.round(frame.y * resolution);\n        frame.width = Math.round(frame.width * resolution);\n        frame.height = Math.round(frame.height * resolution);\n    }\n\n    /**\n     * Applies the Mask and adds it to the current stencil stack.\n     * @author alvin\n     * @param maskData - The mask data.\n     */\n    push(maskData: MaskData): void\n    {\n        if (!maskData._scissorRectLocal)\n        {\n            this.calcScissorRect(maskData);\n        }\n\n        const { gl } = this.renderer;\n\n        if (!maskData._scissorRect)\n        {\n            gl.enable(gl.SCISSOR_TEST);\n        }\n\n        maskData._scissorCounter++;\n        maskData._scissorRect = maskData._scissorRectLocal;\n        this._useCurrent();\n    }\n\n    /**\n     * This should be called after a mask is popped off the mask stack. It will rebind the scissor box to be latest with the\n     * last mask in the stack.\n     *\n     * This can also be called when you directly modify the scissor box and want to restore PixiJS state.\n     * @param maskData - The mask data.\n     */\n    pop(maskData?: MaskData): void\n    {\n        const { gl } = this.renderer;\n\n        if (maskData)\n        {\n            rectPool.push(maskData._scissorRectLocal);\n        }\n\n        if (this.getStackLength() > 0)\n        {\n            this._useCurrent();\n        }\n        else\n        {\n            gl.disable(gl.SCISSOR_TEST);\n        }\n    }\n\n    /**\n     * Setup renderer to use the current scissor data.\n     * @private\n     */\n    _useCurrent(): void\n    {\n        const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;\n        let y: number;\n\n        if (this.renderer.renderTexture.current)\n        {\n            y = rect.y;\n        }\n        else\n        {\n            // flipY. In future we'll have it over renderTextures as an option\n            y = this.renderer.height - rect.height - rect.y;\n        }\n\n        this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);\n    }\n}\n\nextensions.add(ScissorSystem);\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}