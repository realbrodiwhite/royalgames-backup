{"ast":null,"code":"import { MASK_TYPES } from '@pixi/constants';\nimport { ExtensionType, extensions } from '@pixi/extensions';\nimport { SpriteMaskFilter } from '../filters/spriteMask/SpriteMaskFilter.mjs';\nimport { MaskData } from './MaskData.mjs';\nclass MaskSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.enableScissor = true;\n    this.alphaMaskPool = [];\n    this.maskDataPool = [];\n    this.maskStack = [];\n    this.alphaMaskIndex = 0;\n  }\n  setMaskStack(maskStack) {\n    this.maskStack = maskStack;\n    this.renderer.scissor.setMaskStack(maskStack);\n    this.renderer.stencil.setMaskStack(maskStack);\n  }\n  push(target, maskDataOrTarget) {\n    let maskData = maskDataOrTarget;\n    if (!maskData.isMaskData) {\n      const d = this.maskDataPool.pop() || new MaskData();\n      d.pooled = true;\n      d.maskObject = maskDataOrTarget;\n      maskData = d;\n    }\n    const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;\n    maskData.copyCountersOrReset(maskAbove);\n    maskData._colorMask = maskAbove ? maskAbove._colorMask : 15;\n    if (maskData.autoDetect) {\n      this.detect(maskData);\n    }\n    maskData._target = target;\n    if (maskData.type !== MASK_TYPES.SPRITE) {\n      this.maskStack.push(maskData);\n    }\n    if (maskData.enabled) {\n      switch (maskData.type) {\n        case MASK_TYPES.SCISSOR:\n          this.renderer.scissor.push(maskData);\n          break;\n        case MASK_TYPES.STENCIL:\n          this.renderer.stencil.push(maskData);\n          break;\n        case MASK_TYPES.SPRITE:\n          maskData.copyCountersOrReset(null);\n          this.pushSpriteMask(maskData);\n          break;\n        case MASK_TYPES.COLOR:\n          this.pushColorMask(maskData);\n          break;\n        default:\n          break;\n      }\n    }\n    if (maskData.type === MASK_TYPES.SPRITE) {\n      this.maskStack.push(maskData);\n    }\n  }\n  pop(target) {\n    const maskData = this.maskStack.pop();\n    if (!maskData || maskData._target !== target) {\n      return;\n    }\n    if (maskData.enabled) {\n      switch (maskData.type) {\n        case MASK_TYPES.SCISSOR:\n          this.renderer.scissor.pop(maskData);\n          break;\n        case MASK_TYPES.STENCIL:\n          this.renderer.stencil.pop(maskData.maskObject);\n          break;\n        case MASK_TYPES.SPRITE:\n          this.popSpriteMask(maskData);\n          break;\n        case MASK_TYPES.COLOR:\n          this.popColorMask(maskData);\n          break;\n        default:\n          break;\n      }\n    }\n    maskData.reset();\n    if (maskData.pooled) {\n      this.maskDataPool.push(maskData);\n    }\n    if (this.maskStack.length !== 0) {\n      const maskCurrent = this.maskStack[this.maskStack.length - 1];\n      if (maskCurrent.type === MASK_TYPES.SPRITE && maskCurrent._filters) {\n        maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;\n      }\n    }\n  }\n  detect(maskData) {\n    const maskObject = maskData.maskObject;\n    if (!maskObject) {\n      maskData.type = MASK_TYPES.COLOR;\n    } else if (maskObject.isSprite) {\n      maskData.type = MASK_TYPES.SPRITE;\n    } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {\n      maskData.type = MASK_TYPES.SCISSOR;\n    } else {\n      maskData.type = MASK_TYPES.STENCIL;\n    }\n  }\n  pushSpriteMask(maskData) {\n    const {\n      maskObject\n    } = maskData;\n    const target = maskData._target;\n    let alphaMaskFilter = maskData._filters;\n    if (!alphaMaskFilter) {\n      alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];\n      if (!alphaMaskFilter) {\n        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()];\n      }\n    }\n    const renderer = this.renderer;\n    const renderTextureSystem = renderer.renderTexture;\n    let resolution;\n    let multisample;\n    if (renderTextureSystem.current) {\n      var _maskData$multisample;\n      const renderTexture = renderTextureSystem.current;\n      resolution = maskData.resolution || renderTexture.resolution;\n      multisample = (_maskData$multisample = maskData.multisample) !== null && _maskData$multisample !== void 0 ? _maskData$multisample : renderTexture.multisample;\n    } else {\n      var _maskData$multisample2;\n      resolution = maskData.resolution || renderer.resolution;\n      multisample = (_maskData$multisample2 = maskData.multisample) !== null && _maskData$multisample2 !== void 0 ? _maskData$multisample2 : renderer.multisample;\n    }\n    alphaMaskFilter[0].resolution = resolution;\n    alphaMaskFilter[0].multisample = multisample;\n    alphaMaskFilter[0].maskSprite = maskObject;\n    const stashFilterArea = target.filterArea;\n    target.filterArea = maskObject.getBounds(true);\n    renderer.filter.push(target, alphaMaskFilter);\n    target.filterArea = stashFilterArea;\n    if (!maskData._filters) {\n      this.alphaMaskIndex++;\n    }\n  }\n  popSpriteMask(maskData) {\n    this.renderer.filter.pop();\n    if (maskData._filters) {\n      maskData._filters[0].maskSprite = null;\n    } else {\n      this.alphaMaskIndex--;\n      this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;\n    }\n  }\n  pushColorMask(maskData) {\n    const currColorMask = maskData._colorMask;\n    const nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;\n    if (nextColorMask !== currColorMask) {\n      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);\n    }\n  }\n  popColorMask(maskData) {\n    const currColorMask = maskData._colorMask;\n    const nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;\n    if (nextColorMask !== currColorMask) {\n      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);\n    }\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nMaskSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"mask\"\n};\nextensions.add(MaskSystem);\nexport { MaskSystem };","map":{"version":3,"mappings":"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","names":["MaskSystem","constructor","renderer","enableScissor","alphaMaskPool","maskDataPool","maskStack","alphaMaskIndex","setMaskStack","scissor","stencil","push","target","maskDataOrTarget","maskData","isMaskData","d","pop","MaskData","pooled","maskObject","length","copyCountersOrReset","maskAbove","_colorMask","autoDetect","detect","_target","type","SPRITE","enabled","MASK_TYPES","pushSpriteMask","pushColorMask","popSpriteMask","popColorMask","reset","maskCurrent","_filters","isSprite","alphaMaskFilter","SpriteMaskFilter","renderTextureSystem","current","renderTexture","resolution","multisample","maskSprite","stashFilterArea","filterArea","filter","currColorMask","nextColorMask","colorMask","destroy","extension","ExtensionType","name","extensions","add"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/core/src/mask/MaskSystem.ts"],"sourcesContent":["import { MASK_TYPES } from '@pixi/constants';\nimport { extensions, ExtensionType } from '@pixi/extensions';\nimport { SpriteMaskFilter } from '../filters/spriteMask/SpriteMaskFilter';\nimport { MaskData } from './MaskData';\n\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { Renderer } from '../Renderer';\nimport type { ISystem } from '../system/ISystem';\nimport type { IMaskTarget } from './MaskData';\n\n/**\n * System plugin to the renderer to manage masks.\n *\n * There are three built-in types of masking:\n * **Scissor Masking**: Scissor masking discards pixels that are outside of a rectangle called the scissor box. It is\n *  the most performant as the scissor test is inexpensive. However, it can only be used when the mask is rectangular.\n * **Stencil Masking**: Stencil masking discards pixels that don't overlap with the pixels rendered into the stencil\n *  buffer. It is the next fastest option as it does not require rendering into a separate framebuffer. However, it does\n *  cause the mask to be rendered **twice** for each masking operation; hence, minimize the rendering cost of your masks.\n * **Sprite Mask Filtering**: Sprite mask filtering discards pixels based on the red channel of the sprite-mask's\n *  texture. (Generally, the masking texture is grayscale). Using advanced techniques, you might be able to embed this\n *  type of masking in a custom shader - and hence, bypassing the masking system fully for performance wins.\n *\n * The best type of masking is auto-detected when you `push` one. To use scissor masking, you must pass in a `Graphics`\n * object with just a rectangle drawn.\n *\n * ## Mask Stacks\n *\n * In the scene graph, masks can be applied recursively, i.e. a mask can be applied during a masking operation. The mask\n * stack stores the currently applied masks in order. Each {@link PIXI.BaseRenderTexture} holds its own mask stack, i.e.\n * when you switch render-textures, the old masks only applied when you switch back to rendering to the old render-target.\n * @memberof PIXI\n */\nexport class MaskSystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'mask',\n    };\n\n    /**\n     * Flag to enable scissor masking.\n     * @default true\n     */\n    public enableScissor: boolean;\n\n    /** Pool of used sprite mask filters. */\n    protected readonly alphaMaskPool: Array<SpriteMaskFilter[]>;\n\n    /**\n     * Current index of alpha mask pool.\n     * @default 0\n     * @readonly\n     */\n    protected alphaMaskIndex: number;\n\n    /** Pool of mask data. */\n    private readonly maskDataPool: Array<MaskData>;\n    private maskStack: Array<MaskData>;\n    private renderer: Renderer;\n\n    /**\n     * @param renderer - The renderer this System works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n\n        this.enableScissor = true;\n        this.alphaMaskPool = [];\n        this.maskDataPool = [];\n\n        this.maskStack = [];\n        this.alphaMaskIndex = 0;\n    }\n\n    /**\n     * Changes the mask stack that is used by this System.\n     * @param maskStack - The mask stack\n     */\n    setMaskStack(maskStack: Array<MaskData>): void\n    {\n        this.maskStack = maskStack;\n        this.renderer.scissor.setMaskStack(maskStack);\n        this.renderer.stencil.setMaskStack(maskStack);\n    }\n\n    /**\n     * Enables the mask and appends it to the current mask stack.\n     *\n     * NOTE: The batch renderer should be flushed beforehand to prevent pending renders from being masked.\n     * @param {PIXI.DisplayObject} target - Display Object to push the mask to\n     * @param {PIXI.MaskData|PIXI.Sprite|PIXI.Graphics|PIXI.DisplayObject} maskDataOrTarget - The masking data.\n     */\n    push(target: IMaskTarget, maskDataOrTarget: MaskData | IMaskTarget): void\n    {\n        let maskData = maskDataOrTarget as MaskData;\n\n        if (!maskData.isMaskData)\n        {\n            const d = this.maskDataPool.pop() || new MaskData();\n\n            d.pooled = true;\n            d.maskObject = maskDataOrTarget as IMaskTarget;\n            maskData = d;\n        }\n\n        const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;\n\n        maskData.copyCountersOrReset(maskAbove);\n        maskData._colorMask = maskAbove ? maskAbove._colorMask : 0xf;\n\n        if (maskData.autoDetect)\n        {\n            this.detect(maskData);\n        }\n\n        maskData._target = target;\n\n        if (maskData.type !== MASK_TYPES.SPRITE)\n        {\n            this.maskStack.push(maskData);\n        }\n\n        if (maskData.enabled)\n        {\n            switch (maskData.type)\n            {\n                case MASK_TYPES.SCISSOR:\n                    this.renderer.scissor.push(maskData);\n                    break;\n                case MASK_TYPES.STENCIL:\n                    this.renderer.stencil.push(maskData);\n                    break;\n                case MASK_TYPES.SPRITE:\n                    maskData.copyCountersOrReset(null);\n                    this.pushSpriteMask(maskData);\n                    break;\n                case MASK_TYPES.COLOR:\n                    this.pushColorMask(maskData);\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        if (maskData.type === MASK_TYPES.SPRITE)\n        {\n            this.maskStack.push(maskData);\n        }\n    }\n\n    /**\n     * Removes the last mask from the mask stack and doesn't return it.\n     *\n     * NOTE: The batch renderer should be flushed beforehand to render the masked contents before the mask is removed.\n     * @param {PIXI.IMaskTarget} target - Display Object to pop the mask from\n     */\n    pop(target: IMaskTarget): void\n    {\n        const maskData = this.maskStack.pop();\n\n        if (!maskData || maskData._target !== target)\n        {\n            // TODO: add an assert when we have it\n\n            return;\n        }\n\n        if (maskData.enabled)\n        {\n            switch (maskData.type)\n            {\n                case MASK_TYPES.SCISSOR:\n                    this.renderer.scissor.pop(maskData);\n                    break;\n                case MASK_TYPES.STENCIL:\n                    this.renderer.stencil.pop(maskData.maskObject);\n                    break;\n                case MASK_TYPES.SPRITE:\n                    this.popSpriteMask(maskData);\n                    break;\n                case MASK_TYPES.COLOR:\n                    this.popColorMask(maskData);\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        maskData.reset();\n\n        if (maskData.pooled)\n        {\n            this.maskDataPool.push(maskData);\n        }\n\n        if (this.maskStack.length !== 0)\n        {\n            const maskCurrent = this.maskStack[this.maskStack.length - 1];\n\n            if (maskCurrent.type === MASK_TYPES.SPRITE && maskCurrent._filters)\n            {\n                maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;\n            }\n        }\n    }\n\n    /**\n     * Sets type of MaskData based on its maskObject.\n     * @param maskData\n     */\n    detect(maskData: MaskData): void\n    {\n        const maskObject = maskData.maskObject;\n\n        if (!maskObject)\n        {\n            maskData.type = MASK_TYPES.COLOR;\n        }\n        else if (maskObject.isSprite)\n        {\n            maskData.type = MASK_TYPES.SPRITE;\n        }\n        else if (this.enableScissor && this.renderer.scissor.testScissor(maskData))\n        {\n            maskData.type = MASK_TYPES.SCISSOR;\n        }\n        else\n        {\n            maskData.type = MASK_TYPES.STENCIL;\n        }\n    }\n\n    /**\n     * Applies the Mask and adds it to the current filter stack.\n     * @param maskData - Sprite to be used as the mask.\n     */\n    pushSpriteMask(maskData: MaskData): void\n    {\n        const { maskObject } = maskData;\n        const target = maskData._target;\n        let alphaMaskFilter = maskData._filters;\n\n        if (!alphaMaskFilter)\n        {\n            alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];\n\n            if (!alphaMaskFilter)\n            {\n                alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()];\n            }\n        }\n\n        const renderer = this.renderer;\n        const renderTextureSystem = renderer.renderTexture;\n\n        let resolution;\n        let multisample;\n\n        if (renderTextureSystem.current)\n        {\n            const renderTexture = renderTextureSystem.current;\n\n            resolution = maskData.resolution || renderTexture.resolution;\n            multisample = maskData.multisample ?? renderTexture.multisample;\n        }\n        else\n        {\n            resolution = maskData.resolution || renderer.resolution;\n            multisample = maskData.multisample ?? renderer.multisample;\n        }\n\n        alphaMaskFilter[0].resolution = resolution;\n        alphaMaskFilter[0].multisample = multisample;\n        alphaMaskFilter[0].maskSprite = maskObject;\n\n        const stashFilterArea = target.filterArea;\n\n        target.filterArea = maskObject.getBounds(true);\n        renderer.filter.push(target, alphaMaskFilter);\n        target.filterArea = stashFilterArea;\n\n        if (!maskData._filters)\n        {\n            this.alphaMaskIndex++;\n        }\n    }\n\n    /**\n     * Removes the last filter from the filter stack and doesn't return it.\n     * @param maskData - Sprite to be used as the mask.\n     */\n    popSpriteMask(maskData: MaskData): void\n    {\n        this.renderer.filter.pop();\n\n        if (maskData._filters)\n        {\n            maskData._filters[0].maskSprite = null;\n        }\n        else\n        {\n            this.alphaMaskIndex--;\n            this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;\n        }\n    }\n\n    /**\n     * Pushes the color mask.\n     * @param maskData - The mask data\n     */\n    pushColorMask(maskData: MaskData): void\n    {\n        const currColorMask = maskData._colorMask;\n        const nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;\n\n        if (nextColorMask !== currColorMask)\n        {\n            this.renderer.gl.colorMask(\n                (nextColorMask & 0x1) !== 0,\n                (nextColorMask & 0x2) !== 0,\n                (nextColorMask & 0x4) !== 0,\n                (nextColorMask & 0x8) !== 0\n            );\n        }\n    }\n\n    /**\n     * Pops the color mask.\n     * @param maskData - The mask data\n     */\n    popColorMask(maskData: MaskData): void\n    {\n        const currColorMask = maskData._colorMask;\n        const nextColorMask = this.maskStack.length > 0\n            ? this.maskStack[this.maskStack.length - 1]._colorMask : 0xf;\n\n        if (nextColorMask !== currColorMask)\n        {\n            this.renderer.gl.colorMask(\n                (nextColorMask & 0x1) !== 0,\n                (nextColorMask & 0x2) !== 0,\n                (nextColorMask & 0x4) !== 0,\n                (nextColorMask & 0x8) !== 0\n            );\n        }\n    }\n\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n}\n\nextensions.add(MaskSystem);\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}