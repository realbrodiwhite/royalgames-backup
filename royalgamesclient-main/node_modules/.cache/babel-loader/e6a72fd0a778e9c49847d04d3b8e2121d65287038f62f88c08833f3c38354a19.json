{"ast":null,"code":"import { utils } from '@pixi/core';\nimport '../utils/index.mjs';\nimport { isSingleItem } from '../utils/isSingleItem.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\nclass Loader {\n  constructor() {\n    this._parsers = [];\n    this.promiseCache = {};\n  }\n  reset() {\n    this.promiseCache = {};\n  }\n  _getLoadPromiseAndParser(url, data) {\n    const result = {\n      promise: null,\n      parser: null\n    };\n    result.promise = (async () => {\n      let asset = null;\n      for (let i = 0; i < this.parsers.length; i++) {\n        var _parser$test;\n        const parser = this.parsers[i];\n        if (parser.load && (_parser$test = parser.test) !== null && _parser$test !== void 0 && _parser$test.call(parser, url, data, this)) {\n          asset = await parser.load(url, data, this);\n          result.parser = parser;\n          break;\n        }\n      }\n      if (!result.parser) {\n        console.warn(\"[Assets] \".concat(url, \" could not be loaded as we don't know how to parse it, ensure the correct parser has being added\"));\n        return null;\n      }\n      for (let i = 0; i < this.parsers.length; i++) {\n        const parser = this.parsers[i];\n        if (parser.parse) {\n          var _parser$testParse;\n          if (parser.parse && (await ((_parser$testParse = parser.testParse) === null || _parser$testParse === void 0 ? void 0 : _parser$testParse.call(parser, asset, data, this)))) {\n            asset = (await parser.parse(asset, data, this)) || asset;\n            result.parser = parser;\n          }\n        }\n      }\n      return asset;\n    })();\n    return result;\n  }\n  async load(assetsToLoadIn, onProgress) {\n    let count = 0;\n    const assets = {};\n    const singleAsset = isSingleItem(assetsToLoadIn);\n    const assetsToLoad = convertToList(assetsToLoadIn, item => ({\n      src: item\n    }));\n    const total = assetsToLoad.length;\n    const promises = assetsToLoad.map(async asset => {\n      const url = utils.path.toAbsolute(asset.src);\n      if (!assets[asset.src]) {\n        try {\n          if (!this.promiseCache[url]) {\n            this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n          }\n          assets[asset.src] = await this.promiseCache[url].promise;\n          if (onProgress) onProgress(++count / total);\n        } catch (e) {\n          delete this.promiseCache[url];\n          delete assets[asset.src];\n          throw new Error(\"[Loader.load] Failed to load \".concat(url, \".\\n\").concat(e));\n        }\n      }\n    });\n    await Promise.all(promises);\n    return singleAsset ? assets[assetsToLoad[0].src] : assets;\n  }\n  async unload(assetsToUnloadIn) {\n    const assetsToUnload = convertToList(assetsToUnloadIn, item => ({\n      src: item\n    }));\n    const promises = assetsToUnload.map(async asset => {\n      const url = utils.path.toAbsolute(asset.src);\n      const loadPromise = this.promiseCache[url];\n      if (loadPromise) {\n        var _loadPromise$parser, _loadPromise$parser$u;\n        const loadedAsset = await loadPromise.promise;\n        (_loadPromise$parser = loadPromise.parser) === null || _loadPromise$parser === void 0 ? void 0 : (_loadPromise$parser$u = _loadPromise$parser.unload) === null || _loadPromise$parser$u === void 0 ? void 0 : _loadPromise$parser$u.call(_loadPromise$parser, loadedAsset, asset, this);\n        delete this.promiseCache[url];\n      }\n    });\n    await Promise.all(promises);\n  }\n  get parsers() {\n    return this._parsers;\n  }\n}\nexport { Loader };","map":{"version":3,"mappings":";;;;AAiBO,MAAMA,MACb;EADOC;IAEH,KAAQC,WAA2B,EAAC;IAGpC,KAAOC,eAAiD,EAAC;EAAA;EAGzDC,KACAA;IACI,KAAKD,eAAe,EAAC;EAAA;EASjBE,wBAAyBA,MAAaC,IAC9C;IACI,MAAMC,MAA2B;MAC7BC,OAAS;MACTC,MAAQ;IAAA,CACZ;IAEAF,OAAOC,UAAW,CAClB;MACI,IAAIE,KAAQ;MAEZ,SAASC,IAAI,CAAG,MAAI,IAAK,SAAQC,QAAQD,CACzC;QAAA;QACU,eAAS,KAAKE,OAAQ;QAE5B,IAAIJ,OAAOK,IAAQ,2BAAOC,6CAAPC,0BAAcC,GAAK,QAAM,IAAI,CAChD;UACIP,QAAQ,MAAMD,OAAOK,IAAK,MAAKR,MAAM,IAAI;UACzCC,OAAOE,MAAS;UAEhB;QAAA;MACJ;MAGA,KAACF,OAAOE,MACZ;QAGYS,gCAAiBD,GAAqG;QAGvH;MAAA;MAGX,SAASN,IAAI,CAAG,MAAI,IAAK,SAAQC,QAAQD,CACzC;QACU,eAAS,KAAKE,OAAQ;QAE5B,IAAIJ,OAAOU,KACX;UAAA;UACQ,WAAOA,UAAS,4BAAMV,OAAOW,+DAAPC,+BAAmBX,KAAO,QAAM,IAAI,CAC9D;YAEIA,QAAQ,OAAMD,MAAO,OAAMC,KAAO,QAAM,IAAI,CAAK;YAEjDH,OAAOE,MAAS;UAAA;QACpB;MACJ;MAGG;IAAA,CACR;IAEI;EAAA;EA2BX,MAAaK,IACTA,iBACAQ,UAEJ;IACI,IAAIC,KAAQ;IAEZ,MAAMC,SAAuC,EAAC;IAExC,oBAAcC,aAAaC,cAAc;IAE/C,MAAMC,YAAe,iBAAyBD,cAAgB,EAACE,IAAU;MACrEC,GAAK;IAAA,CACP;IAEF,MAAMC,QAAQH,YAAa;IAE3B,MAAMI,QAA4B,gBAAaC,GAAI,OAAOtB,KAC1D;MACI,MAAMO,GAAM,SAAMgB,IAAK,YAAWvB,MAAMmB,GAAG;MAEvC,KAACL,MAAO,OAAMK,GAClB;QAEI;UACQ,KAAC,IAAK,cAAaZ,GACvB;YACI,KAAKd,YAAa,QAAO,IAAK,0BAAyBc,KAAKP,KAAK;UAAA;UAGrEc,OAAOd,KAAM,QAAO,MAAM,KAAKP,aAAac,GAAK;UAG7C,gBAAuBK,aAAEC,QAAQO,KAAK;QAAA,SAEvCI,CAAP;UAII,OAAO,KAAK/B,YAAa;UACzB,OAAOqB,OAAOd,KAAM;UAGd,UAAIyB,6CAAsClB,mBAASiB,CAAG;QAAA;MAChE;IACJ,CACH;IAEK,cAAQE,IAAIL,QAAQ;IAE1B,OAAOM,WAAc,UAAOV,YAAa,IAAGE,GAAO;EAAA;EAevD,MAAaS,OACTC,gBAEJ;IACI,MAAMC,cAAiB,iBAAyBD,gBAAkB,EAACX,IAAU;MACzEC,GAAK;IAAA,CACP;IAEF,MAAME,QAA4B,kBAAeC,GAAI,OAAOtB,KAC5D;MACI,MAAMO,GAAM,SAAMgB,IAAK,YAAWvB,MAAMmB,GAAG;MAErC,oBAAc,KAAK1B,YAAa;MAEtC,IAAIsC,WACJ;QAAA;QACU,oBAAc,MAAMA,WAAY;QAEtC,mCAAYhC,MAAQ,iFAApBiC,oBAAoBJ,gEAApBK,gDAA6BC,WAAa,SAAO,IAAI;QAErD,OAAO,KAAKzC,YAAa;MAAA;IAC7B,CACH;IAEK,cAAQiC,IAAIL,QAAQ;EAAA;EAI9B,IAAWlB,OACXA;IACI,OAAO,IAAK;EAAA;AAEpB","names":["Loader","constructor","_parsers","promiseCache","reset","_getLoadPromiseAndParser","data","result","promise","parser","asset","i","length","parsers","load","test","_parser$test","url","console","parse","testParse","_parser$testParse","onProgress","count","assets","isSingleItem","assetsToLoadIn","assetsToLoad","item","src","total","promises","map","path","e","Error","all","singleAsset","unload","assetsToUnloadIn","assetsToUnload","loadPromise","_loadPromise$parser","_loadPromise$parser$u","loadedAsset"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/assets/src/loader/Loader.ts"],"sourcesContent":["import { utils } from '@pixi/core';\nimport { convertToList, isSingleItem } from '../utils';\n\nimport type { LoaderParser } from './parsers/LoaderParser';\nimport type { LoadAsset, PromiseAndParser } from './types';\n\n/**\n * The Loader is responsible for loading all assets, such as images, spritesheets, audio files, etc.\n * It does not do anything clever with URLs - it just loads stuff!\n * Behind the scenes all things are cached using promises. This means it's impossible to load an asset more than once.\n * Through the use of LoaderParsers, the loader can understand how to load any kind of file!\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the second major system of PixiJS' main Assets class\n * @memberof PIXI\n * @class AssetLoader\n */\nexport class Loader\n{\n    private _parsers: LoaderParser[] = [];\n\n    /** Cache loading promises that ae currently active */\n    public promiseCache: Record<string, PromiseAndParser> = {};\n\n    /** function used for testing */\n    public reset(): void\n    {\n        this.promiseCache = {};\n    }\n\n    /**\n     * Used internally to generate a promise for the asset to be loaded.\n     * @param url - The URL to be loaded\n     * @param data - any custom additional information relevant to the asset being loaded\n     * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n     */\n    private _getLoadPromiseAndParser(url: string, data?: LoadAsset): PromiseAndParser\n    {\n        const result: PromiseAndParser = {\n            promise: null,\n            parser: null\n        };\n\n        result.promise = (async () =>\n        {\n            let asset = null;\n\n            for (let i = 0; i < this.parsers.length; i++)\n            {\n                const parser = this.parsers[i];\n\n                if (parser.load && parser.test?.(url, data, this))\n                {\n                    asset = await parser.load(url, data, this);\n                    result.parser = parser;\n\n                    break;\n                }\n            }\n\n            if (!result.parser)\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                console.warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has being added`);\n                // #endif\n\n                return null;\n            }\n\n            for (let i = 0; i < this.parsers.length; i++)\n            {\n                const parser = this.parsers[i];\n\n                if (parser.parse)\n                {\n                    if (parser.parse && await parser.testParse?.(asset, data, this))\n                    {\n                        // transform the asset..\n                        asset = await parser.parse(asset, data, this) || asset;\n\n                        result.parser = parser;\n                    }\n                }\n            }\n\n            return asset;\n        })();\n\n        return result;\n    }\n\n    /**\n     * Loads one or more assets using the parsers added to the Loader.\n     * @example\n     * // Single asset:\n     * const asset = await Loader.load('cool.png');\n     * console.log(asset);\n     *\n     * // Multiple assets:\n     * const assets = await Loader.load(['cool.png', 'cooler.png']);\n     * console.log(assets);\n     * @param assetsToLoadIn - urls that you want to load, or a single one!\n     * @param onProgress - For multiple asset loading only, an optional function that is called\n     * when progress on asset loading is made. The function is passed a single parameter, `progress`,\n     * which represents the percentage (0.0 - 1.0) of the assets loaded. Do not use this function\n     * to detect when assets are complete and available, instead use the Promise returned by this function.\n     */\n    public async load<T = any>(\n        assetsToLoadIn: string | LoadAsset,\n        onProgress?: (progress: number) => void,\n    ): Promise<T>;\n    public async load<T = any>(\n        assetsToLoadIn: string[] | LoadAsset[],\n        onProgress?: (progress: number) => void,\n    ): Promise<Record<string, T>>;\n    public async load<T = any>(\n        assetsToLoadIn: string | string[] | LoadAsset | LoadAsset[],\n        onProgress?: (progress: number) => void,\n    ): Promise<T | Record<string, T>>\n    {\n        let count = 0;\n\n        const assets: Record<string, Promise<any>> = {};\n\n        const singleAsset = isSingleItem(assetsToLoadIn);\n\n        const assetsToLoad = convertToList<LoadAsset>(assetsToLoadIn, (item) => ({\n            src: item,\n        }));\n\n        const total = assetsToLoad.length;\n\n        const promises: Promise<void>[] = assetsToLoad.map(async (asset: LoadAsset) =>\n        {\n            const url = utils.path.toAbsolute(asset.src);\n\n            if (!assets[asset.src])\n            {\n                try\n                {\n                    if (!this.promiseCache[url])\n                    {\n                        this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n                    }\n\n                    assets[asset.src] = await this.promiseCache[url].promise;\n\n                    // Only progress if nothing goes wrong\n                    if (onProgress) onProgress(++count / total);\n                }\n                catch (e)\n                {\n                    // Delete eventually registered file and promises from internal cache\n                    // so they can be eligible for another loading attempt\n                    delete this.promiseCache[url];\n                    delete assets[asset.src];\n\n                    // Stop further execution\n                    throw new Error(`[Loader.load] Failed to load ${url}.\\n${e}`);\n                }\n            }\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? assets[assetsToLoad[0].src] : assets;\n    }\n\n    /**\n     * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n     * The parser that created the asset, will be the one that unloads it.\n     * @example\n     * // Single asset:\n     * const asset = await Loader.load('cool.png');\n     *\n     * await Loader.unload('cool.png');\n     *\n     * console.log(asset.destroyed); // true\n     * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n     */\n    public async unload(\n        assetsToUnloadIn: string | string[] | LoadAsset | LoadAsset[],\n    ): Promise<void>\n    {\n        const assetsToUnload = convertToList<LoadAsset>(assetsToUnloadIn, (item) => ({\n            src: item,\n        }));\n\n        const promises: Promise<void>[] = assetsToUnload.map(async (asset: LoadAsset) =>\n        {\n            const url = utils.path.toAbsolute(asset.src);\n\n            const loadPromise = this.promiseCache[url];\n\n            if (loadPromise)\n            {\n                const loadedAsset = await loadPromise.promise;\n\n                loadPromise.parser?.unload?.(loadedAsset, asset, this);\n\n                delete this.promiseCache[url];\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    /** All loader parsers registered */\n    public get parsers(): LoaderParser[]\n    {\n        return this._parsers;\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}