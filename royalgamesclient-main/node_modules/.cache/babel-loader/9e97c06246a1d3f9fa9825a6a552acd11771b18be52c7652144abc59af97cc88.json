{"ast":null,"code":"import { utils } from '@pixi/core';\nfunction fixOrientation(points) {\n  let hole = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const m = points.length;\n  if (m < 6) {\n    return;\n  }\n  let area = 0;\n  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {\n    const x2 = points[i];\n    const y2 = points[i + 1];\n    area += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  if (!hole && area > 0 || hole && area <= 0) {\n    const n = m / 2;\n    for (let i = n + n % 2; i < m; i += 2) {\n      const i1 = m - i - 2;\n      const i2 = m - i - 1;\n      const i3 = i;\n      const i4 = i + 1;\n      [points[i1], points[i3]] = [points[i3], points[i1]];\n      [points[i2], points[i4]] = [points[i4], points[i2]];\n    }\n  }\n}\nconst buildPoly = {\n  build(graphicsData) {\n    graphicsData.points = graphicsData.shape.points.slice();\n  },\n  triangulate(graphicsData, graphicsGeometry) {\n    let points = graphicsData.points;\n    const holes = graphicsData.holes;\n    const verts = graphicsGeometry.points;\n    const indices = graphicsGeometry.indices;\n    if (points.length >= 6) {\n      fixOrientation(points, false);\n      const holeArray = [];\n      for (let i = 0; i < holes.length; i++) {\n        const hole = holes[i];\n        fixOrientation(hole.points, true);\n        holeArray.push(points.length / 2);\n        points = points.concat(hole.points);\n      }\n      const triangles = utils.earcut(points, holeArray, 2);\n      if (!triangles) {\n        return;\n      }\n      const vertPos = verts.length / 2;\n      for (let i = 0; i < triangles.length; i += 3) {\n        indices.push(triangles[i] + vertPos);\n        indices.push(triangles[i + 1] + vertPos);\n        indices.push(triangles[i + 2] + vertPos);\n      }\n      for (let i = 0; i < points.length; i++) {\n        verts.push(points[i]);\n      }\n    }\n  }\n};\nexport { buildPoly };","map":{"version":3,"mappings":";AAKA,SAAwBA,uBACxB;EAAA,IAD0CC,2EAAO,KACjD;EACI,MAAMC,IAAIC,MAAO;EAEjB,IAAID,IAAI,CACR;IACI;EAAA;EAGJ,IAAIE,IAAO;EAEX,SAASC,CAAI,MAAGC,EAAK,UAAOJ,CAAI,OAAIK,EAAK,UAAOL,CAAI,OAAIG,CAAI,MAAGA,KAAK,CACpE;IACI,MAAMG,KAAKL,MAAO;IACZ,WAAKA,OAAOE,CAAI;IAEbD,cAAKE,OAAYG;IAErBH;IACAC;EAAA;EAGT,IAAK,CAACN,IAAQ,WAAO,CAAO,YAAQG,QAAQ,CAC5C;IACI,MAAMM,IAAIR,CAAI;IAEd,SAASG,IAAIK,CAAK,OAAI,GAAIL,CAAI,MAAGA,KAAK,CACtC;MACU,WAAKH,IAAIG,CAAI;MACb,WAAKH,IAAIG,CAAI;MACnB,MAAMM,EAAK;MACX,MAAMC,KAAKP,CAAI;MAEd,QAAOQ,KAAKV,MAAO,IAAG,IAAI,CAACA,OAAOQ,EAAK,UAAOE,EAAG;MACjD,QAAOC,KAAKX,MAAO,IAAG,IAAI,CAACA,OAAOS,EAAK,UAAOE,EAAG;IAAA;EACtD;AAER;AAWO,MAAMC,SAAgC;EAEzCC,MAAMC,YACN;IACIA,aAAad,MAAU,gBAAae,KAAkB,QAAOC,KAAM;EAAA,CACvE;EAEAC,YAAYH,cAAcI,gBAC1B;IACI,IAAIlB,SAASc,YAAa;IAC1B,MAAMK,QAAQL,YAAa;IAC3B,MAAMM,QAAQF,gBAAiB;IAC/B,MAAMG,UAAUH,gBAAiB;IAE7B,WAAOI,UAAU,CACrB;MACIzB,eAAeG,QAAQ,KAAK;MAE5B,MAAMuB,YAAY,EAAC;MAGnB,SAASrB,CAAI,MAAGA,CAAI,SAAMoB,QAAQpB,CAClC;QACI,MAAMJ,OAAOqB,KAAM;QAEJtB,oBAAKG,QAAQ,IAAI;QAEtBuB,eAAKvB,MAAO,UAAS,CAAC;QACvBA,gBAAOwB,MAAO,MAAKxB,MAAM;MAAA;MAItC,MAAMyB,SAAY,SAAMC,MAAO,SAAQH,WAAW,CAAC;MAEnD,IAAI,CAACE,SACL;QACI;MAAA;MAGE,gBAAUL,MAAME,MAAS;MAE/B,SAASpB,IAAI,CAAG,MAAIuB,SAAU,SAAQvB,KAAK,CAC3C;QACYmB,aAAKI,SAAU,MAAKE,OAAO;QACnCN,QAAQO,IAAK,WAAU1B,CAAI,QAAKyB,OAAO;QACvCN,QAAQO,IAAK,WAAU1B,CAAI,QAAKyB,OAAO;MAAA;MAG3C,SAASzB,CAAI,MAAGA,CAAI,UAAOoB,QAAQpB,CACnC;QACUkB,WAAKpB,OAAOE,CAAE;MAAA;IACxB;EACJ;AAER","names":["fixOrientation","hole","m","points","area","i","x1","y1","x2","y2","n","i3","i4","i1","i2","buildPoly","build","graphicsData","shape","slice","triangulate","graphicsGeometry","holes","verts","indices","length","holeArray","concat","triangles","earcut","vertPos","push"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/graphics/src/utils/buildPoly.ts"],"sourcesContent":["import { utils } from '@pixi/core';\n\nimport type { Polygon } from '@pixi/core';\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\n\nfunction fixOrientation(points: number[], hole = false)\n{\n    const m = points.length;\n\n    if (m < 6)\n    {\n        return;\n    }\n\n    let area = 0;\n\n    for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2)\n    {\n        const x2 = points[i];\n        const y2 = points[i + 1];\n\n        area += (x2 - x1) * (y2 + y1);\n\n        x1 = x2;\n        y1 = y2;\n    }\n\n    if ((!hole && area > 0) || (hole && area <= 0))\n    {\n        const n = m / 2;\n\n        for (let i = n + (n % 2); i < m; i += 2)\n        {\n            const i1 = m - i - 2;\n            const i2 = m - i - 1;\n            const i3 = i;\n            const i4 = i + 1;\n\n            [points[i1], points[i3]] = [points[i3], points[i1]];\n            [points[i2], points[i4]] = [points[i4], points[i2]];\n        }\n    }\n}\n/**\n * Builds a polygon to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildPoly: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        graphicsData.points = (graphicsData.shape as Polygon).points.slice();\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        let points = graphicsData.points;\n        const holes = graphicsData.holes;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        if (points.length >= 6)\n        {\n            fixOrientation(points, false);\n\n            const holeArray = [];\n            // Process holes..\n\n            for (let i = 0; i < holes.length; i++)\n            {\n                const hole = holes[i];\n\n                fixOrientation(hole.points, true);\n\n                holeArray.push(points.length / 2);\n                points = points.concat(hole.points);\n            }\n\n            // sort color\n            const triangles = utils.earcut(points, holeArray, 2);\n\n            if (!triangles)\n            {\n                return;\n            }\n\n            const vertPos = verts.length / 2;\n\n            for (let i = 0; i < triangles.length; i += 3)\n            {\n                indices.push(triangles[i] + vertPos);\n                indices.push(triangles[i + 1] + vertPos);\n                indices.push(triangles[i + 2] + vertPos);\n            }\n\n            for (let i = 0; i < points.length; i++)\n            {\n                verts.push(points[i]);\n            }\n        }\n    },\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}