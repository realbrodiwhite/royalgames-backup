{"ast":null,"code":"import { BoundingBox } from './BoundingBox.mjs';\nfunction checkRow(data, width, y) {\n  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4) {\n    if (data[index + 3] !== 0) return false;\n  }\n  return true;\n}\nfunction checkColumn(data, width, x, top, bottom) {\n  const stride = 4 * width;\n  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride) {\n    if (data[index + 3] !== 0) return false;\n  }\n  return true;\n}\nfunction getCanvasBoundingBox(canvas) {\n  const {\n    width,\n    height\n  } = canvas;\n  const context = canvas.getContext(\"2d\", {\n    willReadFrequently: true\n  });\n  if (context === null) {\n    throw new TypeError(\"Failed to get canvas 2D context\");\n  }\n  const imageData = context.getImageData(0, 0, width, height);\n  const data = imageData.data;\n  let left = 0;\n  let top = 0;\n  let right = width - 1;\n  let bottom = height - 1;\n  while (top < height && checkRow(data, width, top)) ++top;\n  if (top === height) return BoundingBox.EMPTY;\n  while (checkRow(data, width, bottom)) --bottom;\n  while (checkColumn(data, width, left, top, bottom)) ++left;\n  while (checkColumn(data, width, right, top, bottom)) --right;\n  ++right;\n  ++bottom;\n  return new BoundingBox(left, top, right, bottom);\n}\nexport { getCanvasBoundingBox };","map":{"version":3,"mappings":";AAIA,SAAkBA,eAAyBC,OAAeC,CAC1D;EACa,aAAI,CAAG,UAAQ,CAAI,OAAID,KAAO,MAAIA,KAAO,IAAEE,CAAG,WAAS,CAChE;IACQ,SAAKC,QAAQ,CAAO,SAAU;EAAA;EAG/B;AACX;AAEA,qBAAqBC,IAAyB,SAAeF,CAAW,OAAaG,MACrF;EACI,MAAMC,SAAS,CAAI;EAEnB,SAASL,CAAI,QAAKE,KAAS,SAAMG,MAAW,OAAIJ,CAAI,OAAKG,MAAQ,IAAEJ,CAAG,WAASK,MAC/E;IACQ,SAAKH,QAAQ,CAAO,SAAU;EAAA;EAG/B;AACX;AASO,8BAA8BI,MACrC;EAGU;IAAEP;IAAOQ;EAAW;EAEpB,gBAAUD,MAAO,YAAW,IAAM;IACpCE,kBAAoB;EAAA,CACvB;EAED,IAAIC,YAAY,IAChB;IACU,UAAIC,UAAU,iCAAiC;EAAA;EAGzD,MAAMC,YAAYF,OAAQ,cAAa,CAAG,KAAGV,OAAOQ,MAAM;EAC1D,MAAMJ,OAAOQ,SAAU;EAEvB,IAAIC,IAAO;EACX,IAAIC,GAAM;EACV,IAAIC,QAAQf,KAAQ;EACpB,IAAIK,SAASG,MAAS;EAEtB,OAAOM,GAAM,aAAUf,QAAS,OAAMC,OAAOc,GAAG,GAAK;EACrD,IAAIA,GAAQ,aAAQ,OAAOE,WAAY;EAChC,gBAASZ,IAAM,SAAOC,MAAM,GAAK;EACxC,OAAOY,WAAY,OAAMjB,KAAO,QAAMc,KAAKT,MAAM,GAAK;EACtD,OAAOY,WAAY,OAAMjB,KAAO,SAAOc,KAAKT,MAAM,GAAK;EAErD;EACA;EAEF,OAAO,IAAIW,YAAYH,IAAM,OAAKE,OAAOV,MAAM;AACnD","names":["checkRow","width","y","x","index","data","bottom","stride","canvas","height","willReadFrequently","context","TypeError","imageData","left","top","right","BoundingBox","checkColumn"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/utils/src/media/getCanvasBoundingBox.ts"],"sourcesContent":["import { BoundingBox } from './BoundingBox';\n\nimport type { ICanvas } from '@pixi/settings';\n\nfunction checkRow(data: Uint8ClampedArray, width: number, y: number)\n{\n    for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\nfunction checkColumn(data: Uint8ClampedArray, width: number, x: number, top: number, bottom: number)\n{\n    const stride = 4 * width;\n\n    for (let y = top, index = (top * stride) + (4 * x); y <= bottom; ++y, index += stride)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\n/**\n * Measuring the bounds of a canvas' visible (non-transparent) pixels.\n * @memberof PIXI.utils\n * @param {PIXI.ICanvas} canvas - The canvas to measure.\n * @returns {PIXI.utils.BoundingBox} The bounding box of the canvas' visible pixels.\n * @since 7.1.0\n */\nexport function getCanvasBoundingBox(canvas: ICanvas): BoundingBox\n{\n    // https://gist.github.com/timdown/021d9c8f2aabc7092df564996f5afbbf\n\n    const { width, height } = canvas;\n\n    const context = canvas.getContext('2d', {\n        willReadFrequently: true,\n    });\n\n    if (context === null)\n    {\n        throw new TypeError('Failed to get canvas 2D context');\n    }\n\n    const imageData = context.getImageData(0, 0, width, height);\n    const data = imageData.data;\n\n    let left = 0;\n    let top = 0;\n    let right = width - 1;\n    let bottom = height - 1;\n\n    while (top < height && checkRow(data, width, top)) ++top;\n    if (top === height) return BoundingBox.EMPTY;\n    while (checkRow(data, width, bottom)) --bottom;\n    while (checkColumn(data, width, left, top, bottom)) ++left;\n    while (checkColumn(data, width, right, top, bottom)) --right;\n\n    ++right;\n    ++bottom;\n\n    return new BoundingBox(left, top, right, bottom);\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}