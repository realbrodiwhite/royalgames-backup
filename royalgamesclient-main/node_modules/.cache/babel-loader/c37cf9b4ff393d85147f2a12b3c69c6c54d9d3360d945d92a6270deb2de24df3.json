{"ast":null,"code":"import { MSAA_QUALITY, SCALE_MODES, MIPMAP_MODES, FORMATS, TYPES } from '@pixi/constants';\nimport { Runner } from '@pixi/runner';\nimport { BaseTexture } from '../textures/BaseTexture.mjs';\nimport { DepthResource } from '../textures/resources/DepthResource.mjs';\nclass Framebuffer {\n  constructor(width, height) {\n    this.width = Math.round(width || 100);\n    this.height = Math.round(height || 100);\n    this.stencil = false;\n    this.depth = false;\n    this.dirtyId = 0;\n    this.dirtyFormat = 0;\n    this.dirtySize = 0;\n    this.depthTexture = null;\n    this.colorTextures = [];\n    this.glFramebuffers = {};\n    this.disposeRunner = new Runner(\"disposeFramebuffer\");\n    this.multisample = MSAA_QUALITY.NONE;\n  }\n  get colorTexture() {\n    return this.colorTextures[0];\n  }\n  addColorTexture() {\n    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let texture = arguments.length > 1 ? arguments[1] : undefined;\n    this.colorTextures[index] = texture || new BaseTexture(null, {\n      scaleMode: SCALE_MODES.NEAREST,\n      resolution: 1,\n      mipmap: MIPMAP_MODES.OFF,\n      width: this.width,\n      height: this.height\n    });\n    this.dirtyId++;\n    this.dirtyFormat++;\n    return this;\n  }\n  addDepthTexture(texture) {\n    this.depthTexture = texture || new BaseTexture(new DepthResource(null, {\n      width: this.width,\n      height: this.height\n    }), {\n      scaleMode: SCALE_MODES.NEAREST,\n      resolution: 1,\n      width: this.width,\n      height: this.height,\n      mipmap: MIPMAP_MODES.OFF,\n      format: FORMATS.DEPTH_COMPONENT,\n      type: TYPES.UNSIGNED_SHORT\n    });\n    this.dirtyId++;\n    this.dirtyFormat++;\n    return this;\n  }\n  enableDepth() {\n    this.depth = true;\n    this.dirtyId++;\n    this.dirtyFormat++;\n    return this;\n  }\n  enableStencil() {\n    this.stencil = true;\n    this.dirtyId++;\n    this.dirtyFormat++;\n    return this;\n  }\n  resize(width, height) {\n    width = Math.round(width);\n    height = Math.round(height);\n    if (width === this.width && height === this.height) return;\n    this.width = width;\n    this.height = height;\n    this.dirtyId++;\n    this.dirtySize++;\n    for (let i = 0; i < this.colorTextures.length; i++) {\n      const texture = this.colorTextures[i];\n      const resolution = texture.resolution;\n      texture.setSize(width / resolution, height / resolution);\n    }\n    if (this.depthTexture) {\n      const resolution = this.depthTexture.resolution;\n      this.depthTexture.setSize(width / resolution, height / resolution);\n    }\n  }\n  dispose() {\n    this.disposeRunner.emit(this, false);\n  }\n  destroyDepthTexture() {\n    if (this.depthTexture) {\n      this.depthTexture.destroy();\n      this.depthTexture = null;\n      ++this.dirtyId;\n      ++this.dirtyFormat;\n    }\n  }\n}\nexport { Framebuffer };","map":{"version":3,"mappings":";;;;AAcO,MAAMA,WACb;EAsCIC,YAAYC,OAAeC,MAC3B;IACI,KAAKD,KAAQ,QAAKE,KAAM,UAAS,GAAG;IACpC,KAAKD,MAAS,QAAKC,KAAM,WAAU,GAAG;IAEtC,KAAKC,OAAU;IACf,KAAKC,KAAQ;IAEb,KAAKC,OAAU;IACf,KAAKC,WAAc;IACnB,KAAKC,SAAY;IAEjB,KAAKC,YAAe;IACpB,KAAKC,gBAAgB,EAAC;IAEtB,KAAKC,iBAAiB,EAAC;IAElB,qBAAgB,IAAIC,OAAO,oBAAoB;IACpD,KAAKC,cAAcC,YAAa;EAAA;EAOpC,IAAIC,YACJA;IACI,OAAO,KAAKL,aAAc;EAAA;EAQ9BM,kBACA;IAAA,IADgBC,KAAQ;IAAA,IAAGC,OAC3B;IAEI,KAAKR,aAAc,UAASQ,OAAW,QAAIC,YAAY,IAAM;MACzDC,WAAWC,WAAY;MACvBC,UAAY;MACZC,QAAQC,YAAa;MACrBvB,OAAO,IAAK;MACZC,QAAQ,IAAK;IAAA,CAChB;IAEI;IACA;IAEE;EAAA;EAOXuB,gBAAgBP,OAChB;IAEI,KAAKT,YAAe,cAAW,IAAIU,YAAY,IAAIO,aAAc,OAAM;MAAEzB,OAAO,KAAKA,KAAO;MAAAC,QAAQ,IAAK;IAAA,CAAQ,CAAG;MAChHkB,WAAWC,WAAY;MACvBC,UAAY;MACZrB,OAAO,IAAK;MACZC,QAAQ,IAAK;MACbqB,QAAQC,YAAa;MACrBG,QAAQC,OAAQ;MAChBC,MAAMC,KAAM;IAAA,CACf;IAEI;IACA;IAEE;EAAA;EAIXC,WACAA;IACI,KAAK1B,KAAQ;IAER;IACA;IAEE;EAAA;EAIX2B,aACAA;IACI,KAAK5B,OAAU;IAEV;IACA;IAEE;EAAA;EAQX6B,OAAOhC,OAAeC,MACtB;IACYD,aAAKE,MAAMF,KAAK;IACfC,cAAKC,MAAMD,MAAM;IAE1B,IAAID,KAAU,UAAKA,KAAS,eAAW,IAAK,SAAQ;IAEpD,KAAKA,KAAQ;IACb,KAAKC,MAAS;IAET;IACA;IAEL,SAASgC,IAAI,CAAG,MAAI,IAAK,eAAcC,QAAQD,CAC/C;MACU,gBAAU,KAAKxB,aAAc;MACnC,MAAMY,aAAaJ,OAAQ;MAG3BA,QAAQkB,OAAQ,SAAQd,UAAY,WAASA,UAAU;IAAA;IAG3D,IAAI,KAAKb,YACT;MACU,mBAAa,KAAKA,YAAa;MAErC,KAAKA,YAAa,SAAQR,KAAQ,eAAYC,SAASoB,UAAU;IAAA;EACrE;EAIJe,OACAA;IACS,mBAAcC,IAAK,OAAM,KAAK;EAAA;EAIvCC,mBACAA;IACI,IAAI,KAAK9B,YACT;MACI,KAAKA,aAAa+B,OAAQ;MAC1B,KAAK/B,YAAe;MAEpB,EAAE,IAAK;MACP,EAAE,IAAK;IAAA;EACX;AAER","names":["Framebuffer","constructor","width","height","round","stencil","depth","dirtyId","dirtyFormat","dirtySize","depthTexture","colorTextures","glFramebuffers","Runner","multisample","MSAA_QUALITY","colorTexture","addColorTexture","index","texture","BaseTexture","scaleMode","SCALE_MODES","resolution","mipmap","MIPMAP_MODES","addDepthTexture","DepthResource","format","FORMATS","type","TYPES","enableDepth","enableStencil","resize","i","length","setSize","dispose","emit","destroyDepthTexture","destroy"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/core/src/framebuffer/Framebuffer.ts"],"sourcesContent":["import { FORMATS, MIPMAP_MODES, MSAA_QUALITY, SCALE_MODES, TYPES } from '@pixi/constants';\nimport { Runner } from '@pixi/runner';\nimport { BaseTexture } from '../textures/BaseTexture';\nimport { DepthResource } from '../textures/resources/DepthResource';\n\nimport type { GLFramebuffer } from './GLFramebuffer';\n\n/**\n * A framebuffer can be used to render contents off of the screen. {@link PIXI.BaseRenderTexture} uses\n * one internally to render into itself. You can attach a depth or stencil buffer to a framebuffer.\n *\n * On WebGL 2 machines, shaders can output to multiple textures simultaneously with GLSL 300 ES.\n * @memberof PIXI\n */\nexport class Framebuffer\n{\n    /** Width of framebuffer in pixels. */\n    public width: number;\n\n    /** Height of framebuffer in pixels. */\n    public height: number;\n\n    /**\n     * Desired number of samples for antialiasing. 0 means AA should not be used.\n     *\n     * Experimental WebGL2 feature, allows to use antialiasing in individual renderTextures.\n     * Antialiasing is the same as for main buffer with renderer `antialias: true` options.\n     * Seriously affects GPU memory consumption and GPU performance.\n     * @example\n     * import { MSAA_QUALITY } from 'pixi.js';\n     *\n     * renderTexture.framebuffer.multisample = MSAA_QUALITY.HIGH;\n     * // ...\n     * renderer.render(myContainer, { renderTexture });\n     * renderer.framebuffer.blit(); // Copies data from MSAA framebuffer to texture\n     * @default PIXI.MSAA_QUALITY.NONE\n     */\n    public multisample: MSAA_QUALITY;\n\n    stencil: boolean;\n    depth: boolean;\n    dirtyId: number;\n    dirtyFormat: number;\n    dirtySize: number;\n    depthTexture: BaseTexture;\n    colorTextures: Array<BaseTexture>;\n    glFramebuffers: {[key: string]: GLFramebuffer};\n    disposeRunner: Runner;\n\n    /**\n     * @param width - Width of the frame buffer\n     * @param height - Height of the frame buffer\n     */\n    constructor(width: number, height: number)\n    {\n        this.width = Math.round(width || 100);\n        this.height = Math.round(height || 100);\n\n        this.stencil = false;\n        this.depth = false;\n\n        this.dirtyId = 0;\n        this.dirtyFormat = 0;\n        this.dirtySize = 0;\n\n        this.depthTexture = null;\n        this.colorTextures = [];\n\n        this.glFramebuffers = {};\n\n        this.disposeRunner = new Runner('disposeFramebuffer');\n        this.multisample = MSAA_QUALITY.NONE;\n    }\n\n    /**\n     * Reference to the colorTexture.\n     * @readonly\n     */\n    get colorTexture(): BaseTexture\n    {\n        return this.colorTextures[0];\n    }\n\n    /**\n     * Add texture to the colorTexture array.\n     * @param index - Index of the array to add the texture to\n     * @param texture - Texture to add to the array\n     */\n    addColorTexture(index = 0, texture?: BaseTexture): this\n    {\n        // TODO add some validation to the texture - same width / height etc?\n        this.colorTextures[index] = texture || new BaseTexture(null, {\n            scaleMode: SCALE_MODES.NEAREST,\n            resolution: 1,\n            mipmap: MIPMAP_MODES.OFF,\n            width: this.width,\n            height: this.height,\n        });\n\n        this.dirtyId++;\n        this.dirtyFormat++;\n\n        return this;\n    }\n\n    /**\n     * Add a depth texture to the frame buffer.\n     * @param texture - Texture to add.\n     */\n    addDepthTexture(texture?: BaseTexture): this\n    {\n        /* eslint-disable max-len */\n        this.depthTexture = texture || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {\n            scaleMode: SCALE_MODES.NEAREST,\n            resolution: 1,\n            width: this.width,\n            height: this.height,\n            mipmap: MIPMAP_MODES.OFF,\n            format: FORMATS.DEPTH_COMPONENT,\n            type: TYPES.UNSIGNED_SHORT,\n        });\n\n        this.dirtyId++;\n        this.dirtyFormat++;\n\n        return this;\n    }\n\n    /** Enable depth on the frame buffer. */\n    enableDepth(): this\n    {\n        this.depth = true;\n\n        this.dirtyId++;\n        this.dirtyFormat++;\n\n        return this;\n    }\n\n    /** Enable stencil on the frame buffer. */\n    enableStencil(): this\n    {\n        this.stencil = true;\n\n        this.dirtyId++;\n        this.dirtyFormat++;\n\n        return this;\n    }\n\n    /**\n     * Resize the frame buffer\n     * @param width - Width of the frame buffer to resize to\n     * @param height - Height of the frame buffer to resize to\n     */\n    resize(width: number, height: number): void\n    {\n        width = Math.round(width);\n        height = Math.round(height);\n\n        if (width === this.width && height === this.height) return;\n\n        this.width = width;\n        this.height = height;\n\n        this.dirtyId++;\n        this.dirtySize++;\n\n        for (let i = 0; i < this.colorTextures.length; i++)\n        {\n            const texture = this.colorTextures[i];\n            const resolution = texture.resolution;\n\n            // take into account the fact the texture may have a different resolution..\n            texture.setSize(width / resolution, height / resolution);\n        }\n\n        if (this.depthTexture)\n        {\n            const resolution = this.depthTexture.resolution;\n\n            this.depthTexture.setSize(width / resolution, height / resolution);\n        }\n    }\n\n    /** Disposes WebGL resources that are connected to this geometry. */\n    dispose(): void\n    {\n        this.disposeRunner.emit(this, false);\n    }\n\n    /** Destroys and removes the depth texture added to this framebuffer. */\n    destroyDepthTexture(): void\n    {\n        if (this.depthTexture)\n        {\n            this.depthTexture.destroy();\n            this.depthTexture = null;\n\n            ++this.dirtyId;\n            ++this.dirtyFormat;\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}