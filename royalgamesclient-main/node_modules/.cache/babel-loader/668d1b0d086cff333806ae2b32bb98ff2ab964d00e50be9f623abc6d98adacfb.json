{"ast":null,"code":"import { Rectangle } from '@pixi/core';\nclass Bounds {\n  constructor() {\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = -Infinity;\n    this.maxY = -Infinity;\n    this.rect = null;\n    this.updateID = -1;\n  }\n  isEmpty() {\n    return this.minX > this.maxX || this.minY > this.maxY;\n  }\n  clear() {\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = -Infinity;\n    this.maxY = -Infinity;\n  }\n  getRectangle(rect) {\n    if (this.minX > this.maxX || this.minY > this.maxY) {\n      return Rectangle.EMPTY;\n    }\n    rect = rect || new Rectangle(0, 0, 1, 1);\n    rect.x = this.minX;\n    rect.y = this.minY;\n    rect.width = this.maxX - this.minX;\n    rect.height = this.maxY - this.minY;\n    return rect;\n  }\n  addPoint(point) {\n    this.minX = Math.min(this.minX, point.x);\n    this.maxX = Math.max(this.maxX, point.x);\n    this.minY = Math.min(this.minY, point.y);\n    this.maxY = Math.max(this.maxY, point.y);\n  }\n  addPointMatrix(matrix, point) {\n    const {\n      a,\n      b,\n      c,\n      d,\n      tx,\n      ty\n    } = matrix;\n    const x = a * point.x + c * point.y + tx;\n    const y = b * point.x + d * point.y + ty;\n    this.minX = Math.min(this.minX, x);\n    this.maxX = Math.max(this.maxX, x);\n    this.minY = Math.min(this.minY, y);\n    this.maxY = Math.max(this.maxY, y);\n  }\n  addQuad(vertices) {\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    let x = vertices[0];\n    let y = vertices[1];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = vertices[2];\n    y = vertices[3];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = vertices[4];\n    y = vertices[5];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = vertices[6];\n    y = vertices[7];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  addFrame(transform, x0, y0, x1, y1) {\n    this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);\n  }\n  addFrameMatrix(matrix, x0, y0, x1, y1) {\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    let x = a * x0 + c * y0 + tx;\n    let y = b * x0 + d * y0 + ty;\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = a * x1 + c * y0 + tx;\n    y = b * x1 + d * y0 + ty;\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = a * x0 + c * y1 + tx;\n    y = b * x0 + d * y1 + ty;\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = a * x1 + c * y1 + tx;\n    y = b * x1 + d * y1 + ty;\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  addVertexData(vertexData, beginOffset, endOffset) {\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    for (let i = beginOffset; i < endOffset; i += 2) {\n      const x = vertexData[i];\n      const y = vertexData[i + 1];\n      minX = x < minX ? x : minX;\n      minY = y < minY ? y : minY;\n      maxX = x > maxX ? x : maxX;\n      maxY = y > maxY ? y : maxY;\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  addVertices(transform, vertices, beginOffset, endOffset) {\n    this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);\n  }\n  addVerticesMatrix(matrix, vertices, beginOffset, endOffset) {\n    let padX = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    let padY = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : padX;\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    for (let i = beginOffset; i < endOffset; i += 2) {\n      const rawX = vertices[i];\n      const rawY = vertices[i + 1];\n      const x = a * rawX + c * rawY + tx;\n      const y = d * rawY + b * rawX + ty;\n      minX = Math.min(minX, x - padX);\n      maxX = Math.max(maxX, x + padX);\n      minY = Math.min(minY, y - padY);\n      maxY = Math.max(maxY, y + padY);\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  addBounds(bounds) {\n    const minX = this.minX;\n    const minY = this.minY;\n    const maxX = this.maxX;\n    const maxY = this.maxY;\n    this.minX = bounds.minX < minX ? bounds.minX : minX;\n    this.minY = bounds.minY < minY ? bounds.minY : minY;\n    this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;\n    this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;\n  }\n  addBoundsMask(bounds, mask) {\n    const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;\n    const _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;\n    const _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;\n    const _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;\n    if (_minX <= _maxX && _minY <= _maxY) {\n      const minX = this.minX;\n      const minY = this.minY;\n      const maxX = this.maxX;\n      const maxY = this.maxY;\n      this.minX = _minX < minX ? _minX : minX;\n      this.minY = _minY < minY ? _minY : minY;\n      this.maxX = _maxX > maxX ? _maxX : maxX;\n      this.maxY = _maxY > maxY ? _maxY : maxY;\n    }\n  }\n  addBoundsMatrix(bounds, matrix) {\n    this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);\n  }\n  addBoundsArea(bounds, area) {\n    const _minX = bounds.minX > area.x ? bounds.minX : area.x;\n    const _minY = bounds.minY > area.y ? bounds.minY : area.y;\n    const _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width;\n    const _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;\n    if (_minX <= _maxX && _minY <= _maxY) {\n      const minX = this.minX;\n      const minY = this.minY;\n      const maxX = this.maxX;\n      const maxY = this.maxY;\n      this.minX = _minX < minX ? _minX : minX;\n      this.minY = _minY < minY ? _minY : minY;\n      this.maxX = _maxX > maxX ? _maxX : maxX;\n      this.maxY = _maxY > maxY ? _maxY : maxY;\n    }\n  }\n  pad() {\n    let paddingX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let paddingY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : paddingX;\n    if (!this.isEmpty()) {\n      this.minX -= paddingX;\n      this.maxX += paddingX;\n      this.minY -= paddingY;\n      this.maxY += paddingY;\n    }\n  }\n  addFramePad(x0, y0, x1, y1, padX, padY) {\n    x0 -= padX;\n    y0 -= padY;\n    x1 += padX;\n    y1 += padY;\n    this.minX = this.minX < x0 ? this.minX : x0;\n    this.maxX = this.maxX > x1 ? this.maxX : x1;\n    this.minY = this.minY < y0 ? this.minY : y0;\n    this.maxY = this.maxY > y1 ? this.maxY : y1;\n  }\n}\nexport { Bounds };","map":{"version":3,"mappings":"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","names":["Bounds","constructor","minX","minY","maxX","maxY","rect","updateID","isEmpty","clear","getRectangle","Rectangle","x","y","addPoint","point","Math","addPointMatrix","matrix","a","b","c","d","tx","ty","min","max","addQuad","vertices","addFrame","x0","x1","y1","addFrameMatrix","transform","y0","addVertexData","vertexData","endOffset","i","addVertices","addVerticesMatrix","worldTransform","beginOffset","padX","padY","rawX","rawY","addBounds","bounds","addBoundsMask","mask","_minX","_minY","_maxX","_maxY","addBoundsMatrix","addBoundsArea","area","pad","paddingX","addFramePad"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/display/src/Bounds.ts"],"sourcesContent":["import { Rectangle } from '@pixi/core';\n\nimport type { IPointData, Matrix, Transform } from '@pixi/core';\n\n/**\n * 'Builder' pattern for bounds rectangles.\n *\n * This could be called an Axis-Aligned Bounding Box.\n * It is not an actual shape. It is a mutable thing; no 'EMPTY' or those kind of problems.\n * @memberof PIXI\n */\nexport class Bounds\n{\n    /** @default Infinity */\n    public minX: number;\n\n    /** @default Infinity */\n    public minY: number;\n\n    /** @default -Infinity */\n    public maxX: number;\n\n    /** @default -Infinity */\n    public maxY: number;\n\n    public rect: Rectangle;\n\n    /**\n     * It is updated to _boundsID of corresponding object to keep bounds in sync with content.\n     * Updated from outside, thus public modifier.\n     */\n    public updateID: number;\n\n    constructor()\n    {\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = -Infinity;\n        this.maxY = -Infinity;\n\n        this.rect = null;\n        this.updateID = -1;\n    }\n\n    /**\n     * Checks if bounds are empty.\n     * @returns - True if empty.\n     */\n    isEmpty(): boolean\n    {\n        return this.minX > this.maxX || this.minY > this.maxY;\n    }\n\n    /** Clears the bounds and resets. */\n    clear(): void\n    {\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = -Infinity;\n        this.maxY = -Infinity;\n    }\n\n    /**\n     * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle\n     * It is not guaranteed that it will return tempRect\n     * @param rect - Temporary object will be used if AABB is not empty\n     * @returns - A rectangle of the bounds\n     */\n    getRectangle(rect?: Rectangle): Rectangle\n    {\n        if (this.minX > this.maxX || this.minY > this.maxY)\n        {\n            return Rectangle.EMPTY;\n        }\n\n        rect = rect || new Rectangle(0, 0, 1, 1);\n\n        rect.x = this.minX;\n        rect.y = this.minY;\n        rect.width = this.maxX - this.minX;\n        rect.height = this.maxY - this.minY;\n\n        return rect;\n    }\n\n    /**\n     * This function should be inlined when its possible.\n     * @param point - The point to add.\n     */\n    addPoint(point: IPointData): void\n    {\n        this.minX = Math.min(this.minX, point.x);\n        this.maxX = Math.max(this.maxX, point.x);\n        this.minY = Math.min(this.minY, point.y);\n        this.maxY = Math.max(this.maxY, point.y);\n    }\n\n    /**\n     * Adds a point, after transformed. This should be inlined when its possible.\n     * @param matrix\n     * @param point\n     */\n    addPointMatrix(matrix: Matrix, point: IPointData): void\n    {\n        const { a, b, c, d, tx, ty } = matrix;\n\n        const x = (a * point.x) + (c * point.y) + tx;\n        const y = (b * point.x) + (d * point.y) + ty;\n\n        this.minX = Math.min(this.minX, x);\n        this.maxX = Math.max(this.maxX, x);\n        this.minY = Math.min(this.minY, y);\n        this.maxY = Math.max(this.maxY, y);\n    }\n\n    /**\n     * Adds a quad, not transformed\n     * @param vertices - The verts to add.\n     */\n    addQuad(vertices: Float32Array): void\n    {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        let x = vertices[0];\n        let y = vertices[1];\n\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = vertices[2];\n        y = vertices[3];\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = vertices[4];\n        y = vertices[5];\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = vertices[6];\n        y = vertices[7];\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds sprite frame, transformed.\n     * @param transform - transform to apply\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     */\n    addFrame(transform: Transform, x0: number, y0: number, x1: number, y1: number): void\n    {\n        this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);\n    }\n\n    /**\n     * Adds sprite frame, multiplied by matrix\n     * @param matrix - matrix to apply\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     */\n    addFrameMatrix(matrix: Matrix, x0: number, y0: number, x1: number, y1: number): void\n    {\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        let x = (a * x0) + (c * y0) + tx;\n        let y = (b * x0) + (d * y0) + ty;\n\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = (a * x1) + (c * y0) + tx;\n        y = (b * x1) + (d * y0) + ty;\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = (a * x0) + (c * y1) + tx;\n        y = (b * x0) + (d * y1) + ty;\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = (a * x1) + (c * y1) + tx;\n        y = (b * x1) + (d * y1) + ty;\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds screen vertices from array\n     * @param vertexData - calculated vertices\n     * @param beginOffset - begin offset\n     * @param endOffset - end offset, excluded\n     */\n    addVertexData(vertexData: Float32Array, beginOffset: number, endOffset: number): void\n    {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        for (let i = beginOffset; i < endOffset; i += 2)\n        {\n            const x = vertexData[i];\n            const y = vertexData[i + 1];\n\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Add an array of mesh vertices\n     * @param transform - mesh transform\n     * @param vertices - mesh coordinates in array\n     * @param beginOffset - begin offset\n     * @param endOffset - end offset, excluded\n     */\n    addVertices(transform: Transform, vertices: Float32Array, beginOffset: number, endOffset: number): void\n    {\n        this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);\n    }\n\n    /**\n     * Add an array of mesh vertices.\n     * @param matrix - mesh matrix\n     * @param vertices - mesh coordinates in array\n     * @param beginOffset - begin offset\n     * @param endOffset - end offset, excluded\n     * @param padX - x padding\n     * @param padY - y padding\n     */\n    addVerticesMatrix(matrix: Matrix, vertices: Float32Array, beginOffset: number,\n        endOffset: number, padX = 0, padY = padX): void\n    {\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        for (let i = beginOffset; i < endOffset; i += 2)\n        {\n            const rawX = vertices[i];\n            const rawY = vertices[i + 1];\n            const x = (a * rawX) + (c * rawY) + tx;\n            const y = (d * rawY) + (b * rawX) + ty;\n\n            minX = Math.min(minX, x - padX);\n            maxX = Math.max(maxX, x + padX);\n            minY = Math.min(minY, y - padY);\n            maxY = Math.max(maxY, y + padY);\n        }\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds other {@link Bounds}.\n     * @param bounds - The Bounds to be added\n     */\n    addBounds(bounds: Bounds): void\n    {\n        const minX = this.minX;\n        const minY = this.minY;\n        const maxX = this.maxX;\n        const maxY = this.maxY;\n\n        this.minX = bounds.minX < minX ? bounds.minX : minX;\n        this.minY = bounds.minY < minY ? bounds.minY : minY;\n        this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;\n        this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;\n    }\n\n    /**\n     * Adds other Bounds, masked with Bounds.\n     * @param bounds - The Bounds to be added.\n     * @param mask - TODO\n     */\n    addBoundsMask(bounds: Bounds, mask: Bounds): void\n    {\n        const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;\n        const _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;\n        const _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;\n        const _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;\n\n        if (_minX <= _maxX && _minY <= _maxY)\n        {\n            const minX = this.minX;\n            const minY = this.minY;\n            const maxX = this.maxX;\n            const maxY = this.maxY;\n\n            this.minX = _minX < minX ? _minX : minX;\n            this.minY = _minY < minY ? _minY : minY;\n            this.maxX = _maxX > maxX ? _maxX : maxX;\n            this.maxY = _maxY > maxY ? _maxY : maxY;\n        }\n    }\n\n    /**\n     * Adds other Bounds, multiplied by matrix. Bounds shouldn't be empty.\n     * @param bounds - other bounds\n     * @param matrix - multiplicator\n     */\n    addBoundsMatrix(bounds: Bounds, matrix: Matrix): void\n    {\n        this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);\n    }\n\n    /**\n     * Adds other Bounds, masked with Rectangle.\n     * @param bounds - TODO\n     * @param area - TODO\n     */\n    addBoundsArea(bounds: Bounds, area: Rectangle): void\n    {\n        const _minX = bounds.minX > area.x ? bounds.minX : area.x;\n        const _minY = bounds.minY > area.y ? bounds.minY : area.y;\n        const _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : (area.x + area.width);\n        const _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : (area.y + area.height);\n\n        if (_minX <= _maxX && _minY <= _maxY)\n        {\n            const minX = this.minX;\n            const minY = this.minY;\n            const maxX = this.maxX;\n            const maxY = this.maxY;\n\n            this.minX = _minX < minX ? _minX : minX;\n            this.minY = _minY < minY ? _minY : minY;\n            this.maxX = _maxX > maxX ? _maxX : maxX;\n            this.maxY = _maxY > maxY ? _maxY : maxY;\n        }\n    }\n\n    /**\n     * Pads bounds object, making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     * @param paddingX - The horizontal padding amount.\n     * @param paddingY - The vertical padding amount.\n     */\n    pad(paddingX = 0, paddingY = paddingX): void\n    {\n        if (!this.isEmpty())\n        {\n            this.minX -= paddingX;\n            this.maxX += paddingX;\n            this.minY -= paddingY;\n            this.maxY += paddingY;\n        }\n    }\n\n    /**\n     * Adds padded frame. (x0, y0) should be strictly less than (x1, y1)\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     * @param padX - padding X\n     * @param padY - padding Y\n     */\n    addFramePad(x0: number, y0: number, x1: number, y1: number, padX: number, padY: number): void\n    {\n        x0 -= padX;\n        y0 -= padY;\n        x1 += padX;\n        y1 += padY;\n\n        this.minX = this.minX < x0 ? this.minX : x0;\n        this.maxX = this.maxX > x1 ? this.maxX : x1;\n        this.minY = this.minY < y0 ? this.minY : y0;\n        this.maxY = this.maxY > y1 ? this.maxY : y1;\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}