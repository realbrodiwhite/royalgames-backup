{"ast":null,"code":"import { ALPHA_MODES } from '@pixi/constants';\nimport { settings } from '@pixi/settings';\nimport { BaseImageResource } from './BaseImageResource.mjs';\nclass ImageResource extends BaseImageResource {\n  constructor(source, options) {\n    var _options$createBitmap;\n    options = options || {};\n    if (typeof source === \"string\") {\n      const imageElement = new Image();\n      BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);\n      imageElement.src = source;\n      source = imageElement;\n    }\n    super(source);\n    if (!source.complete && !!this._width && !!this._height) {\n      this._width = 0;\n      this._height = 0;\n    }\n    this.url = source.src;\n    this._process = null;\n    this.preserveBitmap = false;\n    this.createBitmap = ((_options$createBitmap = options.createBitmap) !== null && _options$createBitmap !== void 0 ? _options$createBitmap : settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;\n    this.alphaMode = typeof options.alphaMode === \"number\" ? options.alphaMode : null;\n    this.bitmap = null;\n    this._load = null;\n    if (options.autoLoad !== false) {\n      this.load();\n    }\n  }\n  load(createBitmap) {\n    if (this._load) {\n      return this._load;\n    }\n    if (createBitmap !== void 0) {\n      this.createBitmap = createBitmap;\n    }\n    this._load = new Promise((resolve, reject) => {\n      const source = this.source;\n      this.url = source.src;\n      const completed = () => {\n        if (this.destroyed) {\n          return;\n        }\n        source.onload = null;\n        source.onerror = null;\n        this.resize(source.width, source.height);\n        this._load = null;\n        if (this.createBitmap) {\n          resolve(this.process());\n        } else {\n          resolve(this);\n        }\n      };\n      if (source.complete && source.src) {\n        completed();\n      } else {\n        source.onload = completed;\n        source.onerror = event => {\n          reject(event);\n          this.onError.emit(event);\n        };\n      }\n    });\n    return this._load;\n  }\n  process() {\n    const source = this.source;\n    if (this._process !== null) {\n      return this._process;\n    }\n    if (this.bitmap !== null || !globalThis.createImageBitmap) {\n      return Promise.resolve(this);\n    }\n    const createImageBitmap = globalThis.createImageBitmap;\n    const cors = !source.crossOrigin || source.crossOrigin === \"anonymous\";\n    this._process = fetch(source.src, {\n      mode: cors ? \"cors\" : \"no-cors\"\n    }).then(r => r.blob()).then(blob => createImageBitmap(blob, 0, 0, source.width, source.height, {\n      premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? \"premultiply\" : \"none\"\n    })).then(bitmap => {\n      if (this.destroyed) {\n        return Promise.reject();\n      }\n      this.bitmap = bitmap;\n      this.update();\n      this._process = null;\n      return Promise.resolve(this);\n    });\n    return this._process;\n  }\n  upload(renderer, baseTexture, glTexture) {\n    if (typeof this.alphaMode === \"number\") {\n      baseTexture.alphaMode = this.alphaMode;\n    }\n    if (!this.createBitmap) {\n      return super.upload(renderer, baseTexture, glTexture);\n    }\n    if (!this.bitmap) {\n      this.process();\n      if (!this.bitmap) {\n        return false;\n      }\n    }\n    super.upload(renderer, baseTexture, glTexture, this.bitmap);\n    if (!this.preserveBitmap) {\n      let flag = true;\n      const glTextures = baseTexture._glTextures;\n      for (const key in glTextures) {\n        const otherTex = glTextures[key];\n        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {\n          flag = false;\n          break;\n        }\n      }\n      if (flag) {\n        if (this.bitmap.close) {\n          this.bitmap.close();\n        }\n        this.bitmap = null;\n      }\n    }\n    return true;\n  }\n  dispose() {\n    this.source.onload = null;\n    this.source.onerror = null;\n    super.dispose();\n    if (this.bitmap) {\n      this.bitmap.close();\n      this.bitmap = null;\n    }\n    this._process = null;\n    this._load = null;\n  }\n  static test(source) {\n    return typeof HTMLImageElement !== \"undefined\" && (typeof source === \"string\" || source instanceof HTMLImageElement);\n  }\n}\nexport { ImageResource };","map":{"version":3,"mappings":"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","names":["ImageResource","BaseImageResource","constructor","source","options","Image","crossOrigin","crossorigin","imageElement","src","_width","_height","url","_process","preserveBitmap","createBitmap","settings","CREATE_IMAGE_BITMAP","globalThis","alphaMode","bitmap","_load","autoLoad","load","Promise","resolve","reject","completed","destroyed","onload","onerror","resize","width","height","process","complete","event","emit","createImageBitmap","cors","fetch","mode","r","blob","then","premultiplyAlpha","UNPACK","update","upload","renderer","glTexture","baseTexture","flag","glTextures","key","otherTex","dirtyId","close","dispose","test","HTMLImageElement"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/core/src/textures/resources/ImageResource.ts"],"sourcesContent":["import { ALPHA_MODES } from '@pixi/constants';\nimport { settings } from '@pixi/settings';\nimport { BaseImageResource } from './BaseImageResource';\n\nimport type { Renderer } from '../../Renderer';\nimport type { BaseTexture } from '../BaseTexture';\nimport type { GLTexture } from '../GLTexture';\n\nexport interface IImageResourceOptions\n{\n    /** Start loading process automatically when constructed. */\n    autoLoad?: boolean;\n\n    /** Whether its required to create a bitmap before upload. */\n    createBitmap?: boolean;\n\n    /** Load image using cross origin. */\n    crossorigin?: boolean | string;\n\n    /** Premultiply image alpha in bitmap. */\n    alphaMode?: ALPHA_MODES;\n}\n\n/**\n * Resource type for HTMLImageElement.\n * @memberof PIXI\n */\nexport class ImageResource extends BaseImageResource\n{\n    /** URL of the image source */\n    url: string;\n\n    /**\n     * If the image should be disposed after upload\n     * @default false\n     */\n    preserveBitmap: boolean;\n\n    /**\n     * If capable, convert the image using createImageBitmap API.\n     * @default PIXI.settings.CREATE_IMAGE_BITMAP\n     */\n    createBitmap: boolean;\n\n    /**\n     * Controls texture alphaMode field\n     * Copies from options\n     * Default is `null`, copies option from baseTexture\n     * @readonly\n     */\n    alphaMode: ALPHA_MODES;\n\n    /**\n     * The ImageBitmap element created for a {@code HTMLImageElement}.\n     * @default null\n     */\n    bitmap: ImageBitmap;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<ImageResource>;\n\n    /** When process is completed */\n    private _process: Promise<ImageResource>;\n\n    /**\n     * @param source - image source or URL\n     * @param options\n     * @param {boolean} [options.autoLoad=true] - start loading process\n     * @param {boolean} [options.createBitmap=PIXI.settings.CREATE_IMAGE_BITMAP] - whether its required to create\n     *        a bitmap before upload\n     * @param {boolean} [options.crossorigin=true] - Load image using cross origin\n     * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.UNPACK] - Premultiply image alpha in bitmap\n     */\n    constructor(source: HTMLImageElement | string, options?: IImageResourceOptions)\n    {\n        options = options || {};\n\n        if (typeof source === 'string')\n        {\n            const imageElement = new Image();\n\n            BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);\n\n            imageElement.src = source;\n            source = imageElement;\n        }\n\n        super(source);\n\n        // FireFox 68, and possibly other versions, seems like setting the HTMLImageElement#width and #height\n        // to non-zero values before its loading completes if images are in a cache.\n        // Because of this, need to set the `_width` and the `_height` to zero to avoid uploading incomplete images.\n        // Please refer to the issue #5968 (https://github.com/pixijs/pixijs/issues/5968).\n        if (!source.complete && !!this._width && !!this._height)\n        {\n            this._width = 0;\n            this._height = 0;\n        }\n\n        this.url = source.src;\n\n        this._process = null;\n\n        this.preserveBitmap = false;\n        this.createBitmap = (options.createBitmap ?? settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;\n        this.alphaMode = typeof options.alphaMode === 'number' ? options.alphaMode : null;\n        this.bitmap = null;\n\n        this._load = null;\n\n        if (options.autoLoad !== false)\n        {\n            this.load();\n        }\n    }\n\n    /**\n     * Returns a promise when image will be loaded and processed.\n     * @param createBitmap - whether process image into bitmap\n     */\n    load(createBitmap?: boolean): Promise<ImageResource>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        if (createBitmap !== undefined)\n        {\n            this.createBitmap = createBitmap;\n        }\n\n        this._load = new Promise((resolve, reject): void =>\n        {\n            const source = this.source as HTMLImageElement;\n\n            this.url = source.src;\n\n            const completed = (): void =>\n            {\n                if (this.destroyed)\n                {\n                    return;\n                }\n                source.onload = null;\n                source.onerror = null;\n\n                this.resize(source.width, source.height);\n                this._load = null;\n\n                if (this.createBitmap)\n                {\n                    resolve(this.process());\n                }\n                else\n                {\n                    resolve(this);\n                }\n            };\n\n            if (source.complete && source.src)\n            {\n                completed();\n            }\n            else\n            {\n                source.onload = completed;\n                source.onerror = (event): void =>\n                {\n                    // Avoids Promise freezing when resource broken\n                    reject(event);\n                    this.onError.emit(event);\n                };\n            }\n        });\n\n        return this._load;\n    }\n\n    /**\n     * Called when we need to convert image into BitmapImage.\n     * Can be called multiple times, real promise is cached inside.\n     * @returns - Cached promise to fill that bitmap\n     */\n    process(): Promise<ImageResource>\n    {\n        const source = this.source as HTMLImageElement;\n\n        if (this._process !== null)\n        {\n            return this._process;\n        }\n        if (this.bitmap !== null || !globalThis.createImageBitmap)\n        {\n            return Promise.resolve(this);\n        }\n\n        const createImageBitmap = globalThis.createImageBitmap as any;\n        const cors = !source.crossOrigin || source.crossOrigin === 'anonymous';\n\n        this._process = fetch(source.src,\n            {\n                mode: cors ? 'cors' : 'no-cors'\n            })\n            .then((r) => r.blob())\n            .then((blob) => createImageBitmap(blob,\n                0, 0, source.width, source.height,\n                {\n                    premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK\n                        ? 'premultiply' : 'none',\n                }))\n            .then((bitmap: ImageBitmap) =>\n            {\n                if (this.destroyed)\n                {\n                    return Promise.reject();\n                }\n                this.bitmap = bitmap;\n                this.update();\n                this._process = null;\n\n                return Promise.resolve(this);\n            });\n\n        return this._process;\n    }\n\n    /**\n     * Upload the image resource to GPU.\n     * @param renderer - Renderer to upload to\n     * @param baseTexture - BaseTexture for this resource\n     * @param glTexture - GLTexture to use\n     * @returns {boolean} true is success\n     */\n    override upload(renderer: Renderer, baseTexture: BaseTexture, glTexture: GLTexture): boolean\n    {\n        if (typeof this.alphaMode === 'number')\n        {\n            // bitmap stores unpack premultiply flag, we dont have to notify texImage2D about it\n\n            baseTexture.alphaMode = this.alphaMode;\n        }\n\n        if (!this.createBitmap)\n        {\n            return super.upload(renderer, baseTexture, glTexture);\n        }\n        if (!this.bitmap)\n        {\n            // yeah, ignore the output\n            this.process();\n            if (!this.bitmap)\n            {\n                return false;\n            }\n        }\n\n        super.upload(renderer, baseTexture, glTexture, this.bitmap);\n\n        if (!this.preserveBitmap)\n        {\n            // checks if there are other renderers that possibly need this bitmap\n\n            let flag = true;\n\n            const glTextures = baseTexture._glTextures;\n\n            for (const key in glTextures)\n            {\n                const otherTex = glTextures[key];\n\n                if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId)\n                {\n                    flag = false;\n                    break;\n                }\n            }\n\n            if (flag)\n            {\n                if (this.bitmap.close)\n                {\n                    this.bitmap.close();\n                }\n\n                this.bitmap = null;\n            }\n        }\n\n        return true;\n    }\n\n    /** Destroys this resource. */\n    override dispose(): void\n    {\n        (this.source as HTMLImageElement).onload = null;\n        (this.source as HTMLImageElement).onerror = null;\n\n        super.dispose();\n\n        if (this.bitmap)\n        {\n            this.bitmap.close();\n            this.bitmap = null;\n        }\n        this._process = null;\n        this._load = null;\n    }\n\n    /**\n     * Used to auto-detect the type of resource.\n     * @param {*} source - The source object\n     * @returns {boolean} `true` if current environment support HTMLImageElement, and source is string or HTMLImageElement\n     */\n    static override test(source: unknown): source is string | HTMLImageElement\n    {\n        return typeof HTMLImageElement !== 'undefined' && (typeof source === 'string' || source instanceof HTMLImageElement);\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}