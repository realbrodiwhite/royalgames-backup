{"ast":null,"code":"import { BitmapFontData } from '../BitmapFontData.mjs';\nclass TextFormat {\n  static test(data) {\n    return typeof data === \"string\" && data.startsWith(\"info face=\");\n  }\n  static parse(txt) {\n    const items = txt.match(/^[a-z]+\\s+.+$/gm);\n    const rawData = {\n      info: [],\n      common: [],\n      page: [],\n      char: [],\n      chars: [],\n      kerning: [],\n      kernings: [],\n      distanceField: []\n    };\n    for (const i in items) {\n      const name = items[i].match(/^[a-z]+/gm)[0];\n      const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n      const itemData = {};\n      for (const i2 in attributeList) {\n        const split = attributeList[i2].split(\"=\");\n        const key = split[0];\n        const strValue = split[1].replace(/\"/gm, \"\");\n        const floatValue = parseFloat(strValue);\n        const value = isNaN(floatValue) ? strValue : floatValue;\n        itemData[key] = value;\n      }\n      rawData[name].push(itemData);\n    }\n    const font = new BitmapFontData();\n    rawData.info.forEach(info => font.info.push({\n      face: info.face,\n      size: parseInt(info.size, 10)\n    }));\n    rawData.common.forEach(common => font.common.push({\n      lineHeight: parseInt(common.lineHeight, 10)\n    }));\n    rawData.page.forEach(page => font.page.push({\n      id: parseInt(page.id, 10),\n      file: page.file\n    }));\n    rawData.char.forEach(char => font.char.push({\n      id: parseInt(char.id, 10),\n      page: parseInt(char.page, 10),\n      x: parseInt(char.x, 10),\n      y: parseInt(char.y, 10),\n      width: parseInt(char.width, 10),\n      height: parseInt(char.height, 10),\n      xoffset: parseInt(char.xoffset, 10),\n      yoffset: parseInt(char.yoffset, 10),\n      xadvance: parseInt(char.xadvance, 10)\n    }));\n    rawData.kerning.forEach(kerning => font.kerning.push({\n      first: parseInt(kerning.first, 10),\n      second: parseInt(kerning.second, 10),\n      amount: parseInt(kerning.amount, 10)\n    }));\n    rawData.distanceField.forEach(df => font.distanceField.push({\n      distanceRange: parseInt(df.distanceRange, 10),\n      fieldType: df.fieldType\n    }));\n    return font;\n  }\n}\nexport { TextFormat };","map":{"version":3,"mappings":";AAiDO,MAAMA,UACb;EAMI,OAAOC,KAAKC,IACZ;IACI,OAAO,OAAOA,SAAS,QAAY,SAAKC,WAAW,YAAY;EAAA;EAQnE,OAAOC,MAAMC,GACb;IAEU,cAAQA,GAAI,OAAM,iBAAiB;IACzC,MAAMC,OAA8B;MAChCC,MAAM,EAAC;MACPC,QAAQ,EAAC;MACTC,MAAM,EAAC;MACPC,MAAM,EAAC;MACPC,OAAO,EAAC;MACRC,SAAS,EAAC;MACVC,UAAU,EAAC;MACXC,eAAe;IAAC,CACpB;IAEA,WAAWC,KAAKC,KAChB;MAEI,MAAMC,IAAO,SAAMF,CAAG,QAAM,WAAW,CAAE;MAGzC,MAAMG,aAAgB,SAAMH,CAAG,QAAM,kCAAkC;MAGvE,MAAMI,WAAgB,EAAC;MAEvB,WAAWC,MAAKF,aAChB;QAEI,MAAMG,KAAQ,iBAAcD,EAAG,QAAM,GAAG;QACxC,MAAME,MAAMD,KAAM;QAGlB,MAAME,QAAW,SAAM,CAAG,UAAQ,OAAO,EAAE;QAGrC,mBAAaC,WAAWD,QAAQ;QAGtC,MAAME,KAAQ,SAAMC,UAAU,IAAIH,QAAW;QAE7CJ,SAASG,GAAO;MAAA;MAIZhB,cAAMqB,KAAKR,QAAQ;IAAA;IAGzB,aAAO,IAAIS,cAAe;IAEhCtB,QAAQC,KAAKsB,OAAQ,CAACtB,IAAS,SAAKA,KAAKoB,IAAK;MAC1CG,MAAMvB,IAAK;MACXwB,IAAM,WAASxB,IAAK,OAAM,EAAE;IAAA,CAC/B,CAAC;IAEFD,QAAQE,OAAOqB,OAAQ,CAACrB,MAAW,SAAKA,OAAOmB,IAAK;MAChDK,UAAY,WAASxB,MAAO,aAAY,EAAE;IAAA,CAC7C,CAAC;IAEFF,QAAQG,KAAKoB,OAAQ,CAACpB,IAAS,SAAKA,KAAKkB,IAAK;MAC1CM,EAAI,WAASxB,IAAK,KAAI,EAAE;MACxByB,MAAMzB,IAAK;IAAA,CACd,CAAC;IAEFH,QAAQI,KAAKmB,OAAQ,CAACnB,IAAS,SAAKA,KAAKiB,IAAK;MAC1CM,EAAI,WAASvB,IAAK,KAAI,EAAE;MACxBD,IAAM,WAASC,IAAK,OAAM,EAAE;MAC5ByB,CAAG,WAASzB,IAAK,IAAG,EAAE;MACtB0B,CAAG,WAAS1B,IAAK,IAAG,EAAE;MACtB2B,KAAO,WAAS3B,IAAK,QAAO,EAAE;MAC9B4B,MAAQ,WAAS5B,IAAK,SAAQ,EAAE;MAChC6B,OAAS,WAAS7B,IAAK,UAAS,EAAE;MAClC8B,OAAS,WAAS9B,IAAK,UAAS,EAAE;MAClC+B,QAAU,WAAS/B,IAAK,WAAU,EAAE;IAAA,CACvC,CAAC;IAEFJ,QAAQM,QAAQiB,OAAQ,CAACjB,OAAY,SAAKA,QAAQe,IAAK;MACnDe,KAAO,WAAS9B,OAAQ,QAAO,EAAE;MACjC+B,MAAQ,WAAS/B,OAAQ,SAAQ,EAAE;MACnCgC,MAAQ,WAAShC,OAAQ,SAAQ,EAAE;IAAA,CACtC,CAAC;IAEFN,QAAQQ,cAAce,OAAQ,CAACgB,EAAO,SAAK/B,cAAca,IAAK;MAC1DmB,aAAe,WAASD,EAAG,gBAAe,EAAE;MAC5CE,WAAWF,EAAG;IAAA,CACjB,CAAC;IAEK;EAAA;AAEf","names":["TextFormat","test","data","startsWith","parse","txt","rawData","info","common","page","char","chars","kerning","kernings","distanceField","i","items","name","attributeList","itemData","i2","split","key","strValue","parseFloat","value","floatValue","push","BitmapFontData","forEach","face","size","lineHeight","id","file","x","y","width","height","xoffset","yoffset","xadvance","first","second","amount","df","distanceRange","fieldType"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/text-bitmap/src/formats/TextFormat.ts"],"sourcesContent":["import { BitmapFontData } from '../BitmapFontData';\n\n/**\n * Internal data format used to convert to BitmapFontData.\n * @private\n */\nexport interface IBitmapFontRawData\n{\n    info: {\n        face: string;\n        size: string;\n    }[];\n    common: { lineHeight: string }[];\n    page: {\n        id: string;\n        file: string;\n    }[];\n    chars: {\n        count: number;\n    }[];\n    char: {\n        id: string;\n        page: string;\n        x: string;\n        y: string;\n        width: string;\n        height: string;\n        xoffset: string;\n        yoffset: string;\n        xadvance: string;\n    }[];\n    kernings?: {\n        count: number;\n    }[];\n    kerning?: {\n        first: string;\n        second: string;\n        amount: string;\n    }[];\n    distanceField?: {\n        fieldType: string;\n        distanceRange: string;\n    }[]\n}\n\n/**\n * BitmapFont format that's Text-based.\n * @private\n */\nexport class TextFormat\n{\n    /**\n     * Check if resource refers to txt font data.\n     * @param data\n     * @returns - True if resource could be treated as font data, false otherwise.\n     */\n    static test(data: unknown): boolean\n    {\n        return typeof data === 'string' && data.startsWith('info face=');\n    }\n\n    /**\n     * Convert text font data to a javascript object.\n     * @param txt - Raw string data to be converted\n     * @returns - Parsed font data\n     */\n    static parse(txt: string): BitmapFontData\n    {\n        // Retrieve data item\n        const items = txt.match(/^[a-z]+\\s+.+$/gm);\n        const rawData: IBitmapFontRawData = {\n            info: [],\n            common: [],\n            page: [],\n            char: [],\n            chars: [],\n            kerning: [],\n            kernings: [],\n            distanceField: [],\n        };\n\n        for (const i in items)\n        {\n            // Extract item name\n            const name = items[i].match(/^[a-z]+/gm)[0] as keyof BitmapFontData;\n\n            // Extract item attribute list as string ex.: \"width=10\"\n            const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n\n            // Convert attribute list into an object\n            const itemData: any = {};\n\n            for (const i in attributeList)\n            {\n                // Split key-value pairs\n                const split = attributeList[i].split('=');\n                const key = split[0];\n\n                // Remove eventual quotes from value\n                const strValue = split[1].replace(/\"/gm, '');\n\n                // Try to convert value into float\n                const floatValue = parseFloat(strValue);\n\n                // Use string value case float value is NaN\n                const value = isNaN(floatValue) ? strValue : floatValue;\n\n                itemData[key] = value;\n            }\n\n            // Push current item to the resulting data\n            rawData[name].push(itemData);\n        }\n\n        const font = new BitmapFontData();\n\n        rawData.info.forEach((info) => font.info.push({\n            face: info.face,\n            size: parseInt(info.size, 10),\n        }));\n\n        rawData.common.forEach((common) => font.common.push({\n            lineHeight: parseInt(common.lineHeight, 10),\n        }));\n\n        rawData.page.forEach((page) => font.page.push({\n            id: parseInt(page.id, 10),\n            file: page.file,\n        }));\n\n        rawData.char.forEach((char) => font.char.push({\n            id: parseInt(char.id, 10),\n            page: parseInt(char.page, 10),\n            x: parseInt(char.x, 10),\n            y: parseInt(char.y, 10),\n            width: parseInt(char.width, 10),\n            height: parseInt(char.height, 10),\n            xoffset: parseInt(char.xoffset, 10),\n            yoffset: parseInt(char.yoffset, 10),\n            xadvance: parseInt(char.xadvance, 10),\n        }));\n\n        rawData.kerning.forEach((kerning) => font.kerning.push({\n            first: parseInt(kerning.first, 10),\n            second: parseInt(kerning.second, 10),\n            amount: parseInt(kerning.amount, 10),\n        }));\n\n        rawData.distanceField.forEach((df) => font.distanceField.push({\n            distanceRange: parseInt(df.distanceRange, 10),\n            fieldType: df.fieldType,\n        }));\n\n        return font;\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}