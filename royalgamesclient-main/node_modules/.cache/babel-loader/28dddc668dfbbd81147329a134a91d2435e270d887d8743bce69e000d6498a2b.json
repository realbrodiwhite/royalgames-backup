{"ast":null,"code":"import { ENV } from '@pixi/constants';\nimport { ExtensionType, extensions } from '@pixi/extensions';\nimport { settings } from '@pixi/settings';\nimport { deprecation, premultiplyBlendMode, nextPow2, log2, premultiplyTint } from '@pixi/utils';\nimport { ViewableBuffer } from '../geometry/ViewableBuffer.mjs';\nimport { checkMaxIfStatementsInShader } from '../shader/utils/checkMaxIfStatementsInShader.mjs';\nimport { State } from '../state/State.mjs';\nimport { BaseTexture } from '../textures/BaseTexture.mjs';\nimport { BatchDrawCall } from './BatchDrawCall.mjs';\nimport { BatchGeometry } from './BatchGeometry.mjs';\nimport { BatchShaderGenerator } from './BatchShaderGenerator.mjs';\nimport { BatchTextureArray } from './BatchTextureArray.mjs';\nimport { canUploadSameBuffer } from './canUploadSameBuffer.mjs';\nimport { maxRecommendedTextures } from './maxRecommendedTextures.mjs';\nimport { ObjectRenderer } from './ObjectRenderer.mjs';\nimport defaultFragment from './texture.mjs';\nimport defaultVertex from './texture2.mjs';\nconst _BatchRenderer = class extends ObjectRenderer {\n  constructor(renderer) {\n    super(renderer);\n    this.setShaderGenerator();\n    this.geometryClass = BatchGeometry;\n    this.vertexSize = 6;\n    this.state = State.for2d();\n    this.size = _BatchRenderer.defaultBatchSize * 4;\n    this._vertexCount = 0;\n    this._indexCount = 0;\n    this._bufferedElements = [];\n    this._bufferedTextures = [];\n    this._bufferSize = 0;\n    this._shader = null;\n    this._packedGeometries = [];\n    this._packedGeometryPoolSize = 2;\n    this._flushId = 0;\n    this._aBuffers = {};\n    this._iBuffers = {};\n    this.maxTextures = 1;\n    this.renderer.on(\"prerender\", this.onPrerender, this);\n    renderer.runners.contextChange.add(this);\n    this._dcIndex = 0;\n    this._aIndex = 0;\n    this._iIndex = 0;\n    this._attributeBuffer = null;\n    this._indexBuffer = null;\n    this._tempBoundTextures = [];\n  }\n  static get defaultMaxTextures() {\n    var _this$_defaultMaxText;\n    this._defaultMaxTextures = (_this$_defaultMaxText = this._defaultMaxTextures) !== null && _this$_defaultMaxText !== void 0 ? _this$_defaultMaxText : maxRecommendedTextures(32);\n    return this._defaultMaxTextures;\n  }\n  static set defaultMaxTextures(value) {\n    this._defaultMaxTextures = value;\n  }\n  static get canUploadSameBuffer() {\n    var _this$_canUploadSameB;\n    this._canUploadSameBuffer = (_this$_canUploadSameB = this._canUploadSameBuffer) !== null && _this$_canUploadSameB !== void 0 ? _this$_canUploadSameB : canUploadSameBuffer();\n    return this._canUploadSameBuffer;\n  }\n  static set canUploadSameBuffer(value) {\n    this._canUploadSameBuffer = value;\n  }\n  get MAX_TEXTURES() {\n    deprecation(\"7.1.0\", \"BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures\");\n    return this.maxTextures;\n  }\n  static get defaultVertexSrc() {\n    return defaultVertex;\n  }\n  static get defaultFragmentTemplate() {\n    return defaultFragment;\n  }\n  setShaderGenerator() {\n    let {\n      vertex = _BatchRenderer.defaultVertexSrc,\n      fragment = _BatchRenderer.defaultFragmentTemplate\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.shaderGenerator = new BatchShaderGenerator(vertex, fragment);\n  }\n  contextChange() {\n    const gl = this.renderer.gl;\n    if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {\n      this.maxTextures = 1;\n    } else {\n      this.maxTextures = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), _BatchRenderer.defaultMaxTextures);\n      this.maxTextures = checkMaxIfStatementsInShader(this.maxTextures, gl);\n    }\n    this._shader = this.shaderGenerator.generateShader(this.maxTextures);\n    for (let i = 0; i < this._packedGeometryPoolSize; i++) {\n      this._packedGeometries[i] = new this.geometryClass();\n    }\n    this.initFlushBuffers();\n  }\n  initFlushBuffers() {\n    const {\n      _drawCallPool,\n      _textureArrayPool\n    } = _BatchRenderer;\n    const MAX_SPRITES = this.size / 4;\n    const MAX_TA = Math.floor(MAX_SPRITES / this.maxTextures) + 1;\n    while (_drawCallPool.length < MAX_SPRITES) {\n      _drawCallPool.push(new BatchDrawCall());\n    }\n    while (_textureArrayPool.length < MAX_TA) {\n      _textureArrayPool.push(new BatchTextureArray());\n    }\n    for (let i = 0; i < this.maxTextures; i++) {\n      this._tempBoundTextures[i] = null;\n    }\n  }\n  onPrerender() {\n    this._flushId = 0;\n  }\n  render(element) {\n    if (!element._texture.valid) {\n      return;\n    }\n    if (this._vertexCount + element.vertexData.length / 2 > this.size) {\n      this.flush();\n    }\n    this._vertexCount += element.vertexData.length / 2;\n    this._indexCount += element.indices.length;\n    this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;\n    this._bufferedElements[this._bufferSize++] = element;\n  }\n  buildTexturesAndDrawCalls() {\n    const {\n      _bufferedTextures: textures,\n      maxTextures\n    } = this;\n    const textureArrays = _BatchRenderer._textureArrayPool;\n    const batch = this.renderer.batch;\n    const boundTextures = this._tempBoundTextures;\n    const touch = this.renderer.textureGC.count;\n    let TICK = ++BaseTexture._globalBatch;\n    let countTexArrays = 0;\n    let texArray = textureArrays[0];\n    let start = 0;\n    batch.copyBoundTextures(boundTextures, maxTextures);\n    for (let i = 0; i < this._bufferSize; ++i) {\n      const tex = textures[i];\n      textures[i] = null;\n      if (tex._batchEnabled === TICK) {\n        continue;\n      }\n      if (texArray.count >= maxTextures) {\n        batch.boundArray(texArray, boundTextures, TICK, maxTextures);\n        this.buildDrawCalls(texArray, start, i);\n        start = i;\n        texArray = textureArrays[++countTexArrays];\n        ++TICK;\n      }\n      tex._batchEnabled = TICK;\n      tex.touched = touch;\n      texArray.elements[texArray.count++] = tex;\n    }\n    if (texArray.count > 0) {\n      batch.boundArray(texArray, boundTextures, TICK, maxTextures);\n      this.buildDrawCalls(texArray, start, this._bufferSize);\n      ++countTexArrays;\n      ++TICK;\n    }\n    for (let i = 0; i < boundTextures.length; i++) {\n      boundTextures[i] = null;\n    }\n    BaseTexture._globalBatch = TICK;\n  }\n  buildDrawCalls(texArray, start, finish) {\n    const {\n      _bufferedElements: elements,\n      _attributeBuffer,\n      _indexBuffer,\n      vertexSize\n    } = this;\n    const drawCalls = _BatchRenderer._drawCallPool;\n    let dcIndex = this._dcIndex;\n    let aIndex = this._aIndex;\n    let iIndex = this._iIndex;\n    let drawCall = drawCalls[dcIndex];\n    drawCall.start = this._iIndex;\n    drawCall.texArray = texArray;\n    for (let i = start; i < finish; ++i) {\n      const sprite = elements[i];\n      const tex = sprite._texture.baseTexture;\n      const spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];\n      elements[i] = null;\n      if (start < i && drawCall.blend !== spriteBlendMode) {\n        drawCall.size = iIndex - drawCall.start;\n        start = i;\n        drawCall = drawCalls[++dcIndex];\n        drawCall.texArray = texArray;\n        drawCall.start = iIndex;\n      }\n      this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);\n      aIndex += sprite.vertexData.length / 2 * vertexSize;\n      iIndex += sprite.indices.length;\n      drawCall.blend = spriteBlendMode;\n    }\n    if (start < finish) {\n      drawCall.size = iIndex - drawCall.start;\n      ++dcIndex;\n    }\n    this._dcIndex = dcIndex;\n    this._aIndex = aIndex;\n    this._iIndex = iIndex;\n  }\n  bindAndClearTexArray(texArray) {\n    const textureSystem = this.renderer.texture;\n    for (let j = 0; j < texArray.count; j++) {\n      textureSystem.bind(texArray.elements[j], texArray.ids[j]);\n      texArray.elements[j] = null;\n    }\n    texArray.count = 0;\n  }\n  updateGeometry() {\n    const {\n      _packedGeometries: packedGeometries,\n      _attributeBuffer: attributeBuffer,\n      _indexBuffer: indexBuffer\n    } = this;\n    if (!_BatchRenderer.canUploadSameBuffer) {\n      if (this._packedGeometryPoolSize <= this._flushId) {\n        this._packedGeometryPoolSize++;\n        packedGeometries[this._flushId] = new this.geometryClass();\n      }\n      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);\n      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);\n      this.renderer.geometry.bind(packedGeometries[this._flushId]);\n      this.renderer.geometry.updateBuffers();\n      this._flushId++;\n    } else {\n      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);\n      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);\n      this.renderer.geometry.updateBuffers();\n    }\n  }\n  drawBatches() {\n    const dcCount = this._dcIndex;\n    const {\n      gl,\n      state: stateSystem\n    } = this.renderer;\n    const drawCalls = _BatchRenderer._drawCallPool;\n    let curTexArray = null;\n    for (let i = 0; i < dcCount; i++) {\n      const {\n        texArray,\n        type,\n        size,\n        start,\n        blend\n      } = drawCalls[i];\n      if (curTexArray !== texArray) {\n        curTexArray = texArray;\n        this.bindAndClearTexArray(texArray);\n      }\n      this.state.blendMode = blend;\n      stateSystem.set(this.state);\n      gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);\n    }\n  }\n  flush() {\n    if (this._vertexCount === 0) {\n      return;\n    }\n    this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);\n    this._indexBuffer = this.getIndexBuffer(this._indexCount);\n    this._aIndex = 0;\n    this._iIndex = 0;\n    this._dcIndex = 0;\n    this.buildTexturesAndDrawCalls();\n    this.updateGeometry();\n    this.drawBatches();\n    this._bufferSize = 0;\n    this._vertexCount = 0;\n    this._indexCount = 0;\n  }\n  start() {\n    this.renderer.state.set(this.state);\n    this.renderer.texture.ensureSamplerType(this.maxTextures);\n    this.renderer.shader.bind(this._shader);\n    if (_BatchRenderer.canUploadSameBuffer) {\n      this.renderer.geometry.bind(this._packedGeometries[this._flushId]);\n    }\n  }\n  stop() {\n    this.flush();\n  }\n  destroy() {\n    for (let i = 0; i < this._packedGeometryPoolSize; i++) {\n      if (this._packedGeometries[i]) {\n        this._packedGeometries[i].destroy();\n      }\n    }\n    this.renderer.off(\"prerender\", this.onPrerender, this);\n    this._aBuffers = null;\n    this._iBuffers = null;\n    this._packedGeometries = null;\n    this._attributeBuffer = null;\n    this._indexBuffer = null;\n    if (this._shader) {\n      this._shader.destroy();\n      this._shader = null;\n    }\n    super.destroy();\n  }\n  getAttributeBuffer(size) {\n    const roundedP2 = nextPow2(Math.ceil(size / 8));\n    const roundedSizeIndex = log2(roundedP2);\n    const roundedSize = roundedP2 * 8;\n    if (this._aBuffers.length <= roundedSizeIndex) {\n      this._iBuffers.length = roundedSizeIndex + 1;\n    }\n    let buffer = this._aBuffers[roundedSize];\n    if (!buffer) {\n      this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);\n    }\n    return buffer;\n  }\n  getIndexBuffer(size) {\n    const roundedP2 = nextPow2(Math.ceil(size / 12));\n    const roundedSizeIndex = log2(roundedP2);\n    const roundedSize = roundedP2 * 12;\n    if (this._iBuffers.length <= roundedSizeIndex) {\n      this._iBuffers.length = roundedSizeIndex + 1;\n    }\n    let buffer = this._iBuffers[roundedSizeIndex];\n    if (!buffer) {\n      this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);\n    }\n    return buffer;\n  }\n  packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {\n    const {\n      uint32View,\n      float32View\n    } = attributeBuffer;\n    const packedVertices = aIndex / this.vertexSize;\n    const uvs = element.uvs;\n    const indicies = element.indices;\n    const vertexData = element.vertexData;\n    const textureId = element._texture.baseTexture._batchLocation;\n    const alpha = Math.min(element.worldAlpha, 1);\n    const argb = alpha < 1 && element._texture.baseTexture.alphaMode ? premultiplyTint(element._tintRGB, alpha) : element._tintRGB + (alpha * 255 << 24);\n    for (let i = 0; i < vertexData.length; i += 2) {\n      float32View[aIndex++] = vertexData[i];\n      float32View[aIndex++] = vertexData[i + 1];\n      float32View[aIndex++] = uvs[i];\n      float32View[aIndex++] = uvs[i + 1];\n      uint32View[aIndex++] = argb;\n      float32View[aIndex++] = textureId;\n    }\n    for (let i = 0; i < indicies.length; i++) {\n      indexBuffer[iIndex++] = packedVertices + indicies[i];\n    }\n  }\n};\nlet BatchRenderer = _BatchRenderer;\nBatchRenderer.defaultBatchSize = 4096;\nBatchRenderer.extension = {\n  name: \"batch\",\n  type: ExtensionType.RendererPlugin\n};\nBatchRenderer._drawCallPool = [];\nBatchRenderer._textureArrayPool = [];\nextensions.add(BatchRenderer);\nexport { BatchRenderer };","map":{"version":3,"mappings":"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","names":["_BatchRenderer","ObjectRenderer","constructor","renderer","setShaderGenerator","geometryClass","vertexSize","State","for2d","defaultBatchSize","_vertexCount","_indexCount","_bufferedElements","_bufferedTextures","_bufferSize","_shader","_packedGeometries","_packedGeometryPoolSize","_flushId","_aBuffers","_iBuffers","maxTextures","onPrerender","contextChange","_dcIndex","_aIndex","_iIndex","_attributeBuffer","_indexBuffer","_tempBoundTextures","defaultMaxTextures","_defaultMaxTextures","value","canUploadSameBuffer","_canUploadSameBuffer","MAX_TEXTURES","deprecation","defaultVertexSrc","defaultFragmentTemplate","vertex","fragment","shaderGenerator","BatchShaderGenerator","PREFER_ENV","WEBGL_LEGACY","Math","min","getParameter","gl","i","initFlushBuffers","_drawCallPool","_textureArrayPool","size","MAX_TA","MAX_SPRITES","length","BatchDrawCall","BatchTextureArray","render","element","valid","vertexData","flush","indices","_texture","buildTexturesAndDrawCalls","textureArrays","boundTextures","textureGC","BaseTexture","countTexArrays","texArray","start","batch","tex","textures","_batchEnabled","TICK","count","boundArray","touched","buildDrawCalls","_globalBatch","finish","drawCalls","dcIndex","aIndex","iIndex","drawCall","sprite","elements","spriteBlendMode","premultiplyBlendMode","alphaMode","packInterleavedGeometry","blend","bindAndClearTexArray","j","textureSystem","bind","ids","updateGeometry","packedGeometries","_buffer","attributeBuffer","rawBinaryData","indexBuffer","geometry","updateBuffers","drawBatches","dcCount","state","curTexArray","type","blendMode","stateSystem","drawElements","getAttributeBuffer","getIndexBuffer","set","ensureSamplerType","stop","destroy","roundedP2","nextPow2","ceil","log2","roundedSize","roundedSizeIndex","buffer","ViewableBuffer","Uint16Array","uint32View","float32View","uvs","indicies","baseTexture","alpha","worldAlpha","argb","premultiplyTint","_tintRGB","packedVertices","BatchRenderer","extension","name","ExtensionType","extensions","add"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/core/src/batch/BatchRenderer.ts"],"sourcesContent":["import { ENV } from '@pixi/constants';\nimport { extensions, ExtensionType } from '@pixi/extensions';\nimport { settings } from '@pixi/settings';\nimport { deprecation, log2, nextPow2, premultiplyBlendMode, premultiplyTint } from '@pixi/utils';\nimport { ViewableBuffer } from '../geometry/ViewableBuffer';\nimport { checkMaxIfStatementsInShader } from '../shader/utils/checkMaxIfStatementsInShader';\nimport { State } from '../state/State';\nimport { BaseTexture } from '../textures/BaseTexture';\nimport { BatchDrawCall } from './BatchDrawCall';\nimport { BatchGeometry } from './BatchGeometry';\nimport { BatchShaderGenerator } from './BatchShaderGenerator';\nimport { BatchTextureArray } from './BatchTextureArray';\nimport { canUploadSameBuffer } from './canUploadSameBuffer';\nimport { maxRecommendedTextures } from './maxRecommendedTextures';\nimport { ObjectRenderer } from './ObjectRenderer';\nimport defaultFragment from './texture.frag';\nimport defaultVertex from './texture.vert';\n\nimport type { BLEND_MODES } from '@pixi/constants';\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { Renderer } from '../Renderer';\nimport type { Shader } from '../shader/Shader';\nimport type { Texture } from '../textures/Texture';\n\n/**\n * Interface for elements like Sprite, Mesh etc. for batching.\n * @memberof PIXI\n */\nexport interface IBatchableElement\n{\n    _texture: Texture;\n    vertexData: Float32Array;\n    indices: Uint16Array | Uint32Array | Array<number>;\n    uvs: Float32Array;\n    worldAlpha: number;\n    _tintRGB: number;\n    blendMode: BLEND_MODES;\n}\n\n/**\n * Renderer dedicated to drawing and batching sprites.\n *\n * This is the default batch renderer. It buffers objects\n * with texture-based geometries and renders them in\n * batches. It uploads multiple textures to the GPU to\n * reduce to the number of draw calls.\n * @memberof PIXI\n */\nexport class BatchRenderer extends ObjectRenderer\n{\n    /**\n     * The maximum textures that this device supports.\n     * @static\n     * @default 32\n     */\n    public static get defaultMaxTextures(): number\n    {\n        this._defaultMaxTextures = this._defaultMaxTextures ?? maxRecommendedTextures(32);\n\n        return this._defaultMaxTextures;\n    }\n    public static set defaultMaxTextures(value: number)\n    {\n        this._defaultMaxTextures = value;\n    }\n\n    /** @ignore */\n    private static _defaultMaxTextures: number;\n\n    /**\n     * The default sprite batch size.\n     *\n     * The default aims to balance desktop and mobile devices.\n     * @static\n     */\n    public static defaultBatchSize = 4096;\n\n    /**\n     * Can we upload the same buffer in a single frame?\n     * @static\n     */\n    public static get canUploadSameBuffer(): boolean\n    {\n        this._canUploadSameBuffer = this._canUploadSameBuffer ?? canUploadSameBuffer();\n\n        return this._canUploadSameBuffer;\n    }\n    public static set canUploadSameBuffer(value: boolean)\n    {\n        this._canUploadSameBuffer = value;\n    }\n\n    /** @ignore */\n    private static _canUploadSameBuffer: boolean;\n\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'batch',\n        type: ExtensionType.RendererPlugin,\n    };\n\n    /** The WebGL state in which this renderer will work. */\n    public readonly state: State;\n\n    /**\n     * The number of bufferable objects before a flush\n     * occurs automatically.\n     * @default PIXI.BatchRenderer.defaultBatchSize * 4\n     */\n    public size: number;\n\n    /**\n     * Maximum number of textures that can be uploaded to\n     * the GPU under the current context. It is initialized\n     * properly in `this.contextChange`.\n     * @see PIXI.BatchRenderer#contextChange\n     * @readonly\n     */\n    public maxTextures: number;\n\n    /**\n     * This is used to generate a shader that can\n     * color each vertex based on a `aTextureId`\n     * attribute that points to an texture in `uSampler`.\n     *\n     * This enables the objects with different textures\n     * to be drawn in the same draw call.\n     *\n     * You can customize your shader by creating your\n     * custom shader generator.\n     */\n    protected shaderGenerator: BatchShaderGenerator;\n\n    /**\n     * The class that represents the geometry of objects\n     * that are going to be batched with this.\n     * @member {object}\n     * @default PIXI.BatchGeometry\n     */\n    protected geometryClass: typeof BatchGeometry;\n\n    /**\n     * Size of data being buffered per vertex in the\n     * attribute buffers (in floats). By default, the\n     * batch-renderer plugin uses 6:\n     *\n     * | aVertexPosition | 2 |\n     * |-----------------|---|\n     * | aTextureCoords  | 2 |\n     * | aColor          | 1 |\n     * | aTextureId      | 1 |\n     * @default 6\n     */\n    protected vertexSize: number;\n\n    /** Total count of all vertices used by the currently buffered objects. */\n    protected _vertexCount: number;\n\n    /** Total count of all indices used by the currently buffered objects. */\n    protected _indexCount: number;\n\n    /**\n     * Buffer of objects that are yet to be rendered.\n     * @member {PIXI.DisplayObject[]}\n     */\n    protected _bufferedElements: Array<IBatchableElement>;\n\n    /**\n     * Data for texture batch builder, helps to save a bit of CPU on a pass.\n     * @member {PIXI.BaseTexture[]}\n     */\n    protected _bufferedTextures: Array<BaseTexture>;\n\n    /** Number of elements that are buffered and are waiting to be flushed. */\n    protected _bufferSize: number;\n\n    /**\n     * This shader is generated by `this.shaderGenerator`.\n     *\n     * It is generated specifically to handle the required\n     * number of textures being batched together.\n     */\n    protected _shader: Shader;\n\n    /**\n     * A flush may occur multiple times in a single\n     * frame. On iOS devices or when\n     * `BatchRenderer.canUploadSameBuffer` is false, the\n     * batch renderer does not upload data to the same\n     * `WebGLBuffer` for performance reasons.\n     *\n     * This is the index into `packedGeometries` that points to\n     * geometry holding the most recent buffers.\n     */\n    protected _flushId: number;\n\n    /**\n     * Pool of `ViewableBuffer` objects that are sorted in\n     * order of increasing size. The flush method uses\n     * the buffer with the least size above the amount\n     * it requires. These are used for passing attributes.\n     *\n     * The first buffer has a size of 8; each subsequent\n     * buffer has double capacity of its previous.\n     * @member {PIXI.ViewableBuffer[]}\n     * @see PIXI.BatchRenderer#getAttributeBuffer\n     */\n    protected _aBuffers: Array<ViewableBuffer>;\n\n    /**\n     * Pool of `Uint16Array` objects that are sorted in\n     * order of increasing size. The flush method uses\n     * the buffer with the least size above the amount\n     * it requires. These are used for passing indices.\n     *\n     * The first buffer has a size of 12; each subsequent\n     * buffer has double capacity of its previous.\n     * @member {Uint16Array[]}\n     * @see PIXI.BatchRenderer#getIndexBuffer\n     */\n    protected _iBuffers: Array<Uint16Array>;\n    protected _dcIndex: number;\n    protected _aIndex: number;\n    protected _iIndex: number;\n    protected _attributeBuffer: ViewableBuffer;\n    protected _indexBuffer: Uint16Array;\n    protected _tempBoundTextures: BaseTexture[];\n\n    /**\n     * Pool of `this.geometryClass` geometry objects\n     * that store buffers. They are used to pass data\n     * to the shader on each draw call.\n     *\n     * These are never re-allocated again, unless a\n     * context change occurs; however, the pool may\n     * be expanded if required.\n     * @member {PIXI.Geometry[]}\n     * @see PIXI.BatchRenderer.contextChange\n     */\n    private _packedGeometries: Array<BatchGeometry>;\n\n    /**\n     * Size of `this._packedGeometries`. It can be expanded\n     * if more than `this._packedGeometryPoolSize` flushes\n     * occur in a single frame.\n     */\n    private _packedGeometryPoolSize: number;\n\n    /**\n     * This will hook onto the renderer's `contextChange`\n     * and `prerender` signals.\n     * @param {PIXI.Renderer} renderer - The renderer this works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        this.setShaderGenerator();\n        this.geometryClass = BatchGeometry;\n        this.vertexSize = 6;\n        this.state = State.for2d();\n        this.size = BatchRenderer.defaultBatchSize * 4;\n        this._vertexCount = 0;\n        this._indexCount = 0;\n        this._bufferedElements = [];\n        this._bufferedTextures = [];\n        this._bufferSize = 0;\n        this._shader = null;\n        this._packedGeometries = [];\n        this._packedGeometryPoolSize = 2;\n        this._flushId = 0;\n        this._aBuffers = {} as any;\n        this._iBuffers = {} as any;\n\n        this.maxTextures = 1;\n\n        this.renderer.on('prerender', this.onPrerender, this);\n        renderer.runners.contextChange.add(this);\n\n        this._dcIndex = 0;\n        this._aIndex = 0;\n        this._iIndex = 0;\n        this._attributeBuffer = null;\n        this._indexBuffer = null;\n        this._tempBoundTextures = [];\n    }\n\n    /**\n     * @see PIXI.BatchRenderer#maxTextures\n     * @deprecated since 7.1.0\n     * @readonly\n     */\n    get MAX_TEXTURES(): number\n    {\n        // #if _DEBUG\n        deprecation('7.1.0', 'BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures');\n        // #endif\n\n        return this.maxTextures;\n    }\n\n    /**\n     * The default vertex shader source\n     * @readonly\n     */\n    static get defaultVertexSrc(): string\n    {\n        return defaultVertex;\n    }\n\n    /**\n     * The default fragment shader source\n     * @readonly\n     */\n    static get defaultFragmentTemplate(): string\n    {\n        return defaultFragment;\n    }\n\n    /**\n     * Set the shader generator.\n     * @param {object} [options]\n     * @param {string} [options.vertex=PIXI.BatchRenderer.defaultVertexSrc] - Vertex shader source\n     * @param {string} [options.fragment=PIXI.BatchRenderer.defaultFragmentTemplate] - Fragment shader template\n     */\n    public setShaderGenerator({\n        vertex = BatchRenderer.defaultVertexSrc,\n        fragment = BatchRenderer.defaultFragmentTemplate\n    }: { vertex?: string, fragment?: string } = {}): void\n    {\n        this.shaderGenerator = new BatchShaderGenerator(vertex, fragment);\n    }\n\n    /**\n     * Handles the `contextChange` signal.\n     *\n     * It calculates `this.maxTextures` and allocating the packed-geometry object pool.\n     */\n    contextChange(): void\n    {\n        const gl = this.renderer.gl;\n\n        if (settings.PREFER_ENV === ENV.WEBGL_LEGACY)\n        {\n            this.maxTextures = 1;\n        }\n        else\n        {\n            // step 1: first check max textures the GPU can handle.\n            this.maxTextures = Math.min(\n                gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),\n                BatchRenderer.defaultMaxTextures);\n\n            // step 2: check the maximum number of if statements the shader can have too..\n            this.maxTextures = checkMaxIfStatementsInShader(\n                this.maxTextures, gl);\n        }\n\n        this._shader = this.shaderGenerator.generateShader(this.maxTextures);\n\n        // we use the second shader as the first one depending on your browser\n        // may omit aTextureId as it is not used by the shader so is optimized out.\n        for (let i = 0; i < this._packedGeometryPoolSize; i++)\n        {\n            /* eslint-disable max-len */\n            this._packedGeometries[i] = new (this.geometryClass)();\n        }\n\n        this.initFlushBuffers();\n    }\n\n    /** Makes sure that static and dynamic flush pooled objects have correct dimensions. */\n    initFlushBuffers(): void\n    {\n        const {\n            _drawCallPool,\n            _textureArrayPool,\n        } = BatchRenderer;\n        // max draw calls\n        const MAX_SPRITES = this.size / 4;\n        // max texture arrays\n        const MAX_TA = Math.floor(MAX_SPRITES / this.maxTextures) + 1;\n\n        while (_drawCallPool.length < MAX_SPRITES)\n        {\n            _drawCallPool.push(new BatchDrawCall());\n        }\n        while (_textureArrayPool.length < MAX_TA)\n        {\n            _textureArrayPool.push(new BatchTextureArray());\n        }\n        for (let i = 0; i < this.maxTextures; i++)\n        {\n            this._tempBoundTextures[i] = null;\n        }\n    }\n\n    /** Handles the `prerender` signal. It ensures that flushes start from the first geometry object again. */\n    onPrerender(): void\n    {\n        this._flushId = 0;\n    }\n\n    /**\n     * Buffers the \"batchable\" object. It need not be rendered immediately.\n     * @param {PIXI.DisplayObject} element - the element to render when\n     *    using this renderer\n     */\n    render(element: IBatchableElement): void\n    {\n        if (!element._texture.valid)\n        {\n            return;\n        }\n\n        if (this._vertexCount + (element.vertexData.length / 2) > this.size)\n        {\n            this.flush();\n        }\n\n        this._vertexCount += element.vertexData.length / 2;\n        this._indexCount += element.indices.length;\n        this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;\n        this._bufferedElements[this._bufferSize++] = element;\n    }\n\n    buildTexturesAndDrawCalls(): void\n    {\n        const {\n            _bufferedTextures: textures,\n            maxTextures,\n        } = this;\n        const textureArrays = BatchRenderer._textureArrayPool;\n        const batch = this.renderer.batch;\n        const boundTextures = this._tempBoundTextures;\n        const touch = this.renderer.textureGC.count;\n\n        let TICK = ++BaseTexture._globalBatch;\n        let countTexArrays = 0;\n        let texArray = textureArrays[0];\n        let start = 0;\n\n        batch.copyBoundTextures(boundTextures, maxTextures);\n\n        for (let i = 0; i < this._bufferSize; ++i)\n        {\n            const tex = textures[i];\n\n            textures[i] = null;\n            if (tex._batchEnabled === TICK)\n            {\n                continue;\n            }\n\n            if (texArray.count >= maxTextures)\n            {\n                batch.boundArray(texArray, boundTextures, TICK, maxTextures);\n                this.buildDrawCalls(texArray, start, i);\n                start = i;\n                texArray = textureArrays[++countTexArrays];\n                ++TICK;\n            }\n\n            tex._batchEnabled = TICK;\n            tex.touched = touch;\n            texArray.elements[texArray.count++] = tex;\n        }\n\n        if (texArray.count > 0)\n        {\n            batch.boundArray(texArray, boundTextures, TICK, maxTextures);\n            this.buildDrawCalls(texArray, start, this._bufferSize);\n            ++countTexArrays;\n            ++TICK;\n        }\n\n        // Clean-up\n\n        for (let i = 0; i < boundTextures.length; i++)\n        {\n            boundTextures[i] = null;\n        }\n        BaseTexture._globalBatch = TICK;\n    }\n\n    /**\n     * Populating drawcalls for rendering\n     * @param texArray\n     * @param start\n     * @param finish\n     */\n    buildDrawCalls(texArray: BatchTextureArray, start: number, finish: number): void\n    {\n        const {\n            _bufferedElements: elements,\n            _attributeBuffer,\n            _indexBuffer,\n            vertexSize,\n        } = this;\n        const drawCalls = BatchRenderer._drawCallPool;\n\n        let dcIndex = this._dcIndex;\n        let aIndex = this._aIndex;\n        let iIndex = this._iIndex;\n\n        let drawCall = drawCalls[dcIndex];\n\n        drawCall.start = this._iIndex;\n        drawCall.texArray = texArray;\n\n        for (let i = start; i < finish; ++i)\n        {\n            const sprite = elements[i];\n            const tex = sprite._texture.baseTexture;\n            const spriteBlendMode = premultiplyBlendMode[\n                tex.alphaMode ? 1 : 0][sprite.blendMode];\n\n            elements[i] = null;\n\n            if (start < i && drawCall.blend !== spriteBlendMode)\n            {\n                drawCall.size = iIndex - drawCall.start;\n                start = i;\n                drawCall = drawCalls[++dcIndex];\n                drawCall.texArray = texArray;\n                drawCall.start = iIndex;\n            }\n\n            this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);\n            aIndex += sprite.vertexData.length / 2 * vertexSize;\n            iIndex += sprite.indices.length;\n\n            drawCall.blend = spriteBlendMode;\n        }\n\n        if (start < finish)\n        {\n            drawCall.size = iIndex - drawCall.start;\n            ++dcIndex;\n        }\n\n        this._dcIndex = dcIndex;\n        this._aIndex = aIndex;\n        this._iIndex = iIndex;\n    }\n\n    /**\n     * Bind textures for current rendering\n     * @param texArray\n     */\n    bindAndClearTexArray(texArray: BatchTextureArray): void\n    {\n        const textureSystem = this.renderer.texture;\n\n        for (let j = 0; j < texArray.count; j++)\n        {\n            textureSystem.bind(texArray.elements[j], texArray.ids[j]);\n            texArray.elements[j] = null;\n        }\n        texArray.count = 0;\n    }\n\n    updateGeometry(): void\n    {\n        const {\n            _packedGeometries: packedGeometries,\n            _attributeBuffer: attributeBuffer,\n            _indexBuffer: indexBuffer,\n        } = this;\n\n        if (!BatchRenderer.canUploadSameBuffer)\n        { /* Usually on iOS devices, where the browser doesn't\n            like uploads to the same buffer in a single frame. */\n            if (this._packedGeometryPoolSize <= this._flushId)\n            {\n                this._packedGeometryPoolSize++;\n                packedGeometries[this._flushId] = new (this.geometryClass)();\n            }\n\n            packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);\n            packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);\n\n            this.renderer.geometry.bind(packedGeometries[this._flushId]);\n            this.renderer.geometry.updateBuffers();\n            this._flushId++;\n        }\n        else\n        {\n            // lets use the faster option, always use buffer number 0\n            packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);\n            packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);\n\n            this.renderer.geometry.updateBuffers();\n        }\n    }\n\n    drawBatches(): void\n    {\n        const dcCount = this._dcIndex;\n        const { gl, state: stateSystem } = this.renderer;\n        const drawCalls = BatchRenderer._drawCallPool;\n\n        let curTexArray = null;\n\n        // Upload textures and do the draw calls\n        for (let i = 0; i < dcCount; i++)\n        {\n            const { texArray, type, size, start, blend } = drawCalls[i];\n\n            if (curTexArray !== texArray)\n            {\n                curTexArray = texArray;\n                this.bindAndClearTexArray(texArray);\n            }\n\n            this.state.blendMode = blend;\n            stateSystem.set(this.state);\n            gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);\n        }\n    }\n\n    /** Renders the content _now_ and empties the current batch. */\n    flush(): void\n    {\n        if (this._vertexCount === 0)\n        {\n            return;\n        }\n\n        this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);\n        this._indexBuffer = this.getIndexBuffer(this._indexCount);\n        this._aIndex = 0;\n        this._iIndex = 0;\n        this._dcIndex = 0;\n\n        this.buildTexturesAndDrawCalls();\n        this.updateGeometry();\n        this.drawBatches();\n\n        // reset elements buffer for the next flush\n        this._bufferSize = 0;\n        this._vertexCount = 0;\n        this._indexCount = 0;\n    }\n\n    /** Starts a new sprite batch. */\n    start(): void\n    {\n        this.renderer.state.set(this.state);\n\n        this.renderer.texture.ensureSamplerType(this.maxTextures);\n\n        this.renderer.shader.bind(this._shader);\n\n        if (BatchRenderer.canUploadSameBuffer)\n        {\n            // bind buffer #0, we don't need others\n            this.renderer.geometry.bind(this._packedGeometries[this._flushId]);\n        }\n    }\n\n    /** Stops and flushes the current batch. */\n    stop(): void\n    {\n        this.flush();\n    }\n\n    /** Destroys this `BatchRenderer`. It cannot be used again. */\n    destroy(): void\n    {\n        for (let i = 0; i < this._packedGeometryPoolSize; i++)\n        {\n            if (this._packedGeometries[i])\n            {\n                this._packedGeometries[i].destroy();\n            }\n        }\n\n        this.renderer.off('prerender', this.onPrerender, this);\n\n        this._aBuffers = null;\n        this._iBuffers = null;\n        this._packedGeometries = null;\n        this._attributeBuffer = null;\n        this._indexBuffer = null;\n\n        if (this._shader)\n        {\n            this._shader.destroy();\n            this._shader = null;\n        }\n\n        super.destroy();\n    }\n\n    /**\n     * Fetches an attribute buffer from `this._aBuffers` that can hold atleast `size` floats.\n     * @param size - minimum capacity required\n     * @returns - buffer than can hold atleast `size` floats\n     */\n    getAttributeBuffer(size: number): ViewableBuffer\n    {\n        // 8 vertices is enough for 2 quads\n        const roundedP2 = nextPow2(Math.ceil(size / 8));\n        const roundedSizeIndex = log2(roundedP2);\n        const roundedSize = roundedP2 * 8;\n\n        if (this._aBuffers.length <= roundedSizeIndex)\n        {\n            this._iBuffers.length = roundedSizeIndex + 1;\n        }\n\n        let buffer = this._aBuffers[roundedSize];\n\n        if (!buffer)\n        {\n            this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);\n        }\n\n        return buffer;\n    }\n\n    /**\n     * Fetches an index buffer from `this._iBuffers` that can\n     * have at least `size` capacity.\n     * @param size - minimum required capacity\n     * @returns - buffer that can fit `size` indices.\n     */\n    getIndexBuffer(size: number): Uint16Array\n    {\n        // 12 indices is enough for 2 quads\n        const roundedP2 = nextPow2(Math.ceil(size / 12));\n        const roundedSizeIndex = log2(roundedP2);\n        const roundedSize = roundedP2 * 12;\n\n        if (this._iBuffers.length <= roundedSizeIndex)\n        {\n            this._iBuffers.length = roundedSizeIndex + 1;\n        }\n\n        let buffer = this._iBuffers[roundedSizeIndex];\n\n        if (!buffer)\n        {\n            this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);\n        }\n\n        return buffer;\n    }\n\n    /**\n     * Takes the four batching parameters of `element`, interleaves\n     * and pushes them into the batching attribute/index buffers given.\n     *\n     * It uses these properties: `vertexData` `uvs`, `textureId` and\n     * `indicies`. It also uses the \"tint\" of the base-texture, if\n     * present.\n     * @param {PIXI.DisplayObject} element - element being rendered\n     * @param attributeBuffer - attribute buffer.\n     * @param indexBuffer - index buffer\n     * @param aIndex - number of floats already in the attribute buffer\n     * @param iIndex - number of indices already in `indexBuffer`\n     */\n    packInterleavedGeometry(element: IBatchableElement, attributeBuffer: ViewableBuffer, indexBuffer: Uint16Array,\n        aIndex: number, iIndex: number): void\n    {\n        const {\n            uint32View,\n            float32View,\n        } = attributeBuffer;\n\n        const packedVertices = aIndex / this.vertexSize;\n        const uvs = element.uvs;\n        const indicies = element.indices;\n        const vertexData = element.vertexData;\n        const textureId = element._texture.baseTexture._batchLocation;\n\n        const alpha = Math.min(element.worldAlpha, 1.0);\n        const argb = (alpha < 1.0\n            && element._texture.baseTexture.alphaMode)\n            ? premultiplyTint(element._tintRGB, alpha)\n            : element._tintRGB + (alpha * 255 << 24);\n\n        // lets not worry about tint! for now..\n        for (let i = 0; i < vertexData.length; i += 2)\n        {\n            float32View[aIndex++] = vertexData[i];\n            float32View[aIndex++] = vertexData[i + 1];\n            float32View[aIndex++] = uvs[i];\n            float32View[aIndex++] = uvs[i + 1];\n            uint32View[aIndex++] = argb;\n            float32View[aIndex++] = textureId;\n        }\n\n        for (let i = 0; i < indicies.length; i++)\n        {\n            indexBuffer[iIndex++] = packedVertices + indicies[i];\n        }\n    }\n\n    /**\n     * Pool of `BatchDrawCall` objects that `flush` used\n     * to create \"batches\" of the objects being rendered.\n     *\n     * These are never re-allocated again.\n     * Shared between all batch renderers because it can be only one \"flush\" working at the moment.\n     * @member {PIXI.BatchDrawCall[]}\n     */\n    static _drawCallPool: Array<BatchDrawCall> = [];\n\n    /**\n     * Pool of `BatchDrawCall` objects that `flush` used\n     * to create \"batches\" of the objects being rendered.\n     *\n     * These are never re-allocated again.\n     * Shared between all batch renderers because it can be only one \"flush\" working at the moment.\n     * @member {PIXI.BatchTextureArray[]}\n     */\n    static _textureArrayPool: Array<BatchTextureArray> = [];\n}\n\n// Install BatchRenderer as default\nextensions.add(BatchRenderer);\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}