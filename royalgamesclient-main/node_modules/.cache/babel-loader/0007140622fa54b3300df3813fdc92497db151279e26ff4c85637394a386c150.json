{"ast":null,"code":"import { BaseTexture } from '../BaseTexture.mjs';\nimport { autoDetectResource } from './autoDetectResource.mjs';\nimport { Resource } from './Resource.mjs';\nclass AbstractMultiResource extends Resource {\n  constructor(length, options) {\n    const {\n      width,\n      height\n    } = options || {};\n    super(width, height);\n    this.items = [];\n    this.itemDirtyIds = [];\n    for (let i = 0; i < length; i++) {\n      const partTexture = new BaseTexture();\n      this.items.push(partTexture);\n      this.itemDirtyIds.push(-2);\n    }\n    this.length = length;\n    this._load = null;\n    this.baseTexture = null;\n  }\n  initFromArray(resources, options) {\n    for (let i = 0; i < this.length; i++) {\n      if (!resources[i]) {\n        continue;\n      }\n      if (resources[i].castToBaseTexture) {\n        this.addBaseTextureAt(resources[i].castToBaseTexture(), i);\n      } else if (resources[i] instanceof Resource) {\n        this.addResourceAt(resources[i], i);\n      } else {\n        this.addResourceAt(autoDetectResource(resources[i], options), i);\n      }\n    }\n  }\n  dispose() {\n    for (let i = 0, len = this.length; i < len; i++) {\n      this.items[i].destroy();\n    }\n    this.items = null;\n    this.itemDirtyIds = null;\n    this._load = null;\n  }\n  addResourceAt(resource, index) {\n    if (!this.items[index]) {\n      throw new Error(\"Index \".concat(index, \" is out of bounds\"));\n    }\n    if (resource.valid && !this.valid) {\n      this.resize(resource.width, resource.height);\n    }\n    this.items[index].setResource(resource);\n    return this;\n  }\n  bind(baseTexture) {\n    if (this.baseTexture !== null) {\n      throw new Error(\"Only one base texture per TextureArray is allowed\");\n    }\n    super.bind(baseTexture);\n    for (let i = 0; i < this.length; i++) {\n      this.items[i].parentTextureArray = baseTexture;\n      this.items[i].on(\"update\", baseTexture.update, baseTexture);\n    }\n  }\n  unbind(baseTexture) {\n    super.unbind(baseTexture);\n    for (let i = 0; i < this.length; i++) {\n      this.items[i].parentTextureArray = null;\n      this.items[i].off(\"update\", baseTexture.update, baseTexture);\n    }\n  }\n  load() {\n    if (this._load) {\n      return this._load;\n    }\n    const resources = this.items.map(item => item.resource).filter(item => item);\n    const promises = resources.map(item => item.load());\n    this._load = Promise.all(promises).then(() => {\n      const {\n        realWidth,\n        realHeight\n      } = this.items[0];\n      this.resize(realWidth, realHeight);\n      return Promise.resolve(this);\n    });\n    return this._load;\n  }\n}\nexport { AbstractMultiResource };","map":{"version":3,"mappings":";;;AAaO,MAAeA,8BAA8BC,QACpD;EA+BIC,YAAYC,QAAgBC,OAC5B;IACI,MAAM;MAAEC;MAAOC;IAAW,eAAW,EAAC;IAEtC,MAAMD,OAAOC,MAAM;IAEnB,KAAKC,QAAQ,EAAC;IACd,KAAKC,eAAe,EAAC;IAErB,SAASC,CAAI,MAAGA,CAAI,WAAQA,CAC5B;MACU,oBAAc,IAAIC,WAAY;MAE/B,WAAMC,KAAKC,WAAW;MAItB,kBAAaD,KAAK,CAAE;IAAA;IAG7B,KAAKR,MAAS;IACd,KAAKU,KAAQ;IACb,KAAKC,WAAc;EAAA;EASbC,aAAcA,YAAuBX,OAC/C;IACI,SAASK,CAAI,MAAGA,CAAI,QAAKN,QAAQM,CACjC;MACQ,KAACO,UAAUP,CACf;QACI;MAAA;MAEA,cAAUA,GAAGQ,iBACjB;QACI,KAAKC,gBAAiB,WAAUT,CAAG,uBAAqBA,CAAC;MAAA,CAC7D,UACSO,SAAU,eAAcf,QACjC;QACS,mBAAce,SAAU,KAAIP,CAAC;MAAA,CAGtC;QACI,KAAKU,cAAcC,kBAAmB,WAAUX,CAAI,UAAO,GAAGA,CAAC;MAAA;IACnE;EACJ;EAIJY,OACAA;IACI,SAASZ,IAAI,CAAG,QAAM,KAAKN,MAAQ,MAAImB,KAAKb,CAC5C;MACS,WAAMA,GAAGc,OAAQ;IAAA;IAE1B,KAAKhB,KAAQ;IACb,KAAKC,YAAe;IACpB,KAAKK,KAAQ;EAAA;EAiBjBM,cAAcK,UAAoBC,KAClC;IACQ,KAAC,IAAK,OAAMA,KAChB;MACU,UAAIC,KAAM,iBAASD,KAAwB;IAAA;IAIrD,IAAID,QAAS,UAAS,CAAC,KAAKG,KAC5B;MACI,KAAKC,MAAO,UAASvB,KAAO,WAASC,MAAM;IAAA;IAG1C,WAAMmB,KAAO,cAAYD,QAAQ;IAE/B;EAAA;EAOXK,KAAKf,WACL;IACQ,SAAKA,gBAAgB,IACzB;MACU,UAAIY,MAAM,mDAAmD;IAAA;IAEvE,MAAMG,KAAKf,WAAW;IAEtB,SAASL,CAAI,MAAGA,CAAI,QAAKN,QAAQM,CACjC;MACS,WAAMA,GAAGqB,kBAAqB;MACnC,KAAKvB,MAAME,CAAG,KAAG,QAAU,cAAYsB,QAAQjB,WAAW;IAAA;EAC9D;EAOJkB,OAAOlB,WACP;IACI,MAAMkB,OAAOlB,WAAW;IAExB,SAASL,CAAI,MAAGA,CAAI,QAAKN,QAAQM,CACjC;MACS,WAAMA,GAAGqB,kBAAqB;MACnC,KAAKvB,MAAME,CAAG,MAAI,QAAU,cAAYsB,QAAQjB,WAAW;IAAA;EAC/D;EAOJmB,IACAA;IACI,IAAI,KAAKpB,KACT;MACI,OAAO,IAAK;IAAA;IAGhB,MAAMG,SAAY,QAAKT,KAAM,KAAK2B,QAASA,IAAK,SAAQ,CAAE,QAAQA,QAASA,IAAI;IAG/E,MAAMC,WAAWnB,SAAU,KAAKkB,IAAS,SAAKD,MAAM;IAEpD,KAAKpB,QAAQuB,OAAQ,KAAID,QAAQ,EAC5BE,KAAK,MACN;MACI,MAAM;QAAEC;QAAWC;MAAe,SAAKhC,KAAM;MAExC,YAAO+B,WAAWC,UAAU;MAE1B,eAAQC,QAAQ,IAAI;IAAA,CAE/B;IAEJ,OAAO,IAAK;EAAA;AAEpB","names":["AbstractMultiResource","Resource","constructor","length","options","width","height","items","itemDirtyIds","i","BaseTexture","push","partTexture","_load","baseTexture","initFromArray","resources","castToBaseTexture","addBaseTextureAt","addResourceAt","autoDetectResource","dispose","len","destroy","resource","index","Error","valid","resize","bind","parentTextureArray","update","unbind","load","item","promises","Promise","then","realWidth","realHeight","resolve"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/core/src/textures/resources/AbstractMultiResource.ts"],"sourcesContent":["import { BaseTexture } from '../BaseTexture';\nimport { autoDetectResource } from './autoDetectResource';\nimport { Resource } from './Resource';\n\nimport type { ISize } from '@pixi/math';\nimport type { IAutoDetectOptions } from './autoDetectResource';\n\n/**\n * Resource that can manage several resource (items) inside.\n * All resources need to have the same pixel size.\n * Parent class for CubeResource and ArrayResource\n * @memberof PIXI\n */\nexport abstract class AbstractMultiResource extends Resource\n{\n    /** Number of elements in array. */\n    readonly length: number;\n\n    /**\n     * Collection of partial baseTextures that correspond to resources.\n     * @readonly\n     */\n    items: Array<BaseTexture>;\n\n    /**\n     * Dirty IDs for each part.\n     * @readonly\n     */\n    itemDirtyIds: Array<number>;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<this>;\n\n    /** Bound baseTexture, there can only be one. */\n    baseTexture: BaseTexture;\n\n    /**\n     * @param length\n     * @param options - Options to for Resource constructor\n     * @param {number} [options.width] - Width of the resource\n     * @param {number} [options.height] - Height of the resource\n     */\n    constructor(length: number, options?: ISize)\n    {\n        const { width, height } = options || {};\n\n        super(width, height);\n\n        this.items = [];\n        this.itemDirtyIds = [];\n\n        for (let i = 0; i < length; i++)\n        {\n            const partTexture = new BaseTexture();\n\n            this.items.push(partTexture);\n            // -2 - first run of texture array upload\n            // -1 - texture item was allocated\n            // >=0 - texture item uploaded , in sync with items[i].dirtyId\n            this.itemDirtyIds.push(-2);\n        }\n\n        this.length = length;\n        this._load = null;\n        this.baseTexture = null;\n    }\n\n    /**\n     * Used from ArrayResource and CubeResource constructors.\n     * @param resources - Can be resources, image elements, canvas, etc. ,\n     *  length should be same as constructor length\n     * @param options - Detect options for resources\n     */\n    protected initFromArray(resources: Array<any>, options?: IAutoDetectOptions): void\n    {\n        for (let i = 0; i < this.length; i++)\n        {\n            if (!resources[i])\n            {\n                continue;\n            }\n            if (resources[i].castToBaseTexture)\n            {\n                this.addBaseTextureAt(resources[i].castToBaseTexture(), i);\n            }\n            else if (resources[i] instanceof Resource)\n            {\n                this.addResourceAt(resources[i], i);\n            }\n            else\n            {\n                this.addResourceAt(autoDetectResource(resources[i], options), i);\n            }\n        }\n    }\n\n    /** Destroy this BaseImageResource. */\n    dispose(): void\n    {\n        for (let i = 0, len = this.length; i < len; i++)\n        {\n            this.items[i].destroy();\n        }\n        this.items = null;\n        this.itemDirtyIds = null;\n        this._load = null;\n    }\n\n    /**\n     * Set a baseTexture by ID\n     * @param baseTexture\n     * @param index - Zero-based index of resource to set\n     * @returns - Instance for chaining\n     */\n    abstract addBaseTextureAt(baseTexture: BaseTexture, index: number): this;\n\n    /**\n     * Set a resource by ID\n     * @param resource\n     * @param index - Zero-based index of resource to set\n     * @returns - Instance for chaining\n     */\n    addResourceAt(resource: Resource, index: number): this\n    {\n        if (!this.items[index])\n        {\n            throw new Error(`Index ${index} is out of bounds`);\n        }\n\n        // Inherit the first resource dimensions\n        if (resource.valid && !this.valid)\n        {\n            this.resize(resource.width, resource.height);\n        }\n\n        this.items[index].setResource(resource);\n\n        return this;\n    }\n\n    /**\n     * Set the parent base texture.\n     * @param baseTexture\n     */\n    bind(baseTexture: BaseTexture): void\n    {\n        if (this.baseTexture !== null)\n        {\n            throw new Error('Only one base texture per TextureArray is allowed');\n        }\n        super.bind(baseTexture);\n\n        for (let i = 0; i < this.length; i++)\n        {\n            this.items[i].parentTextureArray = baseTexture;\n            this.items[i].on('update', baseTexture.update, baseTexture);\n        }\n    }\n\n    /**\n     * Unset the parent base texture.\n     * @param baseTexture\n     */\n    unbind(baseTexture: BaseTexture): void\n    {\n        super.unbind(baseTexture);\n\n        for (let i = 0; i < this.length; i++)\n        {\n            this.items[i].parentTextureArray = null;\n            this.items[i].off('update', baseTexture.update, baseTexture);\n        }\n    }\n\n    /**\n     * Load all the resources simultaneously\n     * @returns - When load is resolved\n     */\n    load(): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        const resources = this.items.map((item) => item.resource).filter((item) => item);\n\n        // TODO: also implement load part-by-part strategy\n        const promises = resources.map((item) => item.load());\n\n        this._load = Promise.all(promises)\n            .then(() =>\n            {\n                const { realWidth, realHeight } = this.items[0];\n\n                this.resize(realWidth, realHeight);\n\n                return Promise.resolve(this);\n            }\n            );\n\n        return this._load;\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}