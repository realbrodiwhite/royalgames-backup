{"ast":null,"code":"import { SAMPLER_TYPES, TYPES, MIPMAP_MODES, WRAP_MODES, SCALE_MODES } from '@pixi/constants';\nimport { ExtensionType, extensions } from '@pixi/extensions';\nimport { removeItems } from '@pixi/utils';\nimport { BaseTexture } from './BaseTexture.mjs';\nimport { GLTexture } from './GLTexture.mjs';\nimport { mapTypeAndFormatToInternalFormat } from './utils/mapTypeAndFormatToInternalFormat.mjs';\nclass TextureSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.boundTextures = [];\n    this.currentLocation = -1;\n    this.managedTextures = [];\n    this._unknownBoundTextures = false;\n    this.unknownTexture = new BaseTexture();\n    this.hasIntegerTextures = false;\n  }\n  contextChange() {\n    const gl = this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n    this.webGLVersion = this.renderer.context.webGLVersion;\n    this.internalFormats = mapTypeAndFormatToInternalFormat(gl);\n    const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    this.boundTextures.length = maxTextures;\n    for (let i = 0; i < maxTextures; i++) {\n      this.boundTextures[i] = null;\n    }\n    this.emptyTextures = {};\n    const emptyTexture2D = new GLTexture(gl.createTexture());\n    gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));\n    this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;\n    this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());\n    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);\n    for (let i = 0; i < 6; i++) {\n      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    }\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    for (let i = 0; i < this.boundTextures.length; i++) {\n      this.bind(null, i);\n    }\n  }\n  bind(texture) {\n    var _texture, _texture2;\n    let location = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const {\n      gl\n    } = this;\n    texture = (_texture = texture) === null || _texture === void 0 ? void 0 : _texture.castToBaseTexture();\n    if ((_texture2 = texture) !== null && _texture2 !== void 0 && _texture2.valid && !texture.parentTextureArray) {\n      texture.touched = this.renderer.textureGC.count;\n      const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);\n      if (this.boundTextures[location] !== texture) {\n        if (this.currentLocation !== location) {\n          this.currentLocation = location;\n          gl.activeTexture(gl.TEXTURE0 + location);\n        }\n        gl.bindTexture(texture.target, glTexture.texture);\n      }\n      if (glTexture.dirtyId !== texture.dirtyId) {\n        if (this.currentLocation !== location) {\n          this.currentLocation = location;\n          gl.activeTexture(gl.TEXTURE0 + location);\n        }\n        this.updateTexture(texture);\n      } else if (glTexture.dirtyStyleId !== texture.dirtyStyleId) {\n        this.updateTextureStyle(texture);\n      }\n      this.boundTextures[location] = texture;\n    } else {\n      if (this.currentLocation !== location) {\n        this.currentLocation = location;\n        gl.activeTexture(gl.TEXTURE0 + location);\n      }\n      gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);\n      this.boundTextures[location] = null;\n    }\n  }\n  reset() {\n    this._unknownBoundTextures = true;\n    this.hasIntegerTextures = false;\n    this.currentLocation = -1;\n    for (let i = 0; i < this.boundTextures.length; i++) {\n      this.boundTextures[i] = this.unknownTexture;\n    }\n  }\n  unbind(texture) {\n    const {\n      gl,\n      boundTextures\n    } = this;\n    if (this._unknownBoundTextures) {\n      this._unknownBoundTextures = false;\n      for (let i = 0; i < boundTextures.length; i++) {\n        if (boundTextures[i] === this.unknownTexture) {\n          this.bind(null, i);\n        }\n      }\n    }\n    for (let i = 0; i < boundTextures.length; i++) {\n      if (boundTextures[i] === texture) {\n        if (this.currentLocation !== i) {\n          gl.activeTexture(gl.TEXTURE0 + i);\n          this.currentLocation = i;\n        }\n        gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);\n        boundTextures[i] = null;\n      }\n    }\n  }\n  ensureSamplerType(maxTextures) {\n    const {\n      boundTextures,\n      hasIntegerTextures,\n      CONTEXT_UID\n    } = this;\n    if (!hasIntegerTextures) {\n      return;\n    }\n    for (let i = maxTextures - 1; i >= 0; --i) {\n      const tex = boundTextures[i];\n      if (tex) {\n        const glTexture = tex._glTextures[CONTEXT_UID];\n        if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {\n          this.renderer.texture.unbind(tex);\n        }\n      }\n    }\n  }\n  initTexture(texture) {\n    const glTexture = new GLTexture(this.gl.createTexture());\n    glTexture.dirtyId = -1;\n    texture._glTextures[this.CONTEXT_UID] = glTexture;\n    this.managedTextures.push(texture);\n    texture.on(\"dispose\", this.destroyTexture, this);\n    return glTexture;\n  }\n  initTextureType(texture, glTexture) {\n    var _this$internalFormats, _this$internalFormats2;\n    glTexture.internalFormat = (_this$internalFormats = (_this$internalFormats2 = this.internalFormats[texture.type]) === null || _this$internalFormats2 === void 0 ? void 0 : _this$internalFormats2[texture.format]) !== null && _this$internalFormats !== void 0 ? _this$internalFormats : texture.format;\n    if (this.webGLVersion === 2 && texture.type === TYPES.HALF_FLOAT) {\n      glTexture.type = this.gl.HALF_FLOAT;\n    } else {\n      glTexture.type = texture.type;\n    }\n  }\n  updateTexture(texture) {\n    var _texture$resource;\n    const glTexture = texture._glTextures[this.CONTEXT_UID];\n    if (!glTexture) {\n      return;\n    }\n    const renderer = this.renderer;\n    this.initTextureType(texture, glTexture);\n    if ((_texture$resource = texture.resource) !== null && _texture$resource !== void 0 && _texture$resource.upload(renderer, texture, glTexture)) {\n      if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {\n        this.hasIntegerTextures = true;\n      }\n    } else {\n      const width = texture.realWidth;\n      const height = texture.realHeight;\n      const gl = renderer.gl;\n      if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {\n        glTexture.width = width;\n        glTexture.height = height;\n        gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);\n      }\n    }\n    if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {\n      this.updateTextureStyle(texture);\n    }\n    glTexture.dirtyId = texture.dirtyId;\n  }\n  destroyTexture(texture, skipRemove) {\n    const {\n      gl\n    } = this;\n    texture = texture.castToBaseTexture();\n    if (texture._glTextures[this.CONTEXT_UID]) {\n      this.unbind(texture);\n      gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);\n      texture.off(\"dispose\", this.destroyTexture, this);\n      delete texture._glTextures[this.CONTEXT_UID];\n      if (!skipRemove) {\n        const i = this.managedTextures.indexOf(texture);\n        if (i !== -1) {\n          removeItems(this.managedTextures, i, 1);\n        }\n      }\n    }\n  }\n  updateTextureStyle(texture) {\n    var _texture$resource2;\n    const glTexture = texture._glTextures[this.CONTEXT_UID];\n    if (!glTexture) {\n      return;\n    }\n    if ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {\n      glTexture.mipmap = false;\n    } else {\n      glTexture.mipmap = texture.mipmap >= 1;\n    }\n    if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {\n      glTexture.wrapMode = WRAP_MODES.CLAMP;\n    } else {\n      glTexture.wrapMode = texture.wrapMode;\n    }\n    if ((_texture$resource2 = texture.resource) !== null && _texture$resource2 !== void 0 && _texture$resource2.style(this.renderer, texture, glTexture)) {} else {\n      this.setStyle(texture, glTexture);\n    }\n    glTexture.dirtyStyleId = texture.dirtyStyleId;\n  }\n  setStyle(texture, glTexture) {\n    const gl = this.gl;\n    if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES.ON_MANUAL) {\n      gl.generateMipmap(texture.target);\n    }\n    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);\n    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);\n    if (glTexture.mipmap) {\n      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);\n      const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;\n      if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR) {\n        const level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n        gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n      }\n    } else {\n      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n    }\n    gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nTextureSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"texture\"\n};\nextensions.add(TextureSystem);\nexport { TextureSystem };","map":{"version":3,"mappings":"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","names":["TextureSystem","constructor","renderer","boundTextures","currentLocation","managedTextures","_unknownBoundTextures","BaseTexture","hasIntegerTextures","contextChange","gl","context","mapTypeAndFormatToInternalFormat","maxTextures","getParameter","MAX_TEXTURE_IMAGE_UNITS","length","i","emptyTextures","emptyTexture2D","GLTexture","createTexture","bindTexture","TEXTURE_2D","texture","texImage2D","RGBA","Uint8Array","TEXTURE_CUBE_MAP","TEXTURE_CUBE_MAP_POSITIVE_X","UNSIGNED_BYTE","texParameteri","LINEAR","bind","location","castToBaseTexture","_texture2","valid","parentTextureArray","textureGC","glTexture","CONTEXT_UID","initTexture","target","dirtyId","updateTexture","dirtyStyleId","updateTextureStyle","reset","unbind","unknownTexture","ensureSamplerType","tex","_glTextures","samplerType","FLOAT","push","on","initTextureType","internalFormat","type","_this$internalFormats2","format","webGLVersion","TYPES","HALF_FLOAT","resource","_texture$resource","upload","width","height","destroyTexture","skipRemove","deleteTexture","off","removeItems","mipmap","MIPMAP_MODES","isPowerOfTwo","wrapMode","WRAP_MODES","_texture$resource2","style","setStyle","ON_MANUAL","TEXTURE_MIN_FILTER","scaleMode","LINEAR_MIPMAP_LINEAR","NEAREST_MIPMAP_NEAREST","anisotropicExt","extensions","SCALE_MODES","Math","min","anisotropicLevel","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","level","NEAREST","TEXTURE_MAG_FILTER","destroy","extension","ExtensionType","name","add"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/core/src/textures/TextureSystem.ts"],"sourcesContent":["import { MIPMAP_MODES, SAMPLER_TYPES, SCALE_MODES, TYPES, WRAP_MODES } from '@pixi/constants';\nimport { extensions, ExtensionType } from '@pixi/extensions';\nimport { removeItems } from '@pixi/utils';\nimport { BaseTexture } from './BaseTexture';\nimport { GLTexture } from './GLTexture';\nimport { mapTypeAndFormatToInternalFormat } from './utils/mapTypeAndFormatToInternalFormat';\n\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { IRenderingContext } from '../IRenderer';\nimport type { Renderer } from '../Renderer';\nimport type { ISystem } from '../system/ISystem';\nimport type { Texture } from './Texture';\n\n/**\n * System plugin to the renderer to manage textures.\n * @memberof PIXI\n */\nexport class TextureSystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'texture',\n    };\n\n    /**\n     * Bound textures.\n     * @readonly\n     */\n    public boundTextures: BaseTexture[];\n\n    /**\n     * List of managed textures.\n     * @readonly\n     */\n    public managedTextures: Array<BaseTexture>;\n\n    /** Whether glTexture with int/uint sampler type was uploaded. */\n    protected hasIntegerTextures: boolean;\n    protected CONTEXT_UID: number;\n    protected gl: IRenderingContext;\n    protected internalFormats: { [type: number]: { [format: number]: number } };\n    protected webGLVersion: number;\n\n    /**\n     * BaseTexture value that shows that we don't know what is bound.\n     * @readonly\n     */\n    protected unknownTexture: BaseTexture;\n\n    /**\n     * Did someone temper with textures state? We'll overwrite them when we need to unbind something.\n     * @private\n     */\n    protected _unknownBoundTextures: boolean;\n\n    /**\n     * Current location.\n     * @readonly\n     */\n    currentLocation: number;\n    emptyTextures: {[key: number]: GLTexture};\n    private renderer: Renderer;\n\n    /**\n     * @param renderer - The renderer this system works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n\n        // TODO set to max textures...\n        this.boundTextures = [];\n        this.currentLocation = -1;\n        this.managedTextures = [];\n\n        this._unknownBoundTextures = false;\n        this.unknownTexture = new BaseTexture();\n\n        this.hasIntegerTextures = false;\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    contextChange(): void\n    {\n        const gl = this.gl = this.renderer.gl;\n\n        this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n\n        this.webGLVersion = this.renderer.context.webGLVersion;\n\n        this.internalFormats = mapTypeAndFormatToInternalFormat(gl);\n\n        const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n        this.boundTextures.length = maxTextures;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            this.boundTextures[i] = null;\n        }\n\n        // TODO move this.. to a nice make empty textures class..\n        this.emptyTextures = {};\n\n        const emptyTexture2D = new GLTexture(gl.createTexture());\n\n        gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));\n\n        this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;\n        this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());\n\n        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);\n\n        for (let i = 0; i < 6; i++)\n        {\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        }\n\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\n        for (let i = 0; i < this.boundTextures.length; i++)\n        {\n            this.bind(null, i);\n        }\n    }\n\n    /**\n     * Bind a texture to a specific location\n     *\n     * If you want to unbind something, please use `unbind(texture)` instead of `bind(null, textureLocation)`\n     * @param texture - Texture to bind\n     * @param [location=0] - Location to bind at\n     */\n    bind(texture: Texture | BaseTexture, location = 0): void\n    {\n        const { gl } = this;\n\n        texture = texture?.castToBaseTexture();\n\n        // cannot bind partial texture\n        // TODO: report a warning\n        if (texture?.valid && !texture.parentTextureArray)\n        {\n            texture.touched = this.renderer.textureGC.count;\n\n            const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);\n\n            if (this.boundTextures[location] !== texture)\n            {\n                if (this.currentLocation !== location)\n                {\n                    this.currentLocation = location;\n                    gl.activeTexture(gl.TEXTURE0 + location);\n                }\n\n                gl.bindTexture(texture.target, glTexture.texture);\n            }\n\n            if (glTexture.dirtyId !== texture.dirtyId)\n            {\n                if (this.currentLocation !== location)\n                {\n                    this.currentLocation = location;\n                    gl.activeTexture(gl.TEXTURE0 + location);\n                }\n                this.updateTexture(texture);\n            }\n            else if (glTexture.dirtyStyleId !== texture.dirtyStyleId)\n            {\n                this.updateTextureStyle(texture);\n            }\n\n            this.boundTextures[location] = texture;\n        }\n        else\n        {\n            if (this.currentLocation !== location)\n            {\n                this.currentLocation = location;\n                gl.activeTexture(gl.TEXTURE0 + location);\n            }\n\n            gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);\n            this.boundTextures[location] = null;\n        }\n    }\n\n    /** Resets texture location and bound textures Actual `bind(null, i)` calls will be performed at next `unbind()` call */\n    reset(): void\n    {\n        this._unknownBoundTextures = true;\n        this.hasIntegerTextures = false;\n        this.currentLocation = -1;\n\n        for (let i = 0; i < this.boundTextures.length; i++)\n        {\n            this.boundTextures[i] = this.unknownTexture;\n        }\n    }\n\n    /**\n     * Unbind a texture.\n     * @param texture - Texture to bind\n     */\n    unbind(texture?: BaseTexture): void\n    {\n        const { gl, boundTextures } = this;\n\n        if (this._unknownBoundTextures)\n        {\n            this._unknownBoundTextures = false;\n            // someone changed webGL state,\n            // we have to be sure that our texture does not appear in multi-texture renderer samplers\n            for (let i = 0; i < boundTextures.length; i++)\n            {\n                if (boundTextures[i] === this.unknownTexture)\n                {\n                    this.bind(null, i);\n                }\n            }\n        }\n\n        for (let i = 0; i < boundTextures.length; i++)\n        {\n            if (boundTextures[i] === texture)\n            {\n                if (this.currentLocation !== i)\n                {\n                    gl.activeTexture(gl.TEXTURE0 + i);\n                    this.currentLocation = i;\n                }\n\n                gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);\n                boundTextures[i] = null;\n            }\n        }\n    }\n\n    /**\n     * Ensures that current boundTextures all have FLOAT sampler type,\n     * see {@link PIXI.SAMPLER_TYPES} for explanation.\n     * @param maxTextures - number of locations to check\n     */\n    ensureSamplerType(maxTextures: number): void\n    {\n        const { boundTextures, hasIntegerTextures, CONTEXT_UID } = this;\n\n        if (!hasIntegerTextures)\n        {\n            return;\n        }\n\n        for (let i = maxTextures - 1; i >= 0; --i)\n        {\n            const tex = boundTextures[i];\n\n            if (tex)\n            {\n                const glTexture = tex._glTextures[CONTEXT_UID];\n\n                if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT)\n                {\n                    this.renderer.texture.unbind(tex);\n                }\n            }\n        }\n    }\n\n    /**\n     * Initialize a texture\n     * @private\n     * @param texture - Texture to initialize\n     */\n    initTexture(texture: BaseTexture): GLTexture\n    {\n        const glTexture = new GLTexture(this.gl.createTexture());\n\n        // guarantee an update..\n        glTexture.dirtyId = -1;\n\n        texture._glTextures[this.CONTEXT_UID] = glTexture;\n\n        this.managedTextures.push(texture);\n        texture.on('dispose', this.destroyTexture, this);\n\n        return glTexture;\n    }\n\n    initTextureType(texture: BaseTexture, glTexture: GLTexture): void\n    {\n        glTexture.internalFormat = this.internalFormats[texture.type]?.[texture.format] ?? texture.format;\n\n        if (this.webGLVersion === 2 && texture.type === TYPES.HALF_FLOAT)\n        {\n            // TYPES.HALF_FLOAT is WebGL1 HALF_FLOAT_OES\n            // we have to convert it to WebGL HALF_FLOAT\n            glTexture.type = this.gl.HALF_FLOAT;\n        }\n        else\n        {\n            glTexture.type = texture.type;\n        }\n    }\n\n    /**\n     * Update a texture\n     * @private\n     * @param {PIXI.BaseTexture} texture - Texture to initialize\n     */\n    updateTexture(texture: BaseTexture): void\n    {\n        const glTexture = texture._glTextures[this.CONTEXT_UID];\n\n        if (!glTexture)\n        {\n            return;\n        }\n\n        const renderer = this.renderer;\n\n        this.initTextureType(texture, glTexture);\n\n        if (texture.resource?.upload(renderer, texture, glTexture))\n        {\n            // texture is uploaded, dont do anything!\n            if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT)\n            {\n                this.hasIntegerTextures = true;\n            }\n        }\n        else\n        {\n            // default, renderTexture-like logic\n            const width = texture.realWidth;\n            const height = texture.realHeight;\n            const gl = renderer.gl;\n\n            if (glTexture.width !== width\n                || glTexture.height !== height\n                || glTexture.dirtyId < 0)\n            {\n                glTexture.width = width;\n                glTexture.height = height;\n\n                gl.texImage2D(texture.target, 0,\n                    glTexture.internalFormat,\n                    width,\n                    height,\n                    0,\n                    texture.format,\n                    glTexture.type,\n                    null);\n            }\n        }\n\n        // lets only update what changes..\n        if (texture.dirtyStyleId !== glTexture.dirtyStyleId)\n        {\n            this.updateTextureStyle(texture);\n        }\n        glTexture.dirtyId = texture.dirtyId;\n    }\n\n    /**\n     * Deletes the texture from WebGL\n     * @private\n     * @param texture - the texture to destroy\n     * @param [skipRemove=false] - Whether to skip removing the texture from the TextureManager.\n     */\n    destroyTexture(texture: BaseTexture | Texture, skipRemove?: boolean): void\n    {\n        const { gl } = this;\n\n        texture = texture.castToBaseTexture();\n\n        if (texture._glTextures[this.CONTEXT_UID])\n        {\n            this.unbind(texture);\n\n            gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);\n            texture.off('dispose', this.destroyTexture, this);\n\n            delete texture._glTextures[this.CONTEXT_UID];\n\n            if (!skipRemove)\n            {\n                const i = this.managedTextures.indexOf(texture);\n\n                if (i !== -1)\n                {\n                    removeItems(this.managedTextures, i, 1);\n                }\n            }\n        }\n    }\n\n    /**\n     * Update texture style such as mipmap flag\n     * @private\n     * @param {PIXI.BaseTexture} texture - Texture to update\n     */\n    updateTextureStyle(texture: BaseTexture): void\n    {\n        const glTexture = texture._glTextures[this.CONTEXT_UID];\n\n        if (!glTexture)\n        {\n            return;\n        }\n\n        if ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo)\n        {\n            glTexture.mipmap = false;\n        }\n        else\n        {\n            glTexture.mipmap = texture.mipmap >= 1;\n        }\n\n        if (this.webGLVersion !== 2 && !texture.isPowerOfTwo)\n        {\n            glTexture.wrapMode = WRAP_MODES.CLAMP;\n        }\n        else\n        {\n            glTexture.wrapMode = texture.wrapMode;\n        }\n\n        if (texture.resource?.style(this.renderer, texture, glTexture))\n        {\n            // style is set, dont do anything!\n        }\n        else\n        {\n            this.setStyle(texture, glTexture);\n        }\n\n        glTexture.dirtyStyleId = texture.dirtyStyleId;\n    }\n\n    /**\n     * Set style for texture\n     * @private\n     * @param texture - Texture to update\n     * @param glTexture\n     */\n    setStyle(texture: BaseTexture, glTexture: GLTexture): void\n    {\n        const gl = this.gl;\n\n        if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES.ON_MANUAL)\n        {\n            gl.generateMipmap(texture.target);\n        }\n\n        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);\n        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);\n\n        if (glTexture.mipmap)\n        {\n            /* eslint-disable max-len */\n            gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);\n            /* eslint-disable max-len */\n\n            const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;\n\n            if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR)\n            {\n                const level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n\n                gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n            }\n        }\n        else\n        {\n            gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n        }\n\n        gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n    }\n\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n}\n\nextensions.add(TextureSystem);\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}