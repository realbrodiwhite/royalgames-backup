{"ast":null,"code":"import { ObjectRenderer, Matrix, TYPES, Shader, State, utils, ExtensionType, extensions } from '@pixi/core';\nimport { ParticleBuffer } from './ParticleBuffer.mjs';\nimport fragment from './particles.mjs';\nimport vertex from './particles2.mjs';\nclass ParticleRenderer extends ObjectRenderer {\n  constructor(renderer) {\n    super(renderer);\n    this.shader = null;\n    this.properties = null;\n    this.tempMatrix = new Matrix();\n    this.properties = [{\n      attributeName: \"aVertexPosition\",\n      size: 2,\n      uploadFunction: this.uploadVertices,\n      offset: 0\n    }, {\n      attributeName: \"aPositionCoord\",\n      size: 2,\n      uploadFunction: this.uploadPosition,\n      offset: 0\n    }, {\n      attributeName: \"aRotation\",\n      size: 1,\n      uploadFunction: this.uploadRotation,\n      offset: 0\n    }, {\n      attributeName: \"aTextureCoord\",\n      size: 2,\n      uploadFunction: this.uploadUvs,\n      offset: 0\n    }, {\n      attributeName: \"aColor\",\n      size: 1,\n      type: TYPES.UNSIGNED_BYTE,\n      uploadFunction: this.uploadTint,\n      offset: 0\n    }];\n    this.shader = Shader.from(vertex, fragment, {});\n    this.state = State.for2d();\n  }\n  render(container) {\n    const children = container.children;\n    const maxSize = container._maxSize;\n    const batchSize = container._batchSize;\n    const renderer = this.renderer;\n    let totalChildren = children.length;\n    if (totalChildren === 0) {\n      return;\n    } else if (totalChildren > maxSize && !container.autoResize) {\n      totalChildren = maxSize;\n    }\n    let buffers = container._buffers;\n    if (!buffers) {\n      buffers = container._buffers = this.generateBuffers(container);\n    }\n    const baseTexture = children[0]._texture.baseTexture;\n    const premultiplied = baseTexture.alphaMode > 0;\n    this.state.blendMode = utils.correctBlendMode(container.blendMode, premultiplied);\n    renderer.state.set(this.state);\n    const gl = renderer.gl;\n    const m = container.worldTransform.copyTo(this.tempMatrix);\n    m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);\n    this.shader.uniforms.translationMatrix = m.toArray(true);\n    this.shader.uniforms.uColor = utils.premultiplyRgba(container.tintRgb, container.worldAlpha, this.shader.uniforms.uColor, premultiplied);\n    this.shader.uniforms.uSampler = baseTexture;\n    this.renderer.shader.bind(this.shader);\n    let updateStatic = false;\n    for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {\n      let amount = totalChildren - i;\n      if (amount > batchSize) {\n        amount = batchSize;\n      }\n      if (j >= buffers.length) {\n        buffers.push(this._generateOneMoreBuffer(container));\n      }\n      const buffer = buffers[j];\n      buffer.uploadDynamic(children, i, amount);\n      const bid = container._bufferUpdateIDs[j] || 0;\n      updateStatic = updateStatic || buffer._updateID < bid;\n      if (updateStatic) {\n        buffer._updateID = container._updateID;\n        buffer.uploadStatic(children, i, amount);\n      }\n      renderer.geometry.bind(buffer.geometry);\n      gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);\n    }\n  }\n  generateBuffers(container) {\n    const buffers = [];\n    const size = container._maxSize;\n    const batchSize = container._batchSize;\n    const dynamicPropertyFlags = container._properties;\n    for (let i = 0; i < size; i += batchSize) {\n      buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));\n    }\n    return buffers;\n  }\n  _generateOneMoreBuffer(container) {\n    const batchSize = container._batchSize;\n    const dynamicPropertyFlags = container._properties;\n    return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);\n  }\n  uploadVertices(children, startIndex, amount, array, stride, offset) {\n    let w0 = 0;\n    let w1 = 0;\n    let h0 = 0;\n    let h1 = 0;\n    for (let i = 0; i < amount; ++i) {\n      const sprite = children[startIndex + i];\n      const texture = sprite._texture;\n      const sx = sprite.scale.x;\n      const sy = sprite.scale.y;\n      const trim = texture.trim;\n      const orig = texture.orig;\n      if (trim) {\n        w1 = trim.x - sprite.anchor.x * orig.width;\n        w0 = w1 + trim.width;\n        h1 = trim.y - sprite.anchor.y * orig.height;\n        h0 = h1 + trim.height;\n      } else {\n        w0 = orig.width * (1 - sprite.anchor.x);\n        w1 = orig.width * -sprite.anchor.x;\n        h0 = orig.height * (1 - sprite.anchor.y);\n        h1 = orig.height * -sprite.anchor.y;\n      }\n      array[offset] = w1 * sx;\n      array[offset + 1] = h1 * sy;\n      array[offset + stride] = w0 * sx;\n      array[offset + stride + 1] = h1 * sy;\n      array[offset + stride * 2] = w0 * sx;\n      array[offset + stride * 2 + 1] = h0 * sy;\n      array[offset + stride * 3] = w1 * sx;\n      array[offset + stride * 3 + 1] = h0 * sy;\n      offset += stride * 4;\n    }\n  }\n  uploadPosition(children, startIndex, amount, array, stride, offset) {\n    for (let i = 0; i < amount; i++) {\n      const spritePosition = children[startIndex + i].position;\n      array[offset] = spritePosition.x;\n      array[offset + 1] = spritePosition.y;\n      array[offset + stride] = spritePosition.x;\n      array[offset + stride + 1] = spritePosition.y;\n      array[offset + stride * 2] = spritePosition.x;\n      array[offset + stride * 2 + 1] = spritePosition.y;\n      array[offset + stride * 3] = spritePosition.x;\n      array[offset + stride * 3 + 1] = spritePosition.y;\n      offset += stride * 4;\n    }\n  }\n  uploadRotation(children, startIndex, amount, array, stride, offset) {\n    for (let i = 0; i < amount; i++) {\n      const spriteRotation = children[startIndex + i].rotation;\n      array[offset] = spriteRotation;\n      array[offset + stride] = spriteRotation;\n      array[offset + stride * 2] = spriteRotation;\n      array[offset + stride * 3] = spriteRotation;\n      offset += stride * 4;\n    }\n  }\n  uploadUvs(children, startIndex, amount, array, stride, offset) {\n    for (let i = 0; i < amount; ++i) {\n      const textureUvs = children[startIndex + i]._texture._uvs;\n      if (textureUvs) {\n        array[offset] = textureUvs.x0;\n        array[offset + 1] = textureUvs.y0;\n        array[offset + stride] = textureUvs.x1;\n        array[offset + stride + 1] = textureUvs.y1;\n        array[offset + stride * 2] = textureUvs.x2;\n        array[offset + stride * 2 + 1] = textureUvs.y2;\n        array[offset + stride * 3] = textureUvs.x3;\n        array[offset + stride * 3 + 1] = textureUvs.y3;\n        offset += stride * 4;\n      } else {\n        array[offset] = 0;\n        array[offset + 1] = 0;\n        array[offset + stride] = 0;\n        array[offset + stride + 1] = 0;\n        array[offset + stride * 2] = 0;\n        array[offset + stride * 2 + 1] = 0;\n        array[offset + stride * 3] = 0;\n        array[offset + stride * 3 + 1] = 0;\n        offset += stride * 4;\n      }\n    }\n  }\n  uploadTint(children, startIndex, amount, array, stride, offset) {\n    for (let i = 0; i < amount; ++i) {\n      const sprite = children[startIndex + i];\n      const premultiplied = sprite._texture.baseTexture.alphaMode > 0;\n      const alpha = sprite.alpha;\n      const argb = alpha < 1 && premultiplied ? utils.premultiplyTint(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);\n      array[offset] = argb;\n      array[offset + stride] = argb;\n      array[offset + stride * 2] = argb;\n      array[offset + stride * 3] = argb;\n      offset += stride * 4;\n    }\n  }\n  destroy() {\n    super.destroy();\n    if (this.shader) {\n      this.shader.destroy();\n      this.shader = null;\n    }\n    this.tempMatrix = null;\n  }\n}\nParticleRenderer.extension = {\n  name: \"particle\",\n  type: ExtensionType.RendererPlugin\n};\nextensions.add(ParticleRenderer);\nexport { ParticleRenderer };","map":{"version":3,"mappings":"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","names":["ParticleRenderer","ObjectRenderer","constructor","renderer","shader","properties","Matrix","attributeName","size","uploadFunction","offset","type","TYPES","Shader","vertex","State","for2d","render","container","children","maxSize","batchSize","totalChildren","autoResize","buffers","_texture","baseTexture","alphaMode","state","blendMode","correctBlendMode","premultiplied","set","gl","m","worldTransform","tempMatrix","prepend","globalUniforms","projectionMatrix","translationMatrix","toArray","uColor","premultiplyRgba","tintRgb","worldAlpha","uniforms","uSampler","bind","updateStatic","j","i","amount","length","push","_generateOneMoreBuffer","buffer","_updateID","geometry","drawElements","UNSIGNED_SHORT","generateBuffers","dynamicPropertyFlags","ParticleBuffer","uploadVertices","startIndex","stride","w0","w1","h0","h1","texture","sprite","scale","trim","orig","x","y","anchor","array","uploadPosition","spritePosition","uploadRotation","uploadUvs","textureUvs","uploadTint","alpha","argb","utils","destroy","extension","name","ExtensionType","extensions","add"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/particle-container/src/ParticleRenderer.ts"],"sourcesContent":["import { extensions, ExtensionType, Matrix, ObjectRenderer, Shader, State, TYPES, utils } from '@pixi/core';\nimport { ParticleBuffer } from './ParticleBuffer';\nimport fragment from './particles.frag';\nimport vertex from './particles.vert';\n\nimport type { ExtensionMetadata, Renderer } from '@pixi/core';\nimport type { Sprite } from '@pixi/sprite';\nimport type { ParticleContainer } from './ParticleContainer';\n\nexport interface IParticleRendererProperty\n{\n    attributeName: string;\n    size: number;\n    type?: TYPES;\n    uploadFunction: (...params: any[]) => any;\n    offset: number;\n}\n\n/*\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now\n * share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's ParticleRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleRenderer.java\n */\n\n/**\n * Renderer for Particles that is designer for speed over feature set.\n * @memberof PIXI\n */\nexport class ParticleRenderer extends ObjectRenderer\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'particle',\n        type: ExtensionType.RendererPlugin,\n    };\n\n    /** The WebGL state in which this renderer will work. */\n    public readonly state: State;\n\n    /** The default shader that is used if a sprite doesn't have a more specific one. */\n    public shader: Shader;\n    public tempMatrix: Matrix;\n    public properties: IParticleRendererProperty[];\n\n    /**\n     * @param renderer - The renderer this sprite batch works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        // 65535 is max vertex index in the index buffer (see ParticleRenderer)\n        // so max number of particles is 65536 / 4 = 16384\n        // and max number of element in the index buffer is 16384 * 6 = 98304\n        // Creating a full index buffer, overhead is 98304 * 2 = 196Ko\n        // let numIndices = 98304;\n\n        this.shader = null;\n\n        this.properties = null;\n\n        this.tempMatrix = new Matrix();\n\n        this.properties = [\n            // verticesData\n            {\n                attributeName: 'aVertexPosition',\n                size: 2,\n                uploadFunction: this.uploadVertices,\n                offset: 0,\n            },\n            // positionData\n            {\n                attributeName: 'aPositionCoord',\n                size: 2,\n                uploadFunction: this.uploadPosition,\n                offset: 0,\n            },\n            // rotationData\n            {\n                attributeName: 'aRotation',\n                size: 1,\n                uploadFunction: this.uploadRotation,\n                offset: 0,\n            },\n            // uvsData\n            {\n                attributeName: 'aTextureCoord',\n                size: 2,\n                uploadFunction: this.uploadUvs,\n                offset: 0,\n            },\n            // tintData\n            {\n                attributeName: 'aColor',\n                size: 1,\n                type: TYPES.UNSIGNED_BYTE,\n                uploadFunction: this.uploadTint,\n                offset: 0,\n            },\n        ];\n\n        this.shader = Shader.from(vertex, fragment, {});\n        this.state = State.for2d();\n    }\n\n    /**\n     * Renders the particle container object.\n     * @param container - The container to render using this ParticleRenderer.\n     */\n    public render(container: ParticleContainer): void\n    {\n        const children = container.children;\n        const maxSize = container._maxSize;\n        const batchSize = container._batchSize;\n        const renderer = this.renderer;\n        let totalChildren = children.length;\n\n        if (totalChildren === 0)\n        {\n            return;\n        }\n        else if (totalChildren > maxSize && !container.autoResize)\n        {\n            totalChildren = maxSize;\n        }\n\n        let buffers = container._buffers;\n\n        if (!buffers)\n        {\n            buffers = container._buffers = this.generateBuffers(container);\n        }\n\n        const baseTexture = children[0]._texture.baseTexture;\n        const premultiplied = baseTexture.alphaMode > 0;\n\n        // if the uvs have not updated then no point rendering just yet!\n        this.state.blendMode = utils.correctBlendMode(container.blendMode, premultiplied);\n        renderer.state.set(this.state);\n\n        const gl = renderer.gl;\n\n        const m = container.worldTransform.copyTo(this.tempMatrix);\n\n        m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);\n\n        this.shader.uniforms.translationMatrix = m.toArray(true);\n\n        this.shader.uniforms.uColor = utils.premultiplyRgba(container.tintRgb,\n            container.worldAlpha, this.shader.uniforms.uColor, premultiplied);\n\n        this.shader.uniforms.uSampler = baseTexture;\n\n        this.renderer.shader.bind(this.shader);\n\n        let updateStatic = false;\n\n        // now lets upload and render the buffers..\n        for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1)\n        {\n            let amount = (totalChildren - i);\n\n            if (amount > batchSize)\n            {\n                amount = batchSize;\n            }\n\n            if (j >= buffers.length)\n            {\n                buffers.push(this._generateOneMoreBuffer(container));\n            }\n\n            const buffer = buffers[j];\n\n            // we always upload the dynamic\n            buffer.uploadDynamic(children, i, amount);\n\n            const bid = container._bufferUpdateIDs[j] || 0;\n\n            updateStatic = updateStatic || (buffer._updateID < bid);\n            // we only upload the static content when we have to!\n            if (updateStatic)\n            {\n                buffer._updateID = container._updateID;\n                buffer.uploadStatic(children, i, amount);\n            }\n\n            // bind the buffer\n            renderer.geometry.bind(buffer.geometry);\n            gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);\n        }\n    }\n\n    /**\n     * Creates one particle buffer for each child in the container we want to render and updates internal properties.\n     * @param container - The container to render using this ParticleRenderer\n     * @returns - The buffers\n     */\n    private generateBuffers(container: ParticleContainer): ParticleBuffer[]\n    {\n        const buffers = [];\n        const size = container._maxSize;\n        const batchSize = container._batchSize;\n        const dynamicPropertyFlags = container._properties;\n\n        for (let i = 0; i < size; i += batchSize)\n        {\n            buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));\n        }\n\n        return buffers;\n    }\n\n    /**\n     * Creates one more particle buffer, because container has autoResize feature.\n     * @param container - The container to render using this ParticleRenderer\n     * @returns - The generated buffer\n     */\n    private _generateOneMoreBuffer(container: ParticleContainer): ParticleBuffer\n    {\n        const batchSize = container._batchSize;\n        const dynamicPropertyFlags = container._properties;\n\n        return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);\n    }\n\n    /**\n     * Uploads the vertices.\n     * @param children - the array of sprites to render\n     * @param startIndex - the index to start from in the children array\n     * @param amount - the amount of children that will have their vertices uploaded\n     * @param array - The vertices to upload.\n     * @param stride - Stride to use for iteration.\n     * @param offset - Offset to start at.\n     */\n    public uploadVertices(\n        children: Sprite[], startIndex: number, amount: number,\n        array: number[], stride: number, offset: number\n    ): void\n    {\n        let w0 = 0;\n        let w1 = 0;\n        let h0 = 0;\n        let h1 = 0;\n\n        for (let i = 0; i < amount; ++i)\n        {\n            const sprite = children[startIndex + i];\n            const texture = sprite._texture;\n            const sx = sprite.scale.x;\n            const sy = sprite.scale.y;\n            const trim = texture.trim;\n            const orig = texture.orig;\n\n            if (trim)\n            {\n                // if the sprite is trimmed and is not a tilingsprite then we need to add the\n                // extra space before transforming the sprite coords..\n                w1 = trim.x - (sprite.anchor.x * orig.width);\n                w0 = w1 + trim.width;\n\n                h1 = trim.y - (sprite.anchor.y * orig.height);\n                h0 = h1 + trim.height;\n            }\n            else\n            {\n                w0 = (orig.width) * (1 - sprite.anchor.x);\n                w1 = (orig.width) * -sprite.anchor.x;\n\n                h0 = orig.height * (1 - sprite.anchor.y);\n                h1 = orig.height * -sprite.anchor.y;\n            }\n\n            array[offset] = w1 * sx;\n            array[offset + 1] = h1 * sy;\n\n            array[offset + stride] = w0 * sx;\n            array[offset + stride + 1] = h1 * sy;\n\n            array[offset + (stride * 2)] = w0 * sx;\n            array[offset + (stride * 2) + 1] = h0 * sy;\n\n            array[offset + (stride * 3)] = w1 * sx;\n            array[offset + (stride * 3) + 1] = h0 * sy;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     * Uploads the position.\n     * @param children - the array of sprites to render\n     * @param startIndex - the index to start from in the children array\n     * @param amount - the amount of children that will have their positions uploaded\n     * @param array - The vertices to upload.\n     * @param stride - Stride to use for iteration.\n     * @param offset - Offset to start at.\n     */\n    public uploadPosition(\n        children: Sprite[], startIndex: number, amount: number,\n        array: number[], stride: number, offset: number\n    ): void\n    {\n        for (let i = 0; i < amount; i++)\n        {\n            const spritePosition = children[startIndex + i].position;\n\n            array[offset] = spritePosition.x;\n            array[offset + 1] = spritePosition.y;\n\n            array[offset + stride] = spritePosition.x;\n            array[offset + stride + 1] = spritePosition.y;\n\n            array[offset + (stride * 2)] = spritePosition.x;\n            array[offset + (stride * 2) + 1] = spritePosition.y;\n\n            array[offset + (stride * 3)] = spritePosition.x;\n            array[offset + (stride * 3) + 1] = spritePosition.y;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     * Uploads the rotation.\n     * @param children - the array of sprites to render\n     * @param startIndex - the index to start from in the children array\n     * @param amount - the amount of children that will have their rotation uploaded\n     * @param array - The vertices to upload.\n     * @param stride - Stride to use for iteration.\n     * @param offset - Offset to start at.\n     */\n    public uploadRotation(\n        children: Sprite[], startIndex: number, amount: number,\n        array: number[], stride: number, offset: number\n    ): void\n    {\n        for (let i = 0; i < amount; i++)\n        {\n            const spriteRotation = children[startIndex + i].rotation;\n\n            array[offset] = spriteRotation;\n            array[offset + stride] = spriteRotation;\n            array[offset + (stride * 2)] = spriteRotation;\n            array[offset + (stride * 3)] = spriteRotation;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     * Uploads the UVs.\n     * @param children - the array of sprites to render\n     * @param startIndex - the index to start from in the children array\n     * @param amount - the amount of children that will have their rotation uploaded\n     * @param array - The vertices to upload.\n     * @param stride - Stride to use for iteration.\n     * @param offset - Offset to start at.\n     */\n    public uploadUvs(\n        children: Sprite[], startIndex: number, amount: number,\n        array: number[], stride: number, offset: number\n    ): void\n    {\n        for (let i = 0; i < amount; ++i)\n        {\n            const textureUvs = children[startIndex + i]._texture._uvs;\n\n            if (textureUvs)\n            {\n                array[offset] = textureUvs.x0;\n                array[offset + 1] = textureUvs.y0;\n\n                array[offset + stride] = textureUvs.x1;\n                array[offset + stride + 1] = textureUvs.y1;\n\n                array[offset + (stride * 2)] = textureUvs.x2;\n                array[offset + (stride * 2) + 1] = textureUvs.y2;\n\n                array[offset + (stride * 3)] = textureUvs.x3;\n                array[offset + (stride * 3) + 1] = textureUvs.y3;\n\n                offset += stride * 4;\n            }\n            else\n            {\n                // TODO you know this can be easier!\n                array[offset] = 0;\n                array[offset + 1] = 0;\n\n                array[offset + stride] = 0;\n                array[offset + stride + 1] = 0;\n\n                array[offset + (stride * 2)] = 0;\n                array[offset + (stride * 2) + 1] = 0;\n\n                array[offset + (stride * 3)] = 0;\n                array[offset + (stride * 3) + 1] = 0;\n\n                offset += stride * 4;\n            }\n        }\n    }\n\n    /**\n     * Uploads the tint.\n     * @param children - the array of sprites to render\n     * @param startIndex - the index to start from in the children array\n     * @param amount - the amount of children that will have their rotation uploaded\n     * @param array - The vertices to upload.\n     * @param stride - Stride to use for iteration.\n     * @param offset - Offset to start at.\n     */\n    public uploadTint(\n        children: Sprite[], startIndex: number, amount: number,\n        array: number[], stride: number, offset: number\n    ): void\n    {\n        for (let i = 0; i < amount; ++i)\n        {\n            const sprite = children[startIndex + i];\n            const premultiplied = sprite._texture.baseTexture.alphaMode > 0;\n            const alpha = sprite.alpha;\n\n            // we dont call extra function if alpha is 1.0, that's faster\n            const argb = alpha < 1.0 && premultiplied\n                ? utils.premultiplyTint(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);\n\n            array[offset] = argb;\n            array[offset + stride] = argb;\n            array[offset + (stride * 2)] = argb;\n            array[offset + (stride * 3)] = argb;\n\n            offset += stride * 4;\n        }\n    }\n\n    /** Destroys the ParticleRenderer. */\n    public destroy(): void\n    {\n        super.destroy();\n\n        if (this.shader)\n        {\n            this.shader.destroy();\n            this.shader = null;\n        }\n\n        this.tempMatrix = null;\n    }\n}\n\nextensions.add(ParticleRenderer);\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}