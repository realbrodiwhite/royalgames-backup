{"ast":null,"code":"import { CLEAR_MODES, DRAW_MODES, MSAA_QUALITY } from '@pixi/constants';\nimport { ExtensionType, extensions } from '@pixi/extensions';\nimport { Point, Matrix, Rectangle } from '@pixi/math';\nimport { RenderTexturePool } from '../renderTexture/RenderTexturePool.mjs';\nimport { UniformGroup } from '../shader/UniformGroup.mjs';\nimport { Quad } from '../utils/Quad.mjs';\nimport { QuadUv } from '../utils/QuadUv.mjs';\nimport { FilterState } from './FilterState.mjs';\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\nconst tempMatrix = new Matrix();\nclass FilterSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.defaultFilterStack = [{}];\n    this.texturePool = new RenderTexturePool();\n    this.statePool = [];\n    this.quad = new Quad();\n    this.quadUv = new QuadUv();\n    this.tempRect = new Rectangle();\n    this.activeState = {};\n    this.globalUniforms = new UniformGroup({\n      outputFrame: new Rectangle(),\n      inputSize: new Float32Array(4),\n      inputPixel: new Float32Array(4),\n      inputClamp: new Float32Array(4),\n      resolution: 1,\n      filterArea: new Float32Array(4),\n      filterClamp: new Float32Array(4)\n    }, true);\n    this.forceClear = false;\n    this.useMaxPadding = false;\n  }\n  init() {\n    this.texturePool.setScreenSize(this.renderer.view);\n  }\n  push(target, filters) {\n    var _filters$0$legacy;\n    const renderer = this.renderer;\n    const filterStack = this.defaultFilterStack;\n    const state = this.statePool.pop() || new FilterState();\n    const renderTextureSystem = this.renderer.renderTexture;\n    let resolution = filters[0].resolution;\n    let multisample = filters[0].multisample;\n    let padding = filters[0].padding;\n    let autoFit = filters[0].autoFit;\n    let legacy = (_filters$0$legacy = filters[0].legacy) !== null && _filters$0$legacy !== void 0 ? _filters$0$legacy : true;\n    for (let i = 1; i < filters.length; i++) {\n      var _filter$legacy;\n      const filter = filters[i];\n      resolution = Math.min(resolution, filter.resolution);\n      multisample = Math.min(multisample, filter.multisample);\n      padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding;\n      autoFit = autoFit && filter.autoFit;\n      legacy = legacy || ((_filter$legacy = filter.legacy) !== null && _filter$legacy !== void 0 ? _filter$legacy : true);\n    }\n    if (filterStack.length === 1) {\n      this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;\n    }\n    filterStack.push(state);\n    state.resolution = resolution;\n    state.multisample = multisample;\n    state.legacy = legacy;\n    state.target = target;\n    state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));\n    state.sourceFrame.pad(padding);\n    const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);\n    if (renderer.projection.transform) {\n      this.transformAABB(tempMatrix.copyFrom(renderer.projection.transform).invert(), sourceFrameProjected);\n    }\n    if (autoFit) {\n      state.sourceFrame.fit(sourceFrameProjected);\n      if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) {\n        state.sourceFrame.width = 0;\n        state.sourceFrame.height = 0;\n      }\n    } else if (!state.sourceFrame.intersects(sourceFrameProjected)) {\n      state.sourceFrame.width = 0;\n      state.sourceFrame.height = 0;\n    }\n    this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);\n    state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);\n    state.filters = filters;\n    state.destinationFrame.width = state.renderTexture.width;\n    state.destinationFrame.height = state.renderTexture.height;\n    const destinationFrame = this.tempRect;\n    destinationFrame.x = 0;\n    destinationFrame.y = 0;\n    destinationFrame.width = state.sourceFrame.width;\n    destinationFrame.height = state.sourceFrame.height;\n    state.renderTexture.filterFrame = state.sourceFrame;\n    state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);\n    state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);\n    state.transform = renderer.projection.transform;\n    renderer.projection.transform = null;\n    renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);\n    renderer.framebuffer.clear(0, 0, 0, 0);\n  }\n  pop() {\n    const filterStack = this.defaultFilterStack;\n    const state = filterStack.pop();\n    const filters = state.filters;\n    this.activeState = state;\n    const globalUniforms = this.globalUniforms.uniforms;\n    globalUniforms.outputFrame = state.sourceFrame;\n    globalUniforms.resolution = state.resolution;\n    const inputSize = globalUniforms.inputSize;\n    const inputPixel = globalUniforms.inputPixel;\n    const inputClamp = globalUniforms.inputClamp;\n    inputSize[0] = state.destinationFrame.width;\n    inputSize[1] = state.destinationFrame.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = Math.round(inputSize[0] * state.resolution);\n    inputPixel[1] = Math.round(inputSize[1] * state.resolution);\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];\n    if (state.legacy) {\n      const filterArea = globalUniforms.filterArea;\n      filterArea[0] = state.destinationFrame.width;\n      filterArea[1] = state.destinationFrame.height;\n      filterArea[2] = state.sourceFrame.x;\n      filterArea[3] = state.sourceFrame.y;\n      globalUniforms.filterClamp = globalUniforms.inputClamp;\n    }\n    this.globalUniforms.update();\n    const lastState = filterStack[filterStack.length - 1];\n    this.renderer.framebuffer.blit();\n    if (filters.length === 1) {\n      filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);\n      this.returnFilterTexture(state.renderTexture);\n    } else {\n      let flip = state.renderTexture;\n      let flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);\n      flop.filterFrame = flip.filterFrame;\n      let i = 0;\n      for (i = 0; i < filters.length - 1; ++i) {\n        if (i === 1 && state.multisample > 1) {\n          flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);\n          flop.filterFrame = flip.filterFrame;\n        }\n        filters[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);\n        const t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);\n      if (i > 1 && state.multisample > 1) {\n        this.returnFilterTexture(state.renderTexture);\n      }\n      this.returnFilterTexture(flip);\n      this.returnFilterTexture(flop);\n    }\n    state.clear();\n    this.statePool.push(state);\n  }\n  bindAndClear(filterTexture) {\n    let clearMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CLEAR_MODES.CLEAR;\n    const {\n      renderTexture: renderTextureSystem,\n      state: stateSystem\n    } = this.renderer;\n    if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {\n      this.renderer.projection.transform = this.activeState.transform;\n    } else {\n      this.renderer.projection.transform = null;\n    }\n    if (filterTexture !== null && filterTexture !== void 0 && filterTexture.filterFrame) {\n      const destinationFrame = this.tempRect;\n      destinationFrame.x = 0;\n      destinationFrame.y = 0;\n      destinationFrame.width = filterTexture.filterFrame.width;\n      destinationFrame.height = filterTexture.filterFrame.height;\n      renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);\n    } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {\n      renderTextureSystem.bind(filterTexture);\n    } else {\n      this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);\n    }\n    const autoClear = stateSystem.stateId & 1 || this.forceClear;\n    if (clearMode === CLEAR_MODES.CLEAR || clearMode === CLEAR_MODES.BLIT && autoClear) {\n      this.renderer.framebuffer.clear(0, 0, 0, 0);\n    }\n  }\n  applyFilter(filter, input, output, clearMode) {\n    const renderer = this.renderer;\n    renderer.state.set(filter.state);\n    this.bindAndClear(output, clearMode);\n    filter.uniforms.uSampler = input;\n    filter.uniforms.filterGlobals = this.globalUniforms;\n    renderer.shader.bind(filter);\n    filter.legacy = !!filter.program.attributeData.aTextureCoord;\n    if (filter.legacy) {\n      this.quadUv.map(input._frame, input.filterFrame);\n      renderer.geometry.bind(this.quadUv);\n      renderer.geometry.draw(DRAW_MODES.TRIANGLES);\n    } else {\n      renderer.geometry.bind(this.quad);\n      renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP);\n    }\n  }\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const {\n      sourceFrame,\n      destinationFrame\n    } = this.activeState;\n    const {\n      orig\n    } = sprite._texture;\n    const mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);\n    const worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(1 / orig.width, 1 / orig.height);\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  }\n  destroy() {\n    this.renderer = null;\n    this.texturePool.clear(false);\n  }\n  getOptimalFilterTexture(minWidth, minHeight) {\n    let resolution = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    let multisample = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : MSAA_QUALITY.NONE;\n    return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);\n  }\n  getFilterTexture(input, resolution, multisample) {\n    if (typeof input === \"number\") {\n      const swap = input;\n      input = resolution;\n      resolution = swap;\n    }\n    input = input || this.activeState.renderTexture;\n    const filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);\n    filterTexture.filterFrame = input.filterFrame;\n    return filterTexture;\n  }\n  returnFilterTexture(renderTexture) {\n    this.texturePool.returnTexture(renderTexture);\n  }\n  emptyPool() {\n    this.texturePool.clear(true);\n  }\n  resize() {\n    this.texturePool.setScreenSize(this.renderer.view);\n  }\n  transformAABB(matrix, rect) {\n    const lt = tempPoints[0];\n    const lb = tempPoints[1];\n    const rt = tempPoints[2];\n    const rb = tempPoints[3];\n    lt.set(rect.left, rect.top);\n    lb.set(rect.left, rect.bottom);\n    rt.set(rect.right, rect.top);\n    rb.set(rect.right, rect.bottom);\n    matrix.apply(lt, lt);\n    matrix.apply(lb, lb);\n    matrix.apply(rt, rt);\n    matrix.apply(rb, rb);\n    const x0 = Math.min(lt.x, lb.x, rt.x, rb.x);\n    const y0 = Math.min(lt.y, lb.y, rt.y, rb.y);\n    const x1 = Math.max(lt.x, lb.x, rt.x, rb.x);\n    const y1 = Math.max(lt.y, lb.y, rt.y, rb.y);\n    rect.x = x0;\n    rect.y = y0;\n    rect.width = x1 - x0;\n    rect.height = y1 - y0;\n  }\n  roundFrame(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {\n    if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {\n      return;\n    }\n    if (transform) {\n      const {\n        a,\n        b,\n        c,\n        d\n      } = transform;\n      if ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4)) {\n        return;\n      }\n    }\n    transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();\n    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);\n    this.transformAABB(transform, frame);\n    frame.ceil(resolution);\n    this.transformAABB(transform.invert(), frame);\n  }\n}\nFilterSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"filter\"\n};\nextensions.add(FilterSystem);\nexport { FilterSystem };","map":{"version":3,"mappings":"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","names":["tempPoints","Point","tempMatrix","Matrix","FilterSystem","constructor","renderer","RenderTexturePool","statePool","Quad","QuadUv","Rectangle","activeState","UniformGroup","outputFrame","inputSize","Float32Array","inputPixel","inputClamp","resolution","filterArea","filterClamp","forceClear","useMaxPadding","init","texturePool","view","push","target","filters","filterStack","state","pop","FilterState","legacy","i","length","filter","Math","multisample","padding","autoFit","renderTextureSystem","sourceFrame","copyFrom","pad","sourceFrameProjected","tempRect","projection","transform","invert","fit","height","width","roundFrame","current","destinationFrame","renderTexture","x","y","filterFrame","bind","framebuffer","globalUniforms","update","blit","apply","lastState","CLEAR_MODES","flip","getOptimalFilterTexture","flop","CLEAR","t","BLEND","returnFilterTexture","clear","bindAndClear","clearMode","filterTexture","defaultFilterStack","bindingDestinationFrame","autoClear","stateId","BLIT","applyFilter","input","set","output","uniforms","uSampler","filterGlobals","program","attributeData","quadUv","draw","TRIANGLES","quad","TRIANGLE_STRIP","calculateSpriteMatrix","outputMatrix","sprite","orig","mappedMatrix","worldTransform","TEMP_MATRIX","prepend","scale","translate","anchor","destroy","minWidth","MSAA_QUALITY","NONE","getFilterTexture","swap","returnTexture","emptyPool","resize","transformAABB","rect","lt","lb","rt","rb","left","top","bottom","right","matrix","x1","y1","frame","bindingSourceFrame","a","b","c","d","abs","identity","ceil","extension","type","ExtensionType","name","extensions","add"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/core/src/filters/FilterSystem.ts"],"sourcesContent":["import { CLEAR_MODES, DRAW_MODES, MSAA_QUALITY } from '@pixi/constants';\nimport { extensions, ExtensionType } from '@pixi/extensions';\nimport { Matrix, Point, Rectangle } from '@pixi/math';\nimport { RenderTexturePool } from '../renderTexture/RenderTexturePool';\nimport { UniformGroup } from '../shader/UniformGroup';\nimport { Quad } from '../utils/Quad';\nimport { QuadUv } from '../utils/QuadUv';\nimport { FilterState } from './FilterState';\n\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { Renderer } from '../Renderer';\nimport type { RenderTexture } from '../renderTexture/RenderTexture';\nimport type { ISystem } from '../system/ISystem';\nimport type { Filter } from './Filter';\nimport type { IFilterTarget } from './IFilterTarget';\nimport type { ISpriteMaskTarget } from './spriteMask/SpriteMaskFilter';\n\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\nconst tempMatrix = new Matrix();\n\n/**\n * System plugin to the renderer to manage filters.\n *\n * ## Pipeline\n *\n * The FilterSystem executes the filtering pipeline by rendering the display-object into a texture, applying its\n * [filters]{@link PIXI.Filter} in series, and the last filter outputs into the final render-target.\n *\n * The filter-frame is the rectangle in world space being filtered, and those contents are mapped into\n * `(0, 0, filterFrame.width, filterFrame.height)` into the filter render-texture. The filter-frame is also called\n * the source-frame, as it is used to bind the filter render-textures. The last filter outputs to the `filterFrame`\n * in the final render-target.\n *\n * ## Usage\n *\n * {@link PIXI.Container#renderAdvanced} is an example of how to use the filter system. It is a 3 step process:\n *\n * **push**: Use {@link PIXI.FilterSystem#push} to push the set of filters to be applied on a filter-target.\n * **render**: Render the contents to be filtered using the renderer. The filter-system will only capture the contents\n *      inside the bounds of the filter-target. NOTE: Using {@link PIXI.Renderer#render} is\n *      illegal during an existing render cycle, and it may reset the filter system.\n * **pop**: Use {@link PIXI.FilterSystem#pop} to pop & execute the filters you initially pushed. It will apply them\n *      serially and output to the bounds of the filter-target.\n * @memberof PIXI\n */\nexport class FilterSystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'filter',\n    };\n\n    /**\n     * List of filters for the FilterSystem\n     * @member {object[]}\n     */\n    public readonly defaultFilterStack: Array<FilterState>;\n\n    /** A pool for storing filter states, save us creating new ones each tick. */\n    public statePool: Array<FilterState>;\n\n    /** Stores a bunch of POT textures used for filtering. */\n    public texturePool: RenderTexturePool;\n\n    /** Whether to clear output renderTexture in AUTO/BLIT mode. See {@link PIXI.CLEAR_MODES}. */\n    public forceClear: boolean;\n\n    /**\n     * Old padding behavior is to use the max amount instead of sum padding.\n     * Use this flag if you need the old behavior.\n     * @default false\n     */\n    public useMaxPadding: boolean;\n\n    /** A very simple geometry used when drawing a filter effect to the screen. */\n    protected quad: Quad;\n\n    /** Quad UVs */\n    protected quadUv: QuadUv;\n\n    /**\n     * Active state\n     * @member {object}\n     */\n    protected activeState: FilterState;\n\n    /**\n     * This uniform group is attached to filter uniforms when used.\n     * @property {PIXI.Rectangle} outputFrame -\n     * @property {Float32Array} inputSize -\n     * @property {Float32Array} inputPixel -\n     * @property {Float32Array} inputClamp -\n     * @property {number} resolution -\n     * @property {Float32Array} filterArea -\n     * @property {Float32Array} filterClamp -\n     */\n    protected globalUniforms: UniformGroup;\n\n    /** Temporary rect for math. */\n    private tempRect: Rectangle;\n    public renderer: Renderer;\n\n    /**\n     * @param renderer - The renderer this System works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n\n        this.defaultFilterStack = [{}] as any;\n\n        this.texturePool = new RenderTexturePool();\n\n        this.statePool = [];\n\n        this.quad = new Quad();\n        this.quadUv = new QuadUv();\n        this.tempRect = new Rectangle();\n        this.activeState = {} as any;\n\n        this.globalUniforms = new UniformGroup({\n            outputFrame: new Rectangle(),\n            inputSize: new Float32Array(4),\n            inputPixel: new Float32Array(4),\n            inputClamp: new Float32Array(4),\n            resolution: 1,\n\n            // legacy variables\n            filterArea: new Float32Array(4),\n            filterClamp: new Float32Array(4),\n        }, true);\n\n        this.forceClear = false;\n        this.useMaxPadding = false;\n    }\n\n    init(): void\n    {\n        this.texturePool.setScreenSize(this.renderer.view);\n    }\n\n    /**\n     * Pushes a set of filters to be applied later to the system. This will redirect further rendering into an\n     * input render-texture for the rest of the filtering pipeline.\n     * @param {PIXI.DisplayObject} target - The target of the filter to render.\n     * @param filters - The filters to apply.\n     */\n    push(target: IFilterTarget, filters: Array<Filter>): void\n    {\n        const renderer = this.renderer;\n        const filterStack = this.defaultFilterStack;\n        const state = this.statePool.pop() || new FilterState();\n        const renderTextureSystem = this.renderer.renderTexture;\n\n        let resolution = filters[0].resolution;\n        let multisample = filters[0].multisample;\n        let padding = filters[0].padding;\n        let autoFit = filters[0].autoFit;\n        // We don't know whether it's a legacy filter until it was bound for the first time,\n        // therefore we have to assume that it is if legacy is undefined.\n        let legacy = filters[0].legacy ?? true;\n\n        for (let i = 1; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            // let's use the lowest resolution\n            resolution = Math.min(resolution, filter.resolution);\n            // let's use the lowest number of samples\n            multisample = Math.min(multisample, filter.multisample);\n            // figure out the padding required for filters\n            padding = this.useMaxPadding\n                // old behavior: use largest amount of padding!\n                ? Math.max(padding, filter.padding)\n                // new behavior: sum the padding\n                : padding + filter.padding;\n            // only auto fit if all filters are autofit\n            autoFit = autoFit && filter.autoFit;\n\n            legacy = legacy || (filter.legacy ?? true);\n        }\n\n        if (filterStack.length === 1)\n        {\n            this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;\n        }\n\n        filterStack.push(state);\n\n        state.resolution = resolution;\n        state.multisample = multisample;\n\n        state.legacy = legacy;\n\n        state.target = target;\n        state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));\n\n        state.sourceFrame.pad(padding);\n\n        const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);\n\n        // Project source frame into world space (if projection is applied)\n        if (renderer.projection.transform)\n        {\n            this.transformAABB(\n                tempMatrix.copyFrom(renderer.projection.transform).invert(),\n                sourceFrameProjected\n            );\n        }\n\n        if (autoFit)\n        {\n            state.sourceFrame.fit(sourceFrameProjected);\n\n            if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0)\n            {\n                state.sourceFrame.width = 0;\n                state.sourceFrame.height = 0;\n            }\n        }\n        else if (!state.sourceFrame.intersects(sourceFrameProjected))\n        {\n            state.sourceFrame.width = 0;\n            state.sourceFrame.height = 0;\n        }\n\n        // Round sourceFrame in screen space based on render-texture.\n        this.roundFrame(\n            state.sourceFrame,\n            renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,\n            renderTextureSystem.sourceFrame,\n            renderTextureSystem.destinationFrame,\n            renderer.projection.transform,\n        );\n\n        state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height,\n            resolution, multisample);\n        state.filters = filters;\n\n        state.destinationFrame.width = state.renderTexture.width;\n        state.destinationFrame.height = state.renderTexture.height;\n\n        const destinationFrame = this.tempRect;\n\n        destinationFrame.x = 0;\n        destinationFrame.y = 0;\n        destinationFrame.width = state.sourceFrame.width;\n        destinationFrame.height = state.sourceFrame.height;\n\n        state.renderTexture.filterFrame = state.sourceFrame;\n        state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);\n        state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);\n\n        state.transform = renderer.projection.transform;\n        renderer.projection.transform = null;\n        renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);\n        renderer.framebuffer.clear(0, 0, 0, 0);\n    }\n\n    /** Pops off the filter and applies it. */\n    pop(): void\n    {\n        const filterStack = this.defaultFilterStack;\n        const state = filterStack.pop();\n        const filters = state.filters;\n\n        this.activeState = state;\n\n        const globalUniforms = this.globalUniforms.uniforms;\n\n        globalUniforms.outputFrame = state.sourceFrame;\n        globalUniforms.resolution = state.resolution;\n\n        const inputSize = globalUniforms.inputSize;\n        const inputPixel = globalUniforms.inputPixel;\n        const inputClamp = globalUniforms.inputClamp;\n\n        inputSize[0] = state.destinationFrame.width;\n        inputSize[1] = state.destinationFrame.height;\n        inputSize[2] = 1.0 / inputSize[0];\n        inputSize[3] = 1.0 / inputSize[1];\n\n        inputPixel[0] = Math.round(inputSize[0] * state.resolution);\n        inputPixel[1] = Math.round(inputSize[1] * state.resolution);\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (state.sourceFrame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (state.sourceFrame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        // only update the rect if its legacy..\n        if (state.legacy)\n        {\n            const filterArea = globalUniforms.filterArea;\n\n            filterArea[0] = state.destinationFrame.width;\n            filterArea[1] = state.destinationFrame.height;\n            filterArea[2] = state.sourceFrame.x;\n            filterArea[3] = state.sourceFrame.y;\n\n            globalUniforms.filterClamp = globalUniforms.inputClamp;\n        }\n\n        this.globalUniforms.update();\n\n        const lastState = filterStack[filterStack.length - 1];\n\n        this.renderer.framebuffer.blit();\n\n        if (filters.length === 1)\n        {\n            filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);\n\n            this.returnFilterTexture(state.renderTexture);\n        }\n        else\n        {\n            let flip = state.renderTexture;\n            let flop = this.getOptimalFilterTexture(\n                flip.width,\n                flip.height,\n                state.resolution\n            );\n\n            flop.filterFrame = flip.filterFrame;\n\n            let i = 0;\n\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                if (i === 1 && state.multisample > 1)\n                {\n                    flop = this.getOptimalFilterTexture(\n                        flip.width,\n                        flip.height,\n                        state.resolution\n                    );\n\n                    flop.filterFrame = flip.filterFrame;\n                }\n\n                filters[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);\n\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);\n\n            if (i > 1 && state.multisample > 1)\n            {\n                this.returnFilterTexture(state.renderTexture);\n            }\n\n            this.returnFilterTexture(flip);\n            this.returnFilterTexture(flop);\n        }\n\n        // lastState.renderTexture is blitted when lastState is popped\n\n        state.clear();\n        this.statePool.push(state);\n    }\n\n    /**\n     * Binds a renderTexture with corresponding `filterFrame`, clears it if mode corresponds.\n     * @param filterTexture - renderTexture to bind, should belong to filter pool or filter stack\n     * @param clearMode - clearMode, by default its CLEAR/YES. See {@link PIXI.CLEAR_MODES}\n     */\n    bindAndClear(filterTexture: RenderTexture, clearMode: CLEAR_MODES = CLEAR_MODES.CLEAR): void\n    {\n        const {\n            renderTexture: renderTextureSystem,\n            state: stateSystem,\n        } = this.renderer;\n\n        if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture)\n        {\n            // Restore projection transform if rendering into the output render-target.\n            this.renderer.projection.transform = this.activeState.transform;\n        }\n        else\n        {\n            // Prevent projection within filtering pipeline.\n            this.renderer.projection.transform = null;\n        }\n\n        if (filterTexture?.filterFrame)\n        {\n            const destinationFrame = this.tempRect;\n\n            destinationFrame.x = 0;\n            destinationFrame.y = 0;\n            destinationFrame.width = filterTexture.filterFrame.width;\n            destinationFrame.height = filterTexture.filterFrame.height;\n\n            renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);\n        }\n        else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture)\n        {\n            renderTextureSystem.bind(filterTexture);\n        }\n        else\n        {\n            // Restore binding for output render-target.\n            this.renderer.renderTexture.bind(\n                filterTexture,\n                this.activeState.bindingSourceFrame,\n                this.activeState.bindingDestinationFrame\n            );\n        }\n\n        // Clear the texture in BLIT mode if blending is disabled or the forceClear flag is set. The blending\n        // is stored in the 0th bit of the state.\n        const autoClear = (stateSystem.stateId & 1) || this.forceClear;\n\n        if (clearMode === CLEAR_MODES.CLEAR\n            || (clearMode === CLEAR_MODES.BLIT && autoClear))\n        {\n            // Use framebuffer.clear because we want to clear the whole filter texture, not just the filtering\n            // area over which the shaders are run. This is because filters may sampling outside of it (e.g. blur)\n            // instead of clamping their arithmetic.\n            this.renderer.framebuffer.clear(0, 0, 0, 0);\n        }\n    }\n\n    /**\n     * Draws a filter using the default rendering process.\n     *\n     * This should be called only by {@link Filter#apply}.\n     * @param filter - The filter to draw.\n     * @param input - The input render target.\n     * @param output - The target to output to.\n     * @param clearMode - Should the output be cleared before rendering to it\n     */\n    applyFilter(filter: Filter, input: RenderTexture, output: RenderTexture, clearMode?: CLEAR_MODES): void\n    {\n        const renderer = this.renderer;\n\n        // Set state before binding, so bindAndClear gets the blend mode.\n        renderer.state.set(filter.state);\n        this.bindAndClear(output, clearMode);\n\n        // set the uniforms..\n        filter.uniforms.uSampler = input;\n        filter.uniforms.filterGlobals = this.globalUniforms;\n\n        // TODO make it so that the order of this does not matter..\n        // because it does at the moment cos of global uniforms.\n        // they need to get resynced\n        renderer.shader.bind(filter);\n\n        // check to see if the filter is a legacy one..\n        filter.legacy = !!filter.program.attributeData.aTextureCoord;\n\n        if (filter.legacy)\n        {\n            this.quadUv.map(input._frame, input.filterFrame);\n\n            renderer.geometry.bind(this.quadUv);\n            renderer.geometry.draw(DRAW_MODES.TRIANGLES);\n        }\n        else\n        {\n            renderer.geometry.bind(this.quad);\n            renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP);\n        }\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {PIXI.Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    calculateSpriteMatrix(outputMatrix: Matrix, sprite: ISpriteMaskTarget): Matrix\n    {\n        const { sourceFrame, destinationFrame } = this.activeState;\n        const { orig } = sprite._texture;\n        const mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0,\n            destinationFrame.height, sourceFrame.x, sourceFrame.y);\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(1.0 / orig.width, 1.0 / orig.height);\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    /** Destroys this Filter System. */\n    destroy(): void\n    {\n        this.renderer = null;\n\n        // Those textures has to be destroyed by RenderTextureSystem or FramebufferSystem\n        this.texturePool.clear(false);\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param minWidth - The minimum width of the render texture in real pixels.\n     * @param minHeight - The minimum height of the render texture in real pixels.\n     * @param resolution - The resolution of the render texture.\n     * @param multisample - Number of samples of the render texture.\n     * @returns - The new render texture.\n     */\n    protected getOptimalFilterTexture(minWidth: number, minHeight: number, resolution = 1,\n        multisample: MSAA_QUALITY = MSAA_QUALITY.NONE): RenderTexture\n    {\n        return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);\n    }\n\n    /**\n     * Gets extra render texture to use inside current filter\n     * To be compliant with older filters, you can use params in any order\n     * @param input - renderTexture from which size and resolution will be copied\n     * @param resolution - override resolution of the renderTexture\n     * @param multisample - number of samples of the renderTexture\n     */\n    getFilterTexture(input?: RenderTexture, resolution?: number, multisample?: MSAA_QUALITY): RenderTexture\n    {\n        if (typeof input === 'number')\n        {\n            const swap = input;\n\n            input = resolution as any;\n            resolution = swap;\n        }\n\n        input = input || this.activeState.renderTexture;\n\n        const filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution,\n            multisample || MSAA_QUALITY.NONE);\n\n        filterTexture.filterFrame = input.filterFrame;\n\n        return filterTexture;\n    }\n\n    /**\n     * Frees a render texture back into the pool.\n     * @param renderTexture - The renderTarget to free\n     */\n    returnFilterTexture(renderTexture: RenderTexture): void\n    {\n        this.texturePool.returnTexture(renderTexture);\n    }\n\n    /** Empties the texture pool. */\n    emptyPool(): void\n    {\n        this.texturePool.clear(true);\n    }\n\n    /** Calls `texturePool.resize()`, affects fullScreen renderTextures. */\n    resize(): void\n    {\n        this.texturePool.setScreenSize(this.renderer.view);\n    }\n\n    /**\n     * @param matrix - first param\n     * @param rect - second param\n     */\n    private transformAABB(matrix: Matrix, rect: Rectangle): void\n    {\n        const lt = tempPoints[0];\n        const lb = tempPoints[1];\n        const rt = tempPoints[2];\n        const rb = tempPoints[3];\n\n        lt.set(rect.left, rect.top);\n        lb.set(rect.left, rect.bottom);\n        rt.set(rect.right, rect.top);\n        rb.set(rect.right, rect.bottom);\n\n        matrix.apply(lt, lt);\n        matrix.apply(lb, lb);\n        matrix.apply(rt, rt);\n        matrix.apply(rb, rb);\n\n        const x0 = Math.min(lt.x, lb.x, rt.x, rb.x);\n        const y0 = Math.min(lt.y, lb.y, rt.y, rb.y);\n        const x1 = Math.max(lt.x, lb.x, rt.x, rb.x);\n        const y1 = Math.max(lt.y, lb.y, rt.y, rb.y);\n\n        rect.x = x0;\n        rect.y = y0;\n        rect.width = x1 - x0;\n        rect.height = y1 - y0;\n    }\n\n    private roundFrame(\n        frame: Rectangle,\n        resolution: number,\n        bindingSourceFrame: Rectangle,\n        bindingDestinationFrame: Rectangle,\n        transform?: Matrix\n    )\n    {\n        if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0)\n        {\n            return;\n        }\n\n        if (transform)\n        {\n            const { a, b, c, d } = transform;\n\n            // Skip if skew/rotation present in matrix, except for multiple of 90° rotation. If rotation\n            // is a multiple of 90°, then either pair of (b,c) or (a,d) will be (0,0).\n            if ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4)\n                && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4))\n            {\n                return;\n            }\n        }\n\n        transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();\n\n        // Get forward transform from world space to screen space\n        transform\n            .translate(-bindingSourceFrame.x, -bindingSourceFrame.y)\n            .scale(\n                bindingDestinationFrame.width / bindingSourceFrame.width,\n                bindingDestinationFrame.height / bindingSourceFrame.height)\n            .translate(bindingDestinationFrame.x, bindingDestinationFrame.y);\n\n        // Convert frame to screen space\n        this.transformAABB(transform, frame);\n\n        // Round frame in screen space\n        frame.ceil(resolution);\n\n        // Project back into world space.\n        this.transformAABB(transform.invert(), frame);\n    }\n}\n\nextensions.add(FilterSystem);\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}