{"ast":null,"code":"import { BLEND_MODES } from '@pixi/constants';\nimport { ExtensionType, extensions } from '@pixi/extensions';\nimport { State } from './State.mjs';\nimport { mapWebGLBlendModesToPixi } from './utils/mapWebGLBlendModesToPixi.mjs';\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nconst _StateSystem = class {\n  constructor() {\n    this.gl = null;\n    this.stateId = 0;\n    this.polygonOffset = 0;\n    this.blendMode = BLEND_MODES.NONE;\n    this._blendEq = false;\n    this.map = [];\n    this.map[BLEND] = this.setBlend;\n    this.map[OFFSET] = this.setOffset;\n    this.map[CULLING] = this.setCullFace;\n    this.map[DEPTH_TEST] = this.setDepthTest;\n    this.map[WINDING] = this.setFrontFace;\n    this.map[DEPTH_MASK] = this.setDepthMask;\n    this.checks = [];\n    this.defaultState = new State();\n    this.defaultState.blend = true;\n  }\n  contextChange(gl) {\n    this.gl = gl;\n    this.blendModes = mapWebGLBlendModesToPixi(gl);\n    this.set(this.defaultState);\n    this.reset();\n  }\n  set(state) {\n    state = state || this.defaultState;\n    if (this.stateId !== state.data) {\n      let diff = this.stateId ^ state.data;\n      let i = 0;\n      while (diff) {\n        if (diff & 1) {\n          this.map[i].call(this, !!(state.data & 1 << i));\n        }\n        diff = diff >> 1;\n        i++;\n      }\n      this.stateId = state.data;\n    }\n    for (let i = 0; i < this.checks.length; i++) {\n      this.checks[i](this, state);\n    }\n  }\n  forceState(state) {\n    state = state || this.defaultState;\n    for (let i = 0; i < this.map.length; i++) {\n      this.map[i].call(this, !!(state.data & 1 << i));\n    }\n    for (let i = 0; i < this.checks.length; i++) {\n      this.checks[i](this, state);\n    }\n    this.stateId = state.data;\n  }\n  setBlend(value) {\n    this.updateCheck(_StateSystem.checkBlendMode, value);\n    this.gl[value ? \"enable\" : \"disable\"](this.gl.BLEND);\n  }\n  setOffset(value) {\n    this.updateCheck(_StateSystem.checkPolygonOffset, value);\n    this.gl[value ? \"enable\" : \"disable\"](this.gl.POLYGON_OFFSET_FILL);\n  }\n  setDepthTest(value) {\n    this.gl[value ? \"enable\" : \"disable\"](this.gl.DEPTH_TEST);\n  }\n  setDepthMask(value) {\n    this.gl.depthMask(value);\n  }\n  setCullFace(value) {\n    this.gl[value ? \"enable\" : \"disable\"](this.gl.CULL_FACE);\n  }\n  setFrontFace(value) {\n    this.gl.frontFace(this.gl[value ? \"CW\" : \"CCW\"]);\n  }\n  setBlendMode(value) {\n    if (value === this.blendMode) {\n      return;\n    }\n    this.blendMode = value;\n    const mode = this.blendModes[value];\n    const gl = this.gl;\n    if (mode.length === 2) {\n      gl.blendFunc(mode[0], mode[1]);\n    } else {\n      gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);\n    }\n    if (mode.length === 6) {\n      this._blendEq = true;\n      gl.blendEquationSeparate(mode[4], mode[5]);\n    } else if (this._blendEq) {\n      this._blendEq = false;\n      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n    }\n  }\n  setPolygonOffset(value, scale) {\n    this.gl.polygonOffset(value, scale);\n  }\n  reset() {\n    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);\n    this.forceState(this.defaultState);\n    this._blendEq = true;\n    this.blendMode = -1;\n    this.setBlendMode(0);\n  }\n  updateCheck(func, value) {\n    const index = this.checks.indexOf(func);\n    if (value && index === -1) {\n      this.checks.push(func);\n    } else if (!value && index !== -1) {\n      this.checks.splice(index, 1);\n    }\n  }\n  static checkBlendMode(system, state) {\n    system.setBlendMode(state.blendMode);\n  }\n  static checkPolygonOffset(system, state) {\n    system.setPolygonOffset(1, state.polygonOffset);\n  }\n  destroy() {\n    this.gl = null;\n  }\n};\nlet StateSystem = _StateSystem;\nStateSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"state\"\n};\nextensions.add(StateSystem);\nexport { StateSystem };","map":{"version":3,"mappings":"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","names":["BLEND","OFFSET","CULLING","DEPTH_TEST","WINDING","DEPTH_MASK","_StateSystem","constructor","gl","stateId","polygonOffset","blendMode","BLEND_MODES","_blendEq","map","checks","State","defaultState","blend","contextChange","mapWebGLBlendModesToPixi","reset","set","state","data","i","diff","call","length","forceState","setBlend","value","setOffset","POLYGON_OFFSET_FILL","setDepthTest","setDepthMask","depthMask","setCullFace","CULL_FACE","setFrontFace","frontFace","setBlendMode","blendModes","blendFunc","mode","blendEquationSeparate","FUNC_ADD","setPolygonOffset","scale","UNPACK_FLIP_Y_WEBGL","updateCheck","func","index","push","splice","checkBlendMode","system","checkPolygonOffset","destroy","StateSystem","extension","type","ExtensionType","name","extensions","add"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/core/src/state/StateSystem.ts"],"sourcesContent":["import { BLEND_MODES } from '@pixi/constants';\nimport { extensions, ExtensionType } from '@pixi/extensions';\nimport { State } from './State';\nimport { mapWebGLBlendModesToPixi } from './utils/mapWebGLBlendModesToPixi';\n\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { IRenderingContext } from '../IRenderer';\nimport type { ISystem } from '../system/ISystem';\n\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * System plugin to the renderer to manage WebGL state machines.\n * @memberof PIXI\n */\nexport class StateSystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'state',\n    };\n\n    /**\n     * State ID\n     * @readonly\n     */\n    public stateId: number;\n\n    /**\n     * Polygon offset\n     * @readonly\n     */\n    public polygonOffset: number;\n\n    /**\n     * Blend mode\n     * @default PIXI.BLEND_MODES.NONE\n     * @readonly\n     */\n    public blendMode: BLEND_MODES;\n\n    /** Whether current blend equation is different */\n    protected _blendEq: boolean;\n\n    /**\n     * GL context\n     * @member {WebGLRenderingContext}\n     * @readonly\n     */\n    protected gl: IRenderingContext;\n\n    protected blendModes: number[][];\n\n    /**\n     * Collection of calls\n     * @member {Function[]}\n     */\n    protected readonly map: Array<(value: boolean) => void>;\n\n    /**\n     * Collection of check calls\n     * @member {Function[]}\n     */\n    protected readonly checks: Array<(system: this, state: State) => void>;\n\n    /**\n     * Default WebGL State\n     * @readonly\n     */\n    protected defaultState: State;\n\n    constructor()\n    {\n        this.gl = null;\n\n        this.stateId = 0;\n        this.polygonOffset = 0;\n        this.blendMode = BLEND_MODES.NONE;\n\n        this._blendEq = false;\n\n        // map functions for when we set state..\n        this.map = [];\n        this.map[BLEND] = this.setBlend;\n        this.map[OFFSET] = this.setOffset;\n        this.map[CULLING] = this.setCullFace;\n        this.map[DEPTH_TEST] = this.setDepthTest;\n        this.map[WINDING] = this.setFrontFace;\n        this.map[DEPTH_MASK] = this.setDepthMask;\n\n        this.checks = [];\n\n        this.defaultState = new State();\n        this.defaultState.blend = true;\n    }\n\n    contextChange(gl: IRenderingContext): void\n    {\n        this.gl = gl;\n\n        this.blendModes = mapWebGLBlendModesToPixi(gl);\n\n        this.set(this.defaultState);\n\n        this.reset();\n    }\n\n    /**\n     * Sets the current state\n     * @param {*} state - The state to set.\n     */\n    set(state: State): void\n    {\n        state = state || this.defaultState;\n\n        // TODO maybe to an object check? ( this.state === state )?\n        if (this.stateId !== state.data)\n        {\n            let diff = this.stateId ^ state.data;\n            let i = 0;\n\n            // order from least to most common\n            while (diff)\n            {\n                if (diff & 1)\n                {\n                    // state change!\n                    this.map[i].call(this, !!(state.data & (1 << i)));\n                }\n\n                diff = diff >> 1;\n                i++;\n            }\n\n            this.stateId = state.data;\n        }\n\n        // based on the above settings we check for specific modes..\n        // for example if blend is active we check and set the blend modes\n        // or of polygon offset is active we check the poly depth.\n        for (let i = 0; i < this.checks.length; i++)\n        {\n            this.checks[i](this, state);\n        }\n    }\n\n    /**\n     * Sets the state, when previous state is unknown.\n     * @param {*} state - The state to set\n     */\n    forceState(state: State): void\n    {\n        state = state || this.defaultState;\n        for (let i = 0; i < this.map.length; i++)\n        {\n            this.map[i].call(this, !!(state.data & (1 << i)));\n        }\n        for (let i = 0; i < this.checks.length; i++)\n        {\n            this.checks[i](this, state);\n        }\n\n        this.stateId = state.data;\n    }\n\n    /**\n     * Sets whether to enable or disable blending.\n     * @param value - Turn on or off WebGl blending.\n     */\n    setBlend(value: boolean): void\n    {\n        this.updateCheck(StateSystem.checkBlendMode, value);\n\n        this.gl[value ? 'enable' : 'disable'](this.gl.BLEND);\n    }\n\n    /**\n     * Sets whether to enable or disable polygon offset fill.\n     * @param value - Turn on or off webgl polygon offset testing.\n     */\n    setOffset(value: boolean): void\n    {\n        this.updateCheck(StateSystem.checkPolygonOffset, value);\n\n        this.gl[value ? 'enable' : 'disable'](this.gl.POLYGON_OFFSET_FILL);\n    }\n\n    /**\n     * Sets whether to enable or disable depth test.\n     * @param value - Turn on or off webgl depth testing.\n     */\n    setDepthTest(value: boolean): void\n    {\n        this.gl[value ? 'enable' : 'disable'](this.gl.DEPTH_TEST);\n    }\n\n    /**\n     * Sets whether to enable or disable depth mask.\n     * @param value - Turn on or off webgl depth mask.\n     */\n    setDepthMask(value: boolean): void\n    {\n        this.gl.depthMask(value);\n    }\n\n    /**\n     * Sets whether to enable or disable cull face.\n     * @param {boolean} value - Turn on or off webgl cull face.\n     */\n    setCullFace(value: boolean): void\n    {\n        this.gl[value ? 'enable' : 'disable'](this.gl.CULL_FACE);\n    }\n\n    /**\n     * Sets the gl front face.\n     * @param {boolean} value - true is clockwise and false is counter-clockwise\n     */\n    setFrontFace(value: boolean): void\n    {\n        this.gl.frontFace(this.gl[value ? 'CW' : 'CCW']);\n    }\n\n    /**\n     * Sets the blend mode.\n     * @param {number} value - The blend mode to set to.\n     */\n    setBlendMode(value: number): void\n    {\n        if (value === this.blendMode)\n        {\n            return;\n        }\n\n        this.blendMode = value;\n\n        const mode = this.blendModes[value];\n        const gl = this.gl;\n\n        if (mode.length === 2)\n        {\n            gl.blendFunc(mode[0], mode[1]);\n        }\n        else\n        {\n            gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);\n        }\n        if (mode.length === 6)\n        {\n            this._blendEq = true;\n            gl.blendEquationSeparate(mode[4], mode[5]);\n        }\n        else if (this._blendEq)\n        {\n            this._blendEq = false;\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n        }\n    }\n\n    /**\n     * Sets the polygon offset.\n     * @param {number} value - the polygon offset\n     * @param {number} scale - the polygon offset scale\n     */\n    setPolygonOffset(value: number, scale: number): void\n    {\n        this.gl.polygonOffset(value, scale);\n    }\n\n    // used\n    /** Resets all the logic and disables the VAOs. */\n    reset(): void\n    {\n        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);\n\n        this.forceState(this.defaultState);\n\n        this._blendEq = true;\n        this.blendMode = -1;\n        this.setBlendMode(0);\n    }\n\n    /**\n     * Checks to see which updates should be checked based on which settings have been activated.\n     *\n     * For example, if blend is enabled then we should check the blend modes each time the state is changed\n     * or if polygon fill is activated then we need to check if the polygon offset changes.\n     * The idea is that we only check what we have too.\n     * @param func - the checking function to add or remove\n     * @param value - should the check function be added or removed.\n     */\n    updateCheck(func: (system: this, state: State) => void, value: boolean): void\n    {\n        const index = this.checks.indexOf(func);\n\n        if (value && index === -1)\n        {\n            this.checks.push(func);\n        }\n        else if (!value && index !== -1)\n        {\n            this.checks.splice(index, 1);\n        }\n    }\n\n    /**\n     * A private little wrapper function that we call to check the blend mode.\n     * @param system - the System to perform the state check on\n     * @param state - the state that the blendMode will pulled from\n     */\n    private static checkBlendMode(system: StateSystem, state: State): void\n    {\n        system.setBlendMode(state.blendMode);\n    }\n\n    /**\n     * A private little wrapper function that we call to check the polygon offset.\n     * @param system - the System to perform the state check on\n     * @param state - the state that the blendMode will pulled from\n     */\n    private static checkPolygonOffset(system: StateSystem, state: State): void\n    {\n        system.setPolygonOffset(1, state.polygonOffset);\n    }\n\n    /**\n     * @ignore\n     */\n    destroy(): void\n    {\n        this.gl = null;\n    }\n}\n\nextensions.add(StateSystem);\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}