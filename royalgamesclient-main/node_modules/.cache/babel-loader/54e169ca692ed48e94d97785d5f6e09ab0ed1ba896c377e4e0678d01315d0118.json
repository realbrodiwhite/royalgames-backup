{"ast":null,"code":"import { Rectangle, utils, RenderTexture, MSAA_QUALITY, ExtensionType, extensions } from '@pixi/core';\nconst TEMP_RECT = new Rectangle();\nconst BYTES_PER_PIXEL = 4;\nconst _Extract = class {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  async image(target, format, quality) {\n    const image = new Image();\n    image.src = await this.base64(target, format, quality);\n    return image;\n  }\n  async base64(target, format, quality) {\n    const canvas = this.canvas(target);\n    if (canvas.toDataURL !== void 0) {\n      return canvas.toDataURL(format, quality);\n    }\n    if (canvas.convertToBlob !== void 0) {\n      const blob = await canvas.convertToBlob({\n        type: format,\n        quality\n      });\n      return await new Promise(resolve => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.readAsDataURL(blob);\n      });\n    }\n    throw new Error(\"Extract.base64() requires ICanvas.toDataURL or ICanvas.convertToBlob to be implemented\");\n  }\n  canvas(target, frame) {\n    const {\n      pixels,\n      width,\n      height,\n      flipY\n    } = this._rawPixels(target, frame);\n    let canvasBuffer = new utils.CanvasRenderTarget(width, height, 1);\n    const canvasData = canvasBuffer.context.getImageData(0, 0, width, height);\n    _Extract.arrayPostDivide(pixels, canvasData.data);\n    canvasBuffer.context.putImageData(canvasData, 0, 0);\n    if (flipY) {\n      const target2 = new utils.CanvasRenderTarget(canvasBuffer.width, canvasBuffer.height, 1);\n      target2.context.scale(1, -1);\n      target2.context.drawImage(canvasBuffer.canvas, 0, -height);\n      canvasBuffer.destroy();\n      canvasBuffer = target2;\n    }\n    return canvasBuffer.canvas;\n  }\n  pixels(target, frame) {\n    const {\n      pixels\n    } = this._rawPixels(target, frame);\n    _Extract.arrayPostDivide(pixels, pixels);\n    return pixels;\n  }\n  _rawPixels(target, frame) {\n    const renderer = this.renderer;\n    let resolution;\n    let flipY = false;\n    let renderTexture;\n    let generated = false;\n    if (target) {\n      if (target instanceof RenderTexture) {\n        renderTexture = target;\n      } else {\n        const multisample = renderer.context.webGLVersion >= 2 ? renderer.multisample : MSAA_QUALITY.NONE;\n        renderTexture = this.renderer.generateTexture(target, {\n          multisample\n        });\n        if (multisample !== MSAA_QUALITY.NONE) {\n          const resolvedTexture = RenderTexture.create({\n            width: renderTexture.width,\n            height: renderTexture.height\n          });\n          renderer.framebuffer.bind(renderTexture.framebuffer);\n          renderer.framebuffer.blit(resolvedTexture.framebuffer);\n          renderer.framebuffer.bind(null);\n          renderTexture.destroy(true);\n          renderTexture = resolvedTexture;\n        }\n        generated = true;\n      }\n    }\n    if (renderTexture) {\n      var _frame;\n      resolution = renderTexture.baseTexture.resolution;\n      frame = (_frame = frame) !== null && _frame !== void 0 ? _frame : renderTexture.frame;\n      flipY = false;\n      renderer.renderTexture.bind(renderTexture);\n    } else {\n      resolution = renderer.resolution;\n      if (!frame) {\n        frame = TEMP_RECT;\n        frame.width = renderer.width;\n        frame.height = renderer.height;\n      }\n      flipY = true;\n      renderer.renderTexture.bind(null);\n    }\n    const width = Math.round(frame.width * resolution);\n    const height = Math.round(frame.height * resolution);\n    const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n    const gl = renderer.gl;\n    gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n    if (generated) {\n      renderTexture.destroy(true);\n    }\n    return {\n      pixels,\n      width,\n      height,\n      flipY\n    };\n  }\n  destroy() {\n    this.renderer = null;\n  }\n  static arrayPostDivide(pixels, out) {\n    for (let i = 0; i < pixels.length; i += 4) {\n      const alpha = out[i + 3] = pixels[i + 3];\n      if (alpha !== 0) {\n        out[i] = Math.round(Math.min(pixels[i] * 255 / alpha, 255));\n        out[i + 1] = Math.round(Math.min(pixels[i + 1] * 255 / alpha, 255));\n        out[i + 2] = Math.round(Math.min(pixels[i + 2] * 255 / alpha, 255));\n      } else {\n        out[i] = pixels[i];\n        out[i + 1] = pixels[i + 1];\n        out[i + 2] = pixels[i + 2];\n      }\n    }\n  }\n};\nlet Extract = _Extract;\nExtract.extension = {\n  name: \"extract\",\n  type: ExtensionType.RendererSystem\n};\nextensions.add(Extract);\nexport { Extract };","map":{"version":3,"mappings":"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","names":["TEMP_RECT","Rectangle","BYTES_PER_PIXEL","_Extract","constructor","renderer","image","target","quality","Image","src","base64","format","toDataURL","convertToBlob","canvas","type","Promise","resolve","FileReader","reader","onload","result","readAsDataURL","blob","Error","frame","pixels","width","height","flipY","canvasBuffer","utils","CanvasRenderTarget","canvasData","getImageData","data","context","target2","scale","drawImage","destroy","_rawPixels","generated","RenderTexture","renderTexture","multisample","webGLVersion","MSAA_QUALITY","NONE","create","bind","framebuffer","blit","resolution","baseTexture","round","Uint8Array","gl","readPixels","Math","x","y","RGBA","UNSIGNED_BYTE","arrayPostDivide","out","i","alpha","Extract","extension","name","ExtensionType","extensions","add"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/extract/src/Extract.ts"],"sourcesContent":["import { extensions, ExtensionType, MSAA_QUALITY, Rectangle, RenderTexture, utils } from '@pixi/core';\n\nimport type { ExtensionMetadata, ICanvas, ISystem, Renderer } from '@pixi/core';\nimport type { DisplayObject } from '@pixi/display';\n\nconst TEMP_RECT = new Rectangle();\nconst BYTES_PER_PIXEL = 4;\n\n/**\n * This class provides renderer-specific plugins for exporting content from a renderer.\n * For instance, these plugins can be used for saving an Image, Canvas element or for exporting the raw image data (pixels).\n *\n * Do not instantiate these plugins directly. It is available from the `renderer.extract` property.\n * @example\n * import { Application, Graphics } from 'pixi.js';\n *\n * // Create a new application (extract will be auto-added to renderer)\n * const app = new Application();\n *\n * // Draw a red circle\n * const graphics = new Graphics()\n *     .beginFill(0xFF0000)\n *     .drawCircle(0, 0, 50);\n *\n * // Render the graphics as an HTMLImageElement\n * const image = await app.renderer.extract.image(graphics);\n * document.body.appendChild(image);\n * @memberof PIXI\n */\n\nexport class Extract implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'extract',\n        type: ExtensionType.RendererSystem,\n    };\n\n    private renderer: Renderer;\n\n    /**\n     * @param renderer - A reference to the current renderer\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * Will return a HTML Image of the target\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param format - Image format, e.g. \"image/jpeg\" or \"image/webp\".\n     * @param quality - JPEG or Webp compression from 0 to 1. Default is 0.92.\n     * @returns - HTML Image of the target\n     */\n    public async image(target: DisplayObject | RenderTexture, format?: string, quality?: number): Promise<HTMLImageElement>\n    {\n        const image = new Image();\n\n        image.src = await this.base64(target, format, quality);\n\n        return image;\n    }\n\n    /**\n     * Will return a base64 encoded string of this target. It works by calling\n     *  `Extract.getCanvas` and then running toDataURL on that.\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param format - Image format, e.g. \"image/jpeg\" or \"image/webp\".\n     * @param quality - JPEG or Webp compression from 0 to 1. Default is 0.92.\n     * @returns - A base64 encoded string of the texture.\n     */\n    public async base64(target: DisplayObject | RenderTexture, format?: string, quality?: number): Promise<string>\n    {\n        const canvas = this.canvas(target);\n\n        if (canvas.toDataURL !== undefined)\n        {\n            return canvas.toDataURL(format, quality);\n        }\n        if (canvas.convertToBlob !== undefined)\n        {\n            const blob = await canvas.convertToBlob({ type: format, quality });\n\n            return await new Promise<string>((resolve) =>\n            {\n                const reader = new FileReader();\n\n                reader.onload = () => resolve(reader.result as string);\n                reader.readAsDataURL(blob);\n            });\n        }\n\n        throw new Error('Extract.base64() requires ICanvas.toDataURL or ICanvas.convertToBlob to be implemented');\n    }\n\n    /**\n     * Creates a Canvas element, renders this target to it and then returns it.\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param frame - The frame the extraction is restricted to.\n     * @returns - A Canvas element with the texture rendered on.\n     */\n    public canvas(target?: DisplayObject | RenderTexture, frame?: Rectangle): ICanvas\n    {\n        const { pixels, width, height, flipY } = this._rawPixels(target, frame);\n\n        let canvasBuffer = new utils.CanvasRenderTarget(width, height, 1);\n\n        // Add the pixels to the canvas\n        const canvasData = canvasBuffer.context.getImageData(0, 0, width, height);\n\n        Extract.arrayPostDivide(pixels, canvasData.data);\n\n        canvasBuffer.context.putImageData(canvasData, 0, 0);\n\n        // Flipping pixels\n        if (flipY)\n        {\n            const target = new utils.CanvasRenderTarget(canvasBuffer.width, canvasBuffer.height, 1);\n\n            target.context.scale(1, -1);\n\n            // We can't render to itself because we should be empty before render.\n            target.context.drawImage(canvasBuffer.canvas, 0, -height);\n\n            canvasBuffer.destroy();\n            canvasBuffer = target;\n        }\n\n        // Send the canvas back\n        return canvasBuffer.canvas;\n    }\n\n    /**\n     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n     * order, with integer values between 0 and 255 (included).\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param frame - The frame the extraction is restricted to.\n     * @returns - One-dimensional array containing the pixel data of the entire texture\n     */\n    public pixels(target?: DisplayObject | RenderTexture, frame?: Rectangle): Uint8Array\n    {\n        const { pixels } = this._rawPixels(target, frame);\n\n        Extract.arrayPostDivide(pixels, pixels);\n\n        return pixels;\n    }\n\n    private _rawPixels(target?: DisplayObject | RenderTexture, frame?: Rectangle): {\n        pixels: Uint8Array, width: number, height: number, flipY: boolean,\n    }\n    {\n        const renderer = this.renderer;\n        let resolution;\n        let flipY = false;\n        let renderTexture;\n        let generated = false;\n\n        if (target)\n        {\n            if (target instanceof RenderTexture)\n            {\n                renderTexture = target;\n            }\n            else\n            {\n                const multisample = renderer.context.webGLVersion >= 2 ? renderer.multisample : MSAA_QUALITY.NONE;\n\n                renderTexture = this.renderer.generateTexture(target, { multisample });\n\n                if (multisample !== MSAA_QUALITY.NONE)\n                {\n                    // Resolve the multisampled texture to a non-multisampled texture\n                    const resolvedTexture = RenderTexture.create({\n                        width: renderTexture.width,\n                        height: renderTexture.height,\n                    });\n\n                    renderer.framebuffer.bind(renderTexture.framebuffer);\n                    renderer.framebuffer.blit(resolvedTexture.framebuffer);\n                    renderer.framebuffer.bind(null);\n\n                    renderTexture.destroy(true);\n                    renderTexture = resolvedTexture;\n                }\n\n                generated = true;\n            }\n        }\n\n        if (renderTexture)\n        {\n            resolution = renderTexture.baseTexture.resolution;\n            frame = frame ?? renderTexture.frame;\n            flipY = false;\n            renderer.renderTexture.bind(renderTexture);\n        }\n        else\n        {\n            resolution = renderer.resolution;\n\n            if (!frame)\n            {\n                frame = TEMP_RECT;\n                frame.width = renderer.width;\n                frame.height = renderer.height;\n            }\n\n            flipY = true;\n            renderer.renderTexture.bind(null);\n        }\n\n        const width = Math.round(frame.width * resolution);\n        const height = Math.round(frame.height * resolution);\n\n        const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n\n        // Read pixels to the array\n        const gl = renderer.gl;\n\n        gl.readPixels(\n            Math.round(frame.x * resolution),\n            Math.round(frame.y * resolution),\n            width,\n            height,\n            gl.RGBA,\n            gl.UNSIGNED_BYTE,\n            pixels\n        );\n\n        if (generated)\n        {\n            renderTexture.destroy(true);\n        }\n\n        return { pixels, width, height, flipY };\n    }\n\n    /** Destroys the extract. */\n    public destroy(): void\n    {\n        this.renderer = null;\n    }\n\n    /**\n     * Takes premultiplied pixel data and produces regular pixel data\n     * @private\n     * @param pixels - array of pixel data\n     * @param out - output array\n     */\n    static arrayPostDivide(\n        pixels: number[] | Uint8Array | Uint8ClampedArray, out: number[] | Uint8Array | Uint8ClampedArray\n    ): void\n    {\n        for (let i = 0; i < pixels.length; i += 4)\n        {\n            const alpha = out[i + 3] = pixels[i + 3];\n\n            if (alpha !== 0)\n            {\n                out[i] = Math.round(Math.min(pixels[i] * 255.0 / alpha, 255.0));\n                out[i + 1] = Math.round(Math.min(pixels[i + 1] * 255.0 / alpha, 255.0));\n                out[i + 2] = Math.round(Math.min(pixels[i + 2] * 255.0 / alpha, 255.0));\n            }\n            else\n            {\n                out[i] = pixels[i];\n                out[i + 1] = pixels[i + 1];\n                out[i + 2] = pixels[i + 2];\n            }\n        }\n    }\n}\n\nextensions.add(Extract);\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}