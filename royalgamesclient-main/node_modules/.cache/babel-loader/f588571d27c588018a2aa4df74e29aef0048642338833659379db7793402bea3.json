{"ast":null,"code":"import { TARGETS } from '@pixi/constants';\nimport { AbstractMultiResource } from './AbstractMultiResource.mjs';\nconst _CubeResource = class extends AbstractMultiResource {\n  constructor(source, options) {\n    const {\n      width,\n      height,\n      autoLoad,\n      linkBaseTexture\n    } = options || {};\n    if (source && source.length !== _CubeResource.SIDES) {\n      throw new Error(\"Invalid length. Got \".concat(source.length, \", expected 6\"));\n    }\n    super(6, {\n      width,\n      height\n    });\n    for (let i = 0; i < _CubeResource.SIDES; i++) {\n      this.items[i].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;\n    }\n    this.linkBaseTexture = linkBaseTexture !== false;\n    if (source) {\n      this.initFromArray(source, options);\n    }\n    if (autoLoad !== false) {\n      this.load();\n    }\n  }\n  bind(baseTexture) {\n    super.bind(baseTexture);\n    baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;\n  }\n  addBaseTextureAt(baseTexture, index, linkBaseTexture) {\n    if (linkBaseTexture === void 0) {\n      linkBaseTexture = this.linkBaseTexture;\n    }\n    if (!this.items[index]) {\n      throw new Error(\"Index \".concat(index, \" is out of bounds\"));\n    }\n    if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {\n      if (baseTexture.resource) {\n        this.addResourceAt(baseTexture.resource, index);\n      } else {\n        throw new Error(\"CubeResource does not support copying of renderTexture.\");\n      }\n    } else {\n      baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index;\n      baseTexture.parentTextureArray = this.baseTexture;\n      this.items[index] = baseTexture;\n    }\n    if (baseTexture.valid && !this.valid) {\n      this.resize(baseTexture.realWidth, baseTexture.realHeight);\n    }\n    this.items[index] = baseTexture;\n    return this;\n  }\n  upload(renderer, _baseTexture, glTexture) {\n    const dirty = this.itemDirtyIds;\n    for (let i = 0; i < _CubeResource.SIDES; i++) {\n      const side = this.items[i];\n      if (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) {\n        if (side.valid && side.resource) {\n          side.resource.upload(renderer, side, glTexture);\n          dirty[i] = side.dirtyId;\n        } else if (dirty[i] < -1) {\n          renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);\n          dirty[i] = -1;\n        }\n      }\n    }\n    return true;\n  }\n  static test(source) {\n    return Array.isArray(source) && source.length === _CubeResource.SIDES;\n  }\n};\nlet CubeResource = _CubeResource;\nCubeResource.SIDES = 6;\nexport { CubeResource };","map":{"version":3,"mappings":";;AAwBO,MAAMA,gBAAN,cAA2BC,qBAClC;EAmBIC,YAAYC,QAA2CC,OACvD;IACI,MAAM;MAAEC,KAAO;MAAAC;MAAQC,QAAU;MAAAC;IAAA,IAAoBJ,WAAW,EAAC;IAEjE,IAAID,MAAU,WAAOM,MAAW,mBAAaC,KAC7C;MACI,MAAM,IAAIC,oCAA6BR,OAAOM,MAAoB;IAAA;IAGtE,MAAM,CAAG;MAAEJ,KAAO;MAAAC;IAAA,CAAQ;IAE1B,SAASM,CAAI,MAAGA,CAAI,iBAAaF,OAAOE,CACxC;MACI,KAAKC,KAAM,IAAGC,MAAS,WAAQC,2BAA8B;IAAA;IAGjE,KAAKP,kBAAkBA,eAAoB;IAE3C,IAAIL,MACJ;MACS,mBAAcA,QAAQC,OAAO;IAAA;IAGtC,IAAIG,aAAa,KACjB;MACI,KAAKS,IAAK;IAAA;EACd;EAOJC,KAAKC,WACL;IACI,MAAMD,KAAKC,WAAW;IAEtBA,YAAYJ,SAASK,OAAQ;EAAA;EAGjCC,iBAAiBF,WAA0B,SAAeV,eAC1D;IACI,IAAIA,oBAAoB,KACxB;MACIA,kBAAkB,IAAK;IAAA;IAGvB,KAAC,IAAK,OAAMa,KAChB;MACU,UAAIV,KAAM,iBAASU,KAAwB;IAAA;IAGjD,KAAC,IAAK,oBACHH,WAAY,uBACZI,MAAO,MAAKJ,WAAY,YAAW,CAAE,UAAS,CACrD;MAEI,IAAIA,YAAYK,QAChB;QACS,mBAAcL,WAAY,WAAUG,KAAK;MAAA,CAGlD;QACU,UAAIV,+DAA+D;MAAA;IAC7E,CAGJ;MAEgBO,qBAASC,QAAQJ,2BAA8B;MAC3DG,YAAYM,qBAAqB,IAAK;MAEtC,KAAKX,MAAMQ,KAAS;IAAA;IAGxB,IAAIH,WAAY,UAAS,CAAC,KAAKO,KAC/B;MACI,KAAKC,MAAO,aAAYC,SAAW,cAAYC,UAAU;IAAA;IAG7D,KAAKf,MAAMQ,KAAS;IAEb;EAAA;EAUXQ,OAAOC,QAAoB,gBAA2BC,SACtD;IACI,MAAMC,QAAQ,IAAK;IAEnB,SAASpB,CAAI,MAAGA,CAAI,iBAAaF,OAAOE,CACxC;MACU,aAAO,KAAKC,KAAM;MAExB,IAAImB,MAAMpB,CAAK,SAAKqB,WAAWF,SAAU,WAAUG,aAAaD,OAChE;QACQ,SAAKR,KAAS,SAAKF,QACvB;UACIY,KAAKZ,QAAS,QAAOO,QAAU,QAAMC,SAAS;UAC9CC,MAAMpB,KAAKuB,IAAK;QAAA,CACpB,UACSH,KAAM,MAAK,CACpB;UAGIF,SAASM,GAAGC,UAAW,MAAKvB,MAAQ,KAChCiB,UAAUO,cACV,eAAaX,SACb,eAAaC,YACb,CACA,eAAaW,MACb,YAAUC,MACV,IAAI;UACRR,MAAMpB,CAAK;QAAA;MACf;IACJ;IAGG;EAAA;EAWX,OAAO6B,KAAKtC,MACZ;IACI,OAAOuC,MAAMC,OAAQ,OAAM,CAAK,WAAOlC,WAAWT,aAAa;EAAA;AAEvE;AA/JO,IAAM4C,YAAN;AAAMA,aAoJFlC,KAAQ","names":["_CubeResource","AbstractMultiResource","constructor","source","options","width","height","autoLoad","linkBaseTexture","length","SIDES","Error","i","items","target","TEXTURE_CUBE_MAP_POSITIVE_X","load","bind","baseTexture","TARGETS","addBaseTextureAt","index","Object","resource","parentTextureArray","valid","resize","realWidth","realHeight","upload","renderer","glTexture","dirty","dirtyId","_baseTexture","side","gl","texImage2D","internalFormat","format","type","test","Array","isArray","CubeResource"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/core/src/textures/resources/CubeResource.ts"],"sourcesContent":["import { TARGETS } from '@pixi/constants';\nimport { AbstractMultiResource } from './AbstractMultiResource';\n\nimport type { ISize } from '@pixi/math';\nimport type { ArrayFixed } from '@pixi/utils';\nimport type { Renderer } from '../../Renderer';\nimport type { BaseTexture } from '../BaseTexture';\nimport type { GLTexture } from '../GLTexture';\nimport type { Resource } from './Resource';\n\n/** Constructor options for CubeResource */\nexport interface ICubeResourceOptions extends ISize\n{\n    /** Whether to auto-load resources */\n    autoLoad?: boolean;\n\n    /** In case BaseTextures are supplied, whether to copy them or use. */\n    linkBaseTexture?: boolean;\n}\n\n/**\n * Resource for a CubeTexture which contains six resources.\n * @memberof PIXI\n */\nexport class CubeResource extends AbstractMultiResource\n{\n    items: ArrayFixed<BaseTexture, 6>;\n\n    /**\n     * In case BaseTextures are supplied, whether to use same resource or bind baseTexture itself.\n     * @protected\n     */\n    linkBaseTexture: boolean;\n\n    /**\n     * @param {Array<string|PIXI.Resource>} [source] - Collection of URLs or resources\n     *        to use as the sides of the cube.\n     * @param options - ImageResource options\n     * @param {number} [options.width] - Width of resource\n     * @param {number} [options.height] - Height of resource\n     * @param {number} [options.autoLoad=true] - Whether to auto-load resources\n     * @param {number} [options.linkBaseTexture=true] - In case BaseTextures are supplied,\n     *   whether to copy them or use\n     */\n    constructor(source?: ArrayFixed<string | Resource, 6>, options?: ICubeResourceOptions)\n    {\n        const { width, height, autoLoad, linkBaseTexture } = options || {};\n\n        if (source && source.length !== CubeResource.SIDES)\n        {\n            throw new Error(`Invalid length. Got ${source.length}, expected 6`);\n        }\n\n        super(6, { width, height });\n\n        for (let i = 0; i < CubeResource.SIDES; i++)\n        {\n            this.items[i].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;\n        }\n\n        this.linkBaseTexture = linkBaseTexture !== false;\n\n        if (source)\n        {\n            this.initFromArray(source, options);\n        }\n\n        if (autoLoad !== false)\n        {\n            this.load();\n        }\n    }\n\n    /**\n     * Add binding.\n     * @param baseTexture - parent base texture\n     */\n    bind(baseTexture: BaseTexture): void\n    {\n        super.bind(baseTexture);\n\n        baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;\n    }\n\n    addBaseTextureAt(baseTexture: BaseTexture, index: number, linkBaseTexture?: boolean): this\n    {\n        if (linkBaseTexture === undefined)\n        {\n            linkBaseTexture = this.linkBaseTexture;\n        }\n\n        if (!this.items[index])\n        {\n            throw new Error(`Index ${index} is out of bounds`);\n        }\n\n        if (!this.linkBaseTexture\n            || baseTexture.parentTextureArray\n            || Object.keys(baseTexture._glTextures).length > 0)\n        {\n            // copy mode\n            if (baseTexture.resource)\n            {\n                this.addResourceAt(baseTexture.resource, index);\n            }\n            else\n            {\n                throw new Error(`CubeResource does not support copying of renderTexture.`);\n            }\n        }\n        else\n        {\n            // link mode, the difficult one!\n            baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index;\n            baseTexture.parentTextureArray = this.baseTexture;\n\n            this.items[index] = baseTexture;\n        }\n\n        if (baseTexture.valid && !this.valid)\n        {\n            this.resize(baseTexture.realWidth, baseTexture.realHeight);\n        }\n\n        this.items[index] = baseTexture;\n\n        return this;\n    }\n\n    /**\n     * Upload the resource\n     * @param renderer\n     * @param _baseTexture\n     * @param glTexture\n     * @returns {boolean} true is success\n     */\n    upload(renderer: Renderer, _baseTexture: BaseTexture, glTexture: GLTexture): boolean\n    {\n        const dirty = this.itemDirtyIds;\n\n        for (let i = 0; i < CubeResource.SIDES; i++)\n        {\n            const side = this.items[i];\n\n            if (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId)\n            {\n                if (side.valid && side.resource)\n                {\n                    side.resource.upload(renderer, side, glTexture);\n                    dirty[i] = side.dirtyId;\n                }\n                else if (dirty[i] < -1)\n                {\n                    // either item is not valid yet, either its a renderTexture\n                    // allocate the memory\n                    renderer.gl.texImage2D(side.target, 0,\n                        glTexture.internalFormat,\n                        _baseTexture.realWidth,\n                        _baseTexture.realHeight,\n                        0,\n                        _baseTexture.format,\n                        glTexture.type,\n                        null);\n                    dirty[i] = -1;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /** Number of texture sides to store for CubeResources. */\n    static SIDES = 6;\n\n    /**\n     * Used to auto-detect the type of resource.\n     * @param {*} source - The source object\n     * @returns {boolean} `true` if source is an array of 6 elements\n     */\n    static test(source: unknown): source is ArrayFixed<string | Resource, 6>\n    {\n        return Array.isArray(source) && source.length === CubeResource.SIDES;\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}