{"ast":null,"code":"import { ExtensionType, extensions } from '@pixi/extensions';\nimport { settings } from '@pixi/settings';\nimport { AbstractMaskSystem } from './AbstractMaskSystem.mjs';\nclass StencilSystem extends AbstractMaskSystem {\n  constructor(renderer) {\n    super(renderer);\n    this.glConst = settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST;\n  }\n  getStackLength() {\n    const maskData = this.maskStack[this.maskStack.length - 1];\n    if (maskData) {\n      return maskData._stencilCounter;\n    }\n    return 0;\n  }\n  push(maskData) {\n    const maskObject = maskData.maskObject;\n    const {\n      gl\n    } = this.renderer;\n    const prevMaskCount = maskData._stencilCounter;\n    if (prevMaskCount === 0) {\n      this.renderer.framebuffer.forceStencil();\n      gl.clearStencil(0);\n      gl.clear(gl.STENCIL_BUFFER_BIT);\n      gl.enable(gl.STENCIL_TEST);\n    }\n    maskData._stencilCounter++;\n    const colorMask = maskData._colorMask;\n    if (colorMask !== 0) {\n      maskData._colorMask = 0;\n      gl.colorMask(false, false, false, false);\n    }\n    gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295);\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);\n    maskObject.renderable = true;\n    maskObject.render(this.renderer);\n    this.renderer.batch.flush();\n    maskObject.renderable = false;\n    if (colorMask !== 0) {\n      maskData._colorMask = colorMask;\n      gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);\n    }\n    this._useCurrent();\n  }\n  pop(maskObject) {\n    const gl = this.renderer.gl;\n    if (this.getStackLength() === 0) {\n      gl.disable(gl.STENCIL_TEST);\n    } else {\n      const maskData = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;\n      const colorMask = maskData ? maskData._colorMask : 15;\n      if (colorMask !== 0) {\n        maskData._colorMask = 0;\n        gl.colorMask(false, false, false, false);\n      }\n      gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);\n      maskObject.renderable = true;\n      maskObject.render(this.renderer);\n      this.renderer.batch.flush();\n      maskObject.renderable = false;\n      if (colorMask !== 0) {\n        maskData._colorMask = colorMask;\n        gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);\n      }\n      this._useCurrent();\n    }\n  }\n  _useCurrent() {\n    const gl = this.renderer.gl;\n    gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295);\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n  }\n}\nStencilSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"stencil\"\n};\nextensions.add(StencilSystem);\nexport { StencilSystem };","map":{"version":3,"mappings":";;;AAYO,MAAMA,sBAAsBC,kBACnC;EAUIC,YAAYC,QACZ;IACI,MAAMA,QAAQ;IAEd,KAAKC,OAAU,YAASC,OAAQ,2BAA2B;EAAA;EAG/DC,cACAA;IACI,MAAMC,QAAW,QAAKC,SAAU,MAAKA,UAAUC,MAAS;IAExD,IAAIF,QACJ;MACI,OAAOA,QAAS;IAAA;IAGb;EAAA;EAOXG,KAAKH,QACL;IACI,MAAMI,aAAaJ,QAAS;IACtB;MAAEK;IAAA,IAAO,IAAK;IACpB,MAAMC,gBAAgBN,QAAS;IAE/B,IAAIM,kBAAkB,CACtB;MAES,cAASC,YAAYC,YAAa;MACvCH,GAAGI,aAAa,CAAC;MACdJ,SAAMA,GAAGK,kBAAkB;MAC3BL,UAAOA,GAAGM,YAAY;IAAA;IAGpBX;IAET,MAAMY,YAAYZ,QAAS;IAE3B,IAAIY,cAAc,CAClB;MACIZ,SAASa,UAAa;MACtBR,GAAGO,SAAU,QAAO,KAAO,SAAO,KAAK;IAAA;IAI3CP,GAAGS,WAAY,IAAGC,KAAO,iBAAe,UAAU;IAClDV,GAAGW,UAAUX,EAAG,OAAMA,EAAG,OAAMA,GAAGY,IAAI;IAEtCb,WAAWc,UAAa;IACbd,kBAAO,KAAKR,QAAQ;IAC1B,cAASuB,MAAMC,KAAM;IAC1BhB,WAAWc,UAAa;IAExB,IAAIN,cAAc,CAClB;MACIZ,SAASa,UAAa;MACtBR,GAAGO,SACE,cAAY,CAAO,SACnB,CAAYA,mBAAO,CACnB,eAAY,CAAO,SACnB,CAAYA,mBAAO,CACxB;IAAA;IAGJ,KAAKS,WAAY;EAAA;EAOrBC,IAAIlB,UACJ;IACU,WAAK,KAAKR,QAAS;IAErB,SAAKG,cAAe,OAAM,CAC9B;MAEOM,WAAQA,GAAGM,YAAY;IAAA,CAG9B;MACU,iBAAW,IAAK,WAAUT,MAAW,SAAI,KAAKD,SAAU,MAAKA,SAAU,UAAS,CAAK;MACrF,kBAAYD,QAAW,YAASa,UAAa;MAEnD,IAAID,cAAc,CAClB;QACIZ,SAASa,UAAa;QACtBR,GAAGO,SAAU,QAAO,KAAO,SAAO,KAAK;MAAA;MAI3CP,GAAGW,UAAUX,EAAG,OAAMA,EAAG,OAAMA,GAAGkB,IAAI;MAEtCnB,WAAWc,UAAa;MACbd,kBAAO,KAAKR,QAAQ;MAC1B,cAASuB,MAAMC,KAAM;MAC1BhB,WAAWc,UAAa;MAExB,IAAIN,cAAc,CAClB;QACIZ,SAASa,UAAa;QACtBR,GAAGO,SACE,cAAY,CAAS,SACrB,CAAYA,mBAAS,CACrB,eAAY,CAAS,SACrB,CAAYA,mBAAS,CAC1B;MAAA;MAGJ,KAAKS,WAAY;IAAA;EACrB;EAOJA,WACAA;IACU,WAAK,KAAKzB,QAAS;IAEzBS,GAAGS,YAAYT,EAAG,QAAO,IAAK,mBAAkB,UAAU;IAC1DA,GAAGW,UAAUX,EAAG,OAAMA,EAAG,OAAMA,GAAGmB,IAAI;EAAA;AAE9C;AA5Ia/B,cAGFgC,SAA+B;EAClCC,MAAMC,aAAc;EACpBC,IAAM;AACV;AAwIJC,WAAWC,IAAIrC,aAAa","names":["StencilSystem","AbstractMaskSystem","constructor","renderer","glConst","ADAPTER","getStackLength","maskData","maskStack","length","push","maskObject","gl","prevMaskCount","framebuffer","forceStencil","clearStencil","STENCIL_BUFFER_BIT","STENCIL_TEST","colorMask","_colorMask","stencilFunc","EQUAL","stencilOp","INCR","renderable","batch","flush","_useCurrent","pop","DECR","KEEP","extension","type","ExtensionType","name","extensions","add"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/core/src/mask/StencilSystem.ts"],"sourcesContent":["import { extensions, ExtensionType } from '@pixi/extensions';\nimport { settings } from '@pixi/settings';\nimport { AbstractMaskSystem } from './AbstractMaskSystem';\n\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { Renderer } from '../Renderer';\nimport type { IMaskTarget, MaskData } from './MaskData';\n\n/**\n * System plugin to the renderer to manage stencils (used for masks).\n * @memberof PIXI\n */\nexport class StencilSystem extends AbstractMaskSystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'stencil',\n    };\n\n    /**\n     * @param renderer - The renderer this System works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        this.glConst = settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST;\n    }\n\n    getStackLength(): number\n    {\n        const maskData = this.maskStack[this.maskStack.length - 1];\n\n        if (maskData)\n        {\n            return maskData._stencilCounter;\n        }\n\n        return 0;\n    }\n\n    /**\n     * Applies the Mask and adds it to the current stencil stack.\n     * @param maskData - The mask data\n     */\n    push(maskData: MaskData): void\n    {\n        const maskObject = maskData.maskObject;\n        const { gl } = this.renderer;\n        const prevMaskCount = maskData._stencilCounter;\n\n        if (prevMaskCount === 0)\n        {\n            // force use stencil texture in current framebuffer\n            this.renderer.framebuffer.forceStencil();\n            gl.clearStencil(0);\n            gl.clear(gl.STENCIL_BUFFER_BIT);\n            gl.enable(gl.STENCIL_TEST);\n        }\n\n        maskData._stencilCounter++;\n\n        const colorMask = maskData._colorMask;\n\n        if (colorMask !== 0)\n        {\n            maskData._colorMask = 0;\n            gl.colorMask(false, false, false, false);\n        }\n\n        // Increment the reference stencil value where the new mask overlaps with the old ones.\n        gl.stencilFunc(gl.EQUAL, prevMaskCount, 0xFFFFFFFF);\n        gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);\n\n        maskObject.renderable = true;\n        maskObject.render(this.renderer);\n        this.renderer.batch.flush();\n        maskObject.renderable = false;\n\n        if (colorMask !== 0)\n        {\n            maskData._colorMask = colorMask;\n            gl.colorMask(\n                (colorMask & 1) !== 0,\n                (colorMask & 2) !== 0,\n                (colorMask & 4) !== 0,\n                (colorMask & 8) !== 0\n            );\n        }\n\n        this._useCurrent();\n    }\n\n    /**\n     * Pops stencil mask. MaskData is already removed from stack\n     * @param {PIXI.DisplayObject} maskObject - object of popped mask data\n     */\n    pop(maskObject: IMaskTarget): void\n    {\n        const gl = this.renderer.gl;\n\n        if (this.getStackLength() === 0)\n        {\n            // the stack is empty!\n            gl.disable(gl.STENCIL_TEST);\n        }\n        else\n        {\n            const maskData = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;\n            const colorMask = maskData ? maskData._colorMask : 0xf;\n\n            if (colorMask !== 0)\n            {\n                maskData._colorMask = 0;\n                gl.colorMask(false, false, false, false);\n            }\n\n            // Decrement the reference stencil value where the popped mask overlaps with the other ones\n            gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);\n\n            maskObject.renderable = true;\n            maskObject.render(this.renderer);\n            this.renderer.batch.flush();\n            maskObject.renderable = false;\n\n            if (colorMask !== 0)\n            {\n                maskData._colorMask = colorMask;\n                gl.colorMask(\n                    (colorMask & 0x1) !== 0,\n                    (colorMask & 0x2) !== 0,\n                    (colorMask & 0x4) !== 0,\n                    (colorMask & 0x8) !== 0\n                );\n            }\n\n            this._useCurrent();\n        }\n    }\n\n    /**\n     * Setup renderer to use the current stencil data.\n     * @private\n     */\n    _useCurrent(): void\n    {\n        const gl = this.renderer.gl;\n\n        gl.stencilFunc(gl.EQUAL, this.getStackLength(), 0xFFFFFFFF);\n        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n    }\n}\n\nextensions.add(StencilSystem);\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}