{"ast":null,"code":"import { ENV, BUFFER_TYPE } from '@pixi/constants';\nimport { ExtensionType, extensions } from '@pixi/extensions';\nimport { settings } from '@pixi/settings';\nconst byteSizeMap = {\n  5126: 4,\n  5123: 2,\n  5121: 1\n};\nclass GeometrySystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this._activeGeometry = null;\n    this._activeVao = null;\n    this.hasVao = true;\n    this.hasInstance = true;\n    this.canUseUInt32ElementIndex = false;\n    this.managedGeometries = {};\n  }\n  contextChange() {\n    this.disposeAll(true);\n    const gl = this.gl = this.renderer.gl;\n    const context = this.renderer.context;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n    if (context.webGLVersion !== 2) {\n      let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;\n      if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {\n        nativeVaoExtension = null;\n      }\n      if (nativeVaoExtension) {\n        gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();\n        gl.bindVertexArray = vao => nativeVaoExtension.bindVertexArrayOES(vao);\n        gl.deleteVertexArray = vao => nativeVaoExtension.deleteVertexArrayOES(vao);\n      } else {\n        this.hasVao = false;\n        gl.createVertexArray = () => null;\n        gl.bindVertexArray = () => null;\n        gl.deleteVertexArray = () => null;\n      }\n    }\n    if (context.webGLVersion !== 2) {\n      const instanceExt = gl.getExtension(\"ANGLE_instanced_arrays\");\n      if (instanceExt) {\n        gl.vertexAttribDivisor = (a, b) => instanceExt.vertexAttribDivisorANGLE(a, b);\n        gl.drawElementsInstanced = (a, b, c, d, e) => instanceExt.drawElementsInstancedANGLE(a, b, c, d, e);\n        gl.drawArraysInstanced = (a, b, c, d) => instanceExt.drawArraysInstancedANGLE(a, b, c, d);\n      } else {\n        this.hasInstance = false;\n      }\n    }\n    this.canUseUInt32ElementIndex = context.webGLVersion === 2 || !!context.extensions.uint32ElementIndex;\n  }\n  bind(geometry, shader) {\n    shader = shader || this.renderer.shader.shader;\n    const {\n      gl\n    } = this;\n    let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    let incRefCount = false;\n    if (!vaos) {\n      this.managedGeometries[geometry.id] = geometry;\n      geometry.disposeRunner.add(this);\n      geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};\n      incRefCount = true;\n    }\n    const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);\n    this._activeGeometry = geometry;\n    if (this._activeVao !== vao) {\n      this._activeVao = vao;\n      if (this.hasVao) {\n        gl.bindVertexArray(vao);\n      } else {\n        this.activateVao(geometry, shader.program);\n      }\n    }\n    this.updateBuffers();\n  }\n  reset() {\n    this.unbind();\n  }\n  updateBuffers() {\n    const geometry = this._activeGeometry;\n    const bufferSystem = this.renderer.buffer;\n    for (let i = 0; i < geometry.buffers.length; i++) {\n      const buffer = geometry.buffers[i];\n      bufferSystem.update(buffer);\n    }\n  }\n  checkCompatibility(geometry, program) {\n    const geometryAttributes = geometry.attributes;\n    const shaderAttributes = program.attributeData;\n    for (const j in shaderAttributes) {\n      if (!geometryAttributes[j]) {\n        throw new Error(\"shader and geometry incompatible, geometry missing the \\\"\".concat(j, \"\\\" attribute\"));\n      }\n    }\n  }\n  getSignature(geometry, program) {\n    const attribs = geometry.attributes;\n    const shaderAttributes = program.attributeData;\n    const strings = [\"g\", geometry.id];\n    for (const i in attribs) {\n      if (shaderAttributes[i]) {\n        strings.push(i, shaderAttributes[i].location);\n      }\n    }\n    return strings.join(\"-\");\n  }\n  initGeometryVao(geometry, shader) {\n    let incRefCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const gl = this.gl;\n    const CONTEXT_UID = this.CONTEXT_UID;\n    const bufferSystem = this.renderer.buffer;\n    const program = shader.program;\n    if (!program.glPrograms[CONTEXT_UID]) {\n      this.renderer.shader.generateProgram(shader);\n    }\n    this.checkCompatibility(geometry, program);\n    const signature = this.getSignature(geometry, program);\n    const vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    let vao = vaoObjectHash[signature];\n    if (vao) {\n      vaoObjectHash[program.id] = vao;\n      return vao;\n    }\n    const buffers = geometry.buffers;\n    const attributes = geometry.attributes;\n    const tempStride = {};\n    const tempStart = {};\n    for (const j in buffers) {\n      tempStride[j] = 0;\n      tempStart[j] = 0;\n    }\n    for (const j in attributes) {\n      if (!attributes[j].size && program.attributeData[j]) {\n        attributes[j].size = program.attributeData[j].size;\n      } else if (!attributes[j].size) {\n        console.warn(\"PIXI Geometry attribute '\".concat(j, \"' size cannot be determined (likely the bound shader does not have the attribute)\"));\n      }\n      tempStride[attributes[j].buffer] += attributes[j].size * byteSizeMap[attributes[j].type];\n    }\n    for (const j in attributes) {\n      const attribute = attributes[j];\n      const attribSize = attribute.size;\n      if (attribute.stride === void 0) {\n        if (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type]) {\n          attribute.stride = 0;\n        } else {\n          attribute.stride = tempStride[attribute.buffer];\n        }\n      }\n      if (attribute.start === void 0) {\n        attribute.start = tempStart[attribute.buffer];\n        tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];\n      }\n    }\n    vao = gl.createVertexArray();\n    gl.bindVertexArray(vao);\n    for (let i = 0; i < buffers.length; i++) {\n      const buffer = buffers[i];\n      bufferSystem.bind(buffer);\n      if (incRefCount) {\n        buffer._glBuffers[CONTEXT_UID].refCount++;\n      }\n    }\n    this.activateVao(geometry, program);\n    vaoObjectHash[program.id] = vao;\n    vaoObjectHash[signature] = vao;\n    gl.bindVertexArray(null);\n    bufferSystem.unbind(BUFFER_TYPE.ARRAY_BUFFER);\n    return vao;\n  }\n  disposeGeometry(geometry, contextLost) {\n    var _this$renderer;\n    if (!this.managedGeometries[geometry.id]) {\n      return;\n    }\n    delete this.managedGeometries[geometry.id];\n    const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    const gl = this.gl;\n    const buffers = geometry.buffers;\n    const bufferSystem = (_this$renderer = this.renderer) === null || _this$renderer === void 0 ? void 0 : _this$renderer.buffer;\n    geometry.disposeRunner.remove(this);\n    if (!vaos) {\n      return;\n    }\n    if (bufferSystem) {\n      for (let i = 0; i < buffers.length; i++) {\n        const buf = buffers[i]._glBuffers[this.CONTEXT_UID];\n        if (buf) {\n          buf.refCount--;\n          if (buf.refCount === 0 && !contextLost) {\n            bufferSystem.dispose(buffers[i], contextLost);\n          }\n        }\n      }\n    }\n    if (!contextLost) {\n      for (const vaoId in vaos) {\n        if (vaoId[0] === \"g\") {\n          const vao = vaos[vaoId];\n          if (this._activeVao === vao) {\n            this.unbind();\n          }\n          gl.deleteVertexArray(vao);\n        }\n      }\n    }\n    delete geometry.glVertexArrayObjects[this.CONTEXT_UID];\n  }\n  disposeAll(contextLost) {\n    const all = Object.keys(this.managedGeometries);\n    for (let i = 0; i < all.length; i++) {\n      this.disposeGeometry(this.managedGeometries[all[i]], contextLost);\n    }\n  }\n  activateVao(geometry, program) {\n    const gl = this.gl;\n    const CONTEXT_UID = this.CONTEXT_UID;\n    const bufferSystem = this.renderer.buffer;\n    const buffers = geometry.buffers;\n    const attributes = geometry.attributes;\n    if (geometry.indexBuffer) {\n      bufferSystem.bind(geometry.indexBuffer);\n    }\n    let lastBuffer = null;\n    for (const j in attributes) {\n      const attribute = attributes[j];\n      const buffer = buffers[attribute.buffer];\n      const glBuffer = buffer._glBuffers[CONTEXT_UID];\n      if (program.attributeData[j]) {\n        if (lastBuffer !== glBuffer) {\n          bufferSystem.bind(buffer);\n          lastBuffer = glBuffer;\n        }\n        const location = program.attributeData[j].location;\n        gl.enableVertexAttribArray(location);\n        gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);\n        if (attribute.instance) {\n          if (this.hasInstance) {\n            gl.vertexAttribDivisor(location, attribute.divisor);\n          } else {\n            throw new Error(\"geometry error, GPU Instancing is not supported on this device\");\n          }\n        }\n      }\n    }\n  }\n  draw(type, size, start, instanceCount) {\n    const {\n      gl\n    } = this;\n    const geometry = this._activeGeometry;\n    if (geometry.indexBuffer) {\n      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n      const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n      if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {\n        if (geometry.instanced) {\n          gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);\n        } else {\n          gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n        }\n      } else {\n        console.warn(\"unsupported index buffer type: uint32\");\n      }\n    } else if (geometry.instanced) {\n      gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);\n    } else {\n      gl.drawArrays(type, start, size || geometry.getSize());\n    }\n    return this;\n  }\n  unbind() {\n    this.gl.bindVertexArray(null);\n    this._activeVao = null;\n    this._activeGeometry = null;\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nGeometrySystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"geometry\"\n};\nextensions.add(GeometrySystem);\nexport { GeometrySystem };","map":{"version":3,"mappings":"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","names":["byteSizeMap","GeometrySystem","constructor","renderer","_activeGeometry","_activeVao","hasVao","hasInstance","canUseUInt32ElementIndex","managedGeometries","contextChange","disposeAll","gl","webGLVersion","nativeVaoExtension","extensions","PREFER_ENV","WEBGL_LEGACY","createVertexArrayOES","bindVertexArray","vao","bindVertexArrayOES","deleteVertexArray","deleteVertexArrayOES","createVertexArray","instanceExt","vertexAttribDivisor","a","b","drawElementsInstanced","c","e","drawElementsInstancedANGLE","d","drawArraysInstancedANGLE","context","bind","geometry","shader","incRefCount","vaos","id","add","glVertexArrayObjects","CONTEXT_UID","program","updateBuffers","reset","unbind","i","length","buffers","bufferSystem","update","buffer","checkCompatibility","geometryAttributes","shaderAttributes","j","Error","getSignature","attribs","strings","push","location","join","initGeometryVao","signature","vaoObjectHash","attributes","tempStride","tempStart","size","attributeData","console","attribute","attribSize","stride","type","start","_glBuffers","BUFFER_TYPE","ARRAY_BUFFER","disposeGeometry","contextLost","_this$renderer","remove","buf","vaoId","all","keys","activateVao","indexBuffer","lastBuffer","glBuffer","enableVertexAttribArray","vertexAttribPointer","instance","divisor","draw","instanceCount","data","glType","UNSIGNED_SHORT","byteSize","instanced","warn","getSize","drawArrays","destroy","extension","ExtensionType","name"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/core/src/geometry/GeometrySystem.ts"],"sourcesContent":["import { BUFFER_TYPE, ENV } from '@pixi/constants';\nimport { extensions, ExtensionType } from '@pixi/extensions';\nimport { settings } from '@pixi/settings';\n\nimport type { DRAW_MODES } from '@pixi/constants';\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { Dict } from '@pixi/utils';\nimport type { IRenderingContext } from '../IRenderer';\nimport type { Renderer } from '../Renderer';\nimport type { Program } from '../shader/Program';\nimport type { Shader } from '../shader/Shader';\nimport type { ISystem } from '../system/ISystem';\nimport type { Geometry } from './Geometry';\nimport type { GLBuffer } from './GLBuffer';\n\nconst byteSizeMap: {[key: number]: number} = { 5126: 4, 5123: 2, 5121: 1 };\n\n/**\n * System plugin to the renderer to manage geometry.\n * @memberof PIXI\n */\nexport class GeometrySystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'geometry',\n    };\n\n    /**\n     * `true` if we has `*_vertex_array_object` extension.\n     * @readonly\n     */\n    public hasVao: boolean;\n\n    /**\n     * `true` if has `ANGLE_instanced_arrays` extension.\n     * @readonly\n     */\n    public hasInstance: boolean;\n\n    /**\n     * `true` if support `gl.UNSIGNED_INT` in `gl.drawElements` or `gl.drawElementsInstanced`.\n     * @readonly\n     */\n    public canUseUInt32ElementIndex: boolean;\n\n    protected CONTEXT_UID: number;\n    protected gl: IRenderingContext;\n    protected _activeGeometry: Geometry;\n    protected _activeVao: WebGLVertexArrayObject;\n    protected _boundBuffer: GLBuffer;\n\n    /** Cache for all geometries by id, used in case renderer gets destroyed or for profiling. */\n    readonly managedGeometries: {[key: number]: Geometry};\n\n    /** Renderer that owns this {@link GeometrySystem}. */\n    private renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n        this._activeGeometry = null;\n        this._activeVao = null;\n\n        this.hasVao = true;\n        this.hasInstance = true;\n        this.canUseUInt32ElementIndex = false;\n        this.managedGeometries = {};\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        this.disposeAll(true);\n\n        const gl = this.gl = this.renderer.gl;\n        const context = this.renderer.context;\n\n        this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n\n        // webgl2\n        if (context.webGLVersion !== 2)\n        {\n            // webgl 1!\n            let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;\n\n            if (settings.PREFER_ENV === ENV.WEBGL_LEGACY)\n            {\n                nativeVaoExtension = null;\n            }\n\n            if (nativeVaoExtension)\n            {\n                gl.createVertexArray = (): WebGLVertexArrayObject =>\n                    nativeVaoExtension.createVertexArrayOES();\n\n                gl.bindVertexArray = (vao): void =>\n                    nativeVaoExtension.bindVertexArrayOES(vao);\n\n                gl.deleteVertexArray = (vao): void =>\n                    nativeVaoExtension.deleteVertexArrayOES(vao);\n            }\n            else\n            {\n                this.hasVao = false;\n                gl.createVertexArray = (): WebGLVertexArrayObject =>\n                    null;\n\n                gl.bindVertexArray = (): void =>\n                    null;\n\n                gl.deleteVertexArray = (): void =>\n                    null;\n            }\n        }\n\n        if (context.webGLVersion !== 2)\n        {\n            const instanceExt = gl.getExtension('ANGLE_instanced_arrays');\n\n            if (instanceExt)\n            {\n                gl.vertexAttribDivisor = (a, b): void =>\n                    instanceExt.vertexAttribDivisorANGLE(a, b);\n\n                gl.drawElementsInstanced = (a, b, c, d, e): void =>\n                    instanceExt.drawElementsInstancedANGLE(a, b, c, d, e);\n\n                gl.drawArraysInstanced = (a, b, c, d): void =>\n                    instanceExt.drawArraysInstancedANGLE(a, b, c, d);\n            }\n            else\n            {\n                this.hasInstance = false;\n            }\n        }\n\n        this.canUseUInt32ElementIndex = context.webGLVersion === 2 || !!context.extensions.uint32ElementIndex;\n    }\n\n    /**\n     * Binds geometry so that is can be drawn. Creating a Vao if required\n     * @param geometry - Instance of geometry to bind.\n     * @param shader - Instance of shader to use vao for.\n     */\n    bind(geometry?: Geometry, shader?: Shader): void\n    {\n        shader = shader || this.renderer.shader.shader;\n\n        const { gl } = this;\n\n        // not sure the best way to address this..\n        // currently different shaders require different VAOs for the same geometry\n        // Still mulling over the best way to solve this one..\n        // will likely need to modify the shader attribute locations at run time!\n        let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n        let incRefCount = false;\n\n        if (!vaos)\n        {\n            this.managedGeometries[geometry.id] = geometry;\n            geometry.disposeRunner.add(this);\n            geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};\n            incRefCount = true;\n        }\n\n        const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);\n\n        this._activeGeometry = geometry;\n\n        if (this._activeVao !== vao)\n        {\n            this._activeVao = vao;\n\n            if (this.hasVao)\n            {\n                gl.bindVertexArray(vao);\n            }\n            else\n            {\n                this.activateVao(geometry, shader.program);\n            }\n        }\n\n        // TODO - optimise later!\n        // don't need to loop through if nothing changed!\n        // maybe look to add an 'autoupdate' to geometry?\n        this.updateBuffers();\n    }\n\n    /** Reset and unbind any active VAO and geometry. */\n    reset(): void\n    {\n        this.unbind();\n    }\n\n    /** Update buffers of the currently bound geometry. */\n    updateBuffers(): void\n    {\n        const geometry = this._activeGeometry;\n\n        const bufferSystem = this.renderer.buffer;\n\n        for (let i = 0; i < geometry.buffers.length; i++)\n        {\n            const buffer = geometry.buffers[i];\n\n            bufferSystem.update(buffer);\n        }\n    }\n\n    /**\n     * Check compatibility between a geometry and a program\n     * @param geometry - Geometry instance.\n     * @param program - Program instance.\n     */\n    protected checkCompatibility(geometry: Geometry, program: Program): void\n    {\n        // geometry must have at least all the attributes that the shader requires.\n        const geometryAttributes = geometry.attributes;\n        const shaderAttributes = program.attributeData;\n\n        for (const j in shaderAttributes)\n        {\n            if (!geometryAttributes[j])\n            {\n                throw new Error(`shader and geometry incompatible, geometry missing the \"${j}\" attribute`);\n            }\n        }\n    }\n\n    /**\n     * Takes a geometry and program and generates a unique signature for them.\n     * @param geometry - To get signature from.\n     * @param program - To test geometry against.\n     * @returns - Unique signature of the geometry and program\n     */\n    protected getSignature(geometry: Geometry, program: Program): string\n    {\n        const attribs = geometry.attributes;\n        const shaderAttributes = program.attributeData;\n\n        const strings = ['g', geometry.id];\n\n        for (const i in attribs)\n        {\n            if (shaderAttributes[i])\n            {\n                strings.push(i, shaderAttributes[i].location);\n            }\n        }\n\n        return strings.join('-');\n    }\n\n    /**\n     * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.\n     * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the\n     * attribute locations.\n     * @param geometry - Instance of geometry to to generate Vao for.\n     * @param shader - Instance of the shader.\n     * @param incRefCount - Increment refCount of all geometry buffers.\n     */\n    protected initGeometryVao(geometry: Geometry, shader: Shader, incRefCount = true): WebGLVertexArrayObject\n    {\n        const gl = this.gl;\n        const CONTEXT_UID = this.CONTEXT_UID;\n        const bufferSystem = this.renderer.buffer;\n        const program = shader.program;\n\n        if (!program.glPrograms[CONTEXT_UID])\n        {\n            this.renderer.shader.generateProgram(shader);\n        }\n\n        this.checkCompatibility(geometry, program);\n\n        const signature = this.getSignature(geometry, program);\n\n        const vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n\n        let vao = vaoObjectHash[signature];\n\n        if (vao)\n        {\n            // this will give us easy access to the vao\n            vaoObjectHash[program.id] = vao;\n\n            return vao;\n        }\n\n        const buffers = geometry.buffers;\n        const attributes = geometry.attributes;\n        const tempStride: Dict<number> = {};\n        const tempStart: Dict<number> = {};\n\n        for (const j in buffers)\n        {\n            tempStride[j] = 0;\n            tempStart[j] = 0;\n        }\n\n        for (const j in attributes)\n        {\n            if (!attributes[j].size && program.attributeData[j])\n            {\n                attributes[j].size = program.attributeData[j].size;\n            }\n            else if (!attributes[j].size)\n            {\n                console.warn(`PIXI Geometry attribute '${j}' size cannot be determined (likely the bound shader does not have the attribute)`);  // eslint-disable-line\n            }\n\n            tempStride[attributes[j].buffer] += attributes[j].size * byteSizeMap[attributes[j].type];\n        }\n\n        for (const j in attributes)\n        {\n            const attribute = attributes[j];\n            const attribSize = attribute.size;\n\n            if (attribute.stride === undefined)\n            {\n                if (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type])\n                {\n                    attribute.stride = 0;\n                }\n                else\n                {\n                    attribute.stride = tempStride[attribute.buffer];\n                }\n            }\n\n            if (attribute.start === undefined)\n            {\n                attribute.start = tempStart[attribute.buffer];\n\n                tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];\n            }\n        }\n\n        // @TODO: We don't know if VAO is supported.\n        vao = gl.createVertexArray();\n\n        gl.bindVertexArray(vao);\n\n        // first update - and create the buffers!\n        // only create a gl buffer if it actually gets\n        for (let i = 0; i < buffers.length; i++)\n        {\n            const buffer = buffers[i];\n\n            bufferSystem.bind(buffer);\n\n            if (incRefCount)\n            {\n                buffer._glBuffers[CONTEXT_UID].refCount++;\n            }\n        }\n\n        // TODO - maybe make this a data object?\n        // lets wait to see if we need to first!\n\n        this.activateVao(geometry, program);\n\n        // add it to the cache!\n        vaoObjectHash[program.id] = vao;\n        vaoObjectHash[signature] = vao;\n\n        gl.bindVertexArray(null);\n        bufferSystem.unbind(BUFFER_TYPE.ARRAY_BUFFER);\n\n        return vao;\n    }\n\n    /**\n     * Disposes geometry.\n     * @param geometry - Geometry with buffers. Only VAO will be disposed\n     * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    disposeGeometry(geometry: Geometry, contextLost?: boolean): void\n    {\n        if (!this.managedGeometries[geometry.id])\n        {\n            return;\n        }\n\n        delete this.managedGeometries[geometry.id];\n\n        const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n        const gl = this.gl;\n        const buffers = geometry.buffers;\n        const bufferSystem = this.renderer?.buffer;\n\n        geometry.disposeRunner.remove(this);\n\n        if (!vaos)\n        {\n            return;\n        }\n\n        // bufferSystem may have already been destroyed..\n        // if this is the case, there is no need to destroy the geometry buffers...\n        // they already have been!\n        if (bufferSystem)\n        {\n            for (let i = 0; i < buffers.length; i++)\n            {\n                const buf = buffers[i]._glBuffers[this.CONTEXT_UID];\n\n                // my be null as context may have changed right before the dispose is called\n                if (buf)\n                {\n                    buf.refCount--;\n                    if (buf.refCount === 0 && !contextLost)\n                    {\n                        bufferSystem.dispose(buffers[i], contextLost);\n                    }\n                }\n            }\n        }\n\n        if (!contextLost)\n        {\n            for (const vaoId in vaos)\n            {\n                // delete only signatures, everything else are copies\n                if (vaoId[0] === 'g')\n                {\n                    const vao = vaos[vaoId];\n\n                    if (this._activeVao === vao)\n                    {\n                        this.unbind();\n                    }\n                    gl.deleteVertexArray(vao);\n                }\n            }\n        }\n\n        delete geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    }\n\n    /**\n     * Dispose all WebGL resources of all managed geometries.\n     * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n     */\n    disposeAll(contextLost?: boolean): void\n    {\n        const all: Array<any> = Object.keys(this.managedGeometries);\n\n        for (let i = 0; i < all.length; i++)\n        {\n            this.disposeGeometry(this.managedGeometries[all[i]], contextLost);\n        }\n    }\n\n    /**\n     * Activate vertex array object.\n     * @param geometry - Geometry instance.\n     * @param program - Shader program instance.\n     */\n    protected activateVao(geometry: Geometry, program: Program): void\n    {\n        const gl = this.gl;\n        const CONTEXT_UID = this.CONTEXT_UID;\n        const bufferSystem = this.renderer.buffer;\n        const buffers = geometry.buffers;\n        const attributes = geometry.attributes;\n\n        if (geometry.indexBuffer)\n        {\n            // first update the index buffer if we have one..\n            bufferSystem.bind(geometry.indexBuffer);\n        }\n\n        let lastBuffer = null;\n\n        // add a new one!\n        for (const j in attributes)\n        {\n            const attribute = attributes[j];\n            const buffer = buffers[attribute.buffer];\n            const glBuffer = buffer._glBuffers[CONTEXT_UID];\n\n            if (program.attributeData[j])\n            {\n                if (lastBuffer !== glBuffer)\n                {\n                    bufferSystem.bind(buffer);\n\n                    lastBuffer = glBuffer;\n                }\n\n                const location = program.attributeData[j].location;\n\n                // TODO introduce state again\n                // we can optimise this for older devices that have no VAOs\n                gl.enableVertexAttribArray(location);\n\n                gl.vertexAttribPointer(location,\n                    attribute.size,\n                    attribute.type || gl.FLOAT,\n                    attribute.normalized,\n                    attribute.stride,\n                    attribute.start);\n\n                if (attribute.instance)\n                {\n                    // TODO calculate instance count based of this...\n                    if (this.hasInstance)\n                    {\n                        gl.vertexAttribDivisor(location, attribute.divisor);\n                    }\n                    else\n                    {\n                        throw new Error('geometry error, GPU Instancing is not supported on this device');\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the currently bound geometry.\n     * @param type - The type primitive to render.\n     * @param size - The number of elements to be rendered. If not specified, all vertices after the\n     *  starting vertex will be drawn.\n     * @param start - The starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     * @param instanceCount - The number of instances of the set of elements to execute. If not specified,\n     *  all instances will be drawn.\n     */\n    draw(type: DRAW_MODES, size?: number, start?: number, instanceCount?: number): this\n    {\n        const { gl } = this;\n        const geometry = this._activeGeometry;\n\n        // TODO.. this should not change so maybe cache the function?\n\n        if (geometry.indexBuffer)\n        {\n            const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n            const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n            if (byteSize === 2 || (byteSize === 4 && this.canUseUInt32ElementIndex))\n            {\n                if (geometry.instanced)\n                {\n                    /* eslint-disable max-len */\n                    gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);\n                    /* eslint-enable max-len */\n                }\n                else\n                {\n                    /* eslint-disable max-len */\n                    gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n                    /* eslint-enable max-len */\n                }\n            }\n            else\n            {\n                console.warn('unsupported index buffer type: uint32');\n            }\n        }\n        else if (geometry.instanced)\n        {\n            // TODO need a better way to calculate size..\n            gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);\n        }\n        else\n        {\n            gl.drawArrays(type, start, size || geometry.getSize());\n        }\n\n        return this;\n    }\n\n    /** Unbind/reset everything. */\n    protected unbind(): void\n    {\n        this.gl.bindVertexArray(null);\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n}\n\nextensions.add(GeometrySystem);\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}