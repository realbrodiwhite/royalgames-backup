{"ast":null,"code":"import { Ticker } from '@pixi/ticker';\nimport { BaseImageResource } from './BaseImageResource.mjs';\nconst _VideoResource = class extends BaseImageResource {\n  constructor(source, options) {\n    options = options || {};\n    if (!(source instanceof HTMLVideoElement)) {\n      const videoElement = document.createElement(\"video\");\n      videoElement.setAttribute(\"preload\", \"auto\");\n      videoElement.setAttribute(\"webkit-playsinline\", \"\");\n      videoElement.setAttribute(\"playsinline\", \"\");\n      if (typeof source === \"string\") {\n        source = [source];\n      }\n      const firstSrc = source[0].src || source[0];\n      BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);\n      for (let i = 0; i < source.length; ++i) {\n        const sourceElement = document.createElement(\"source\");\n        let {\n          src,\n          mime\n        } = source[i];\n        src = src || source[i];\n        const baseSrc = src.split(\"?\").shift().toLowerCase();\n        const ext = baseSrc.slice(baseSrc.lastIndexOf(\".\") + 1);\n        mime = mime || _VideoResource.MIME_TYPES[ext] || \"video/\".concat(ext);\n        sourceElement.src = src;\n        sourceElement.type = mime;\n        videoElement.appendChild(sourceElement);\n      }\n      source = videoElement;\n    }\n    super(source);\n    this.noSubImage = true;\n    this._autoUpdate = true;\n    this._isConnectedToTicker = false;\n    this._updateFPS = options.updateFPS || 0;\n    this._msToNextUpdate = 0;\n    this.autoPlay = options.autoPlay !== false;\n    this._load = null;\n    this._resolve = null;\n    this._onCanPlay = this._onCanPlay.bind(this);\n    this._onError = this._onError.bind(this);\n    if (options.autoLoad !== false) {\n      this.load();\n    }\n  }\n  update() {\n    let _deltaTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    if (!this.destroyed) {\n      const elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;\n      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n      if (!this._updateFPS || this._msToNextUpdate <= 0) {\n        super.update();\n        this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;\n      }\n    }\n  }\n  load() {\n    if (this._load) {\n      return this._load;\n    }\n    const source = this.source;\n    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {\n      source.complete = true;\n    }\n    source.addEventListener(\"play\", this._onPlayStart.bind(this));\n    source.addEventListener(\"pause\", this._onPlayStop.bind(this));\n    if (!this._isSourceReady()) {\n      source.addEventListener(\"canplay\", this._onCanPlay);\n      source.addEventListener(\"canplaythrough\", this._onCanPlay);\n      source.addEventListener(\"error\", this._onError, true);\n    } else {\n      this._onCanPlay();\n    }\n    this._load = new Promise(resolve => {\n      if (this.valid) {\n        resolve(this);\n      } else {\n        this._resolve = resolve;\n        source.load();\n      }\n    });\n    return this._load;\n  }\n  _onError(event) {\n    this.source.removeEventListener(\"error\", this._onError, true);\n    this.onError.emit(event);\n  }\n  _isSourcePlaying() {\n    const source = this.source;\n    return !source.paused && !source.ended && this._isSourceReady();\n  }\n  _isSourceReady() {\n    const source = this.source;\n    return source.readyState > 2;\n  }\n  _onPlayStart() {\n    if (!this.valid) {\n      this._onCanPlay();\n    }\n    if (this.autoUpdate && !this._isConnectedToTicker) {\n      Ticker.shared.add(this.update, this);\n      this._isConnectedToTicker = true;\n    }\n  }\n  _onPlayStop() {\n    if (this._isConnectedToTicker) {\n      Ticker.shared.remove(this.update, this);\n      this._isConnectedToTicker = false;\n    }\n  }\n  _onCanPlay() {\n    const source = this.source;\n    source.removeEventListener(\"canplay\", this._onCanPlay);\n    source.removeEventListener(\"canplaythrough\", this._onCanPlay);\n    const valid = this.valid;\n    this.resize(source.videoWidth, source.videoHeight);\n    if (!valid && this._resolve) {\n      this._resolve(this);\n      this._resolve = null;\n    }\n    if (this._isSourcePlaying()) {\n      this._onPlayStart();\n    } else if (this.autoPlay) {\n      source.play();\n    }\n  }\n  dispose() {\n    if (this._isConnectedToTicker) {\n      Ticker.shared.remove(this.update, this);\n      this._isConnectedToTicker = false;\n    }\n    const source = this.source;\n    if (source) {\n      source.removeEventListener(\"error\", this._onError, true);\n      source.pause();\n      source.src = \"\";\n      source.load();\n    }\n    super.dispose();\n  }\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      if (!this._autoUpdate && this._isConnectedToTicker) {\n        Ticker.shared.remove(this.update, this);\n        this._isConnectedToTicker = false;\n      } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {\n        Ticker.shared.add(this.update, this);\n        this._isConnectedToTicker = true;\n      }\n    }\n  }\n  get updateFPS() {\n    return this._updateFPS;\n  }\n  set updateFPS(value) {\n    if (value !== this._updateFPS) {\n      this._updateFPS = value;\n    }\n  }\n  static test(source, extension) {\n    return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || _VideoResource.TYPES.includes(extension);\n  }\n};\nlet VideoResource = _VideoResource;\nVideoResource.TYPES = [\"mp4\", \"m4v\", \"webm\", \"ogg\", \"ogv\", \"h264\", \"avi\", \"mov\"];\nVideoResource.MIME_TYPES = {\n  ogv: \"video/ogg\",\n  mov: \"video/quicktime\",\n  m4v: \"video/mp4\"\n};\nexport { VideoResource };","map":{"version":3,"mappings":"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","names":["_VideoResource","BaseImageResource","constructor","source","options","HTMLVideoElement","document","videoElement","firstSrc","crossOrigin","crossorigin","i","src","mime","baseSrc","toLowerCase","ext","lastIndexOf","MIME_TYPES","sourceElement","type","appendChild","noSubImage","_autoUpdate","_isConnectedToTicker","updateFPS","_msToNextUpdate","autoPlay","_load","_resolve","_onCanPlay","_onError","autoLoad","load","update","_deltaTime","destroyed","elapsedMS","shared","floor","_updateFPS","readyState","HAVE_ENOUGH_DATA","HAVE_FUTURE_DATA","width","height","complete","addEventListener","_onPlayStart","_onPlayStop","Promise","resolve","valid","event","emit","_isSourcePlaying","_isSourceReady","Ticker","resize","videoWidth","videoHeight","play","dispose","removeEventListener","pause","autoUpdate","value","test","extension","globalThis","includes","VideoResource","TYPES","ogv","mov","m4v"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/core/src/textures/resources/VideoResource.ts"],"sourcesContent":["import { Ticker } from '@pixi/ticker';\nimport { BaseImageResource } from './BaseImageResource';\n\nimport type { Dict } from '@pixi/utils';\n\nexport interface IVideoResourceOptions\n{\n    autoLoad?: boolean;\n    autoPlay?: boolean;\n    updateFPS?: number;\n    crossorigin?: boolean | string;\n}\n\nexport interface IVideoResourceOptionsElement\n{\n    src: string;\n    mime: string;\n}\n\n/**\n * Resource type for {@code HTMLVideoElement}.\n * @memberof PIXI\n */\nexport class VideoResource extends BaseImageResource\n{\n    /** Override the source to be the video element. */\n    public source: HTMLVideoElement;\n\n    /**\n     * `true` to use Ticker.shared to auto update the base texture.\n     * @default true\n     */\n    protected _autoUpdate: boolean;\n\n    /**\n     * `true` if the instance is currently connected to PIXI.Ticker.shared to auto update the base texture.\n     * @default false\n     */\n    protected _isConnectedToTicker: boolean;\n    protected _updateFPS: number;\n    protected _msToNextUpdate: number;\n\n    /**\n     * When set to true will automatically play videos used by this texture once\n     * they are loaded. If false, it will not modify the playing state.\n     * @default true\n     */\n    protected autoPlay: boolean;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<VideoResource>;\n\n    /** Callback when completed with load. */\n    private _resolve: (value?: VideoResource | PromiseLike<VideoResource>) => void;\n\n    /**\n     * @param {HTMLVideoElement|object|string|Array<string|object>} source - Video element to use.\n     * @param {object} [options] - Options to use\n     * @param {boolean} [options.autoLoad=true] - Start loading the video immediately\n     * @param {boolean} [options.autoPlay=true] - Start playing video immediately\n     * @param {number} [options.updateFPS=0] - How many times a second to update the texture from the video.\n     * Leave at 0 to update at every render.\n     * @param {boolean} [options.crossorigin=true] - Load image using cross origin\n     */\n    constructor(\n        source?: HTMLVideoElement | Array<string | IVideoResourceOptionsElement> | string, options?: IVideoResourceOptions\n    )\n    {\n        options = options || {};\n\n        if (!(source instanceof HTMLVideoElement))\n        {\n            const videoElement = document.createElement('video');\n\n            // workaround for https://github.com/pixijs/pixijs/issues/5996\n            videoElement.setAttribute('preload', 'auto');\n            videoElement.setAttribute('webkit-playsinline', '');\n            videoElement.setAttribute('playsinline', '');\n\n            if (typeof source === 'string')\n            {\n                source = [source];\n            }\n\n            const firstSrc = (source[0] as IVideoResourceOptionsElement).src || source[0] as string;\n\n            BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);\n\n            // array of objects or strings\n            for (let i = 0; i < source.length; ++i)\n            {\n                const sourceElement = document.createElement('source');\n\n                let { src, mime } = source[i] as IVideoResourceOptionsElement;\n\n                src = src || source[i] as string;\n\n                const baseSrc = src.split('?').shift().toLowerCase();\n                const ext = baseSrc.slice(baseSrc.lastIndexOf('.') + 1);\n\n                mime = mime || VideoResource.MIME_TYPES[ext] || `video/${ext}`;\n\n                sourceElement.src = src;\n                sourceElement.type = mime;\n\n                videoElement.appendChild(sourceElement);\n            }\n\n            // Override the source\n            source = videoElement;\n        }\n\n        super(source);\n\n        this.noSubImage = true;\n\n        this._autoUpdate = true;\n        this._isConnectedToTicker = false;\n\n        this._updateFPS = options.updateFPS || 0;\n        this._msToNextUpdate = 0;\n        this.autoPlay = options.autoPlay !== false;\n\n        this._load = null;\n        this._resolve = null;\n\n        // Bind for listeners\n        this._onCanPlay = this._onCanPlay.bind(this);\n        this._onError = this._onError.bind(this);\n\n        if (options.autoLoad !== false)\n        {\n            this.load();\n        }\n    }\n\n    /**\n     * Trigger updating of the texture.\n     * @param _deltaTime - time delta since last tick\n     */\n    update(_deltaTime = 0): void\n    {\n        if (!this.destroyed)\n        {\n            // account for if video has had its playbackRate changed\n            const elapsedMS = Ticker.shared.elapsedMS * (this.source as HTMLVideoElement).playbackRate;\n\n            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n            if (!this._updateFPS || this._msToNextUpdate <= 0)\n            {\n                super.update(/* deltaTime*/);\n                this._msToNextUpdate = this._updateFPS ? Math.floor(1000 / this._updateFPS) : 0;\n            }\n        }\n    }\n\n    /**\n     * Start preloading the video resource.\n     * @returns {Promise<void>} Handle the validate event\n     */\n    load(): Promise<VideoResource>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        const source = this.source as HTMLVideoElement;\n\n        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)\n            && source.width && source.height)\n        {\n            (source as any).complete = true;\n        }\n\n        source.addEventListener('play', this._onPlayStart.bind(this));\n        source.addEventListener('pause', this._onPlayStop.bind(this));\n\n        if (!this._isSourceReady())\n        {\n            source.addEventListener('canplay', this._onCanPlay);\n            source.addEventListener('canplaythrough', this._onCanPlay);\n            source.addEventListener('error', this._onError, true);\n        }\n        else\n        {\n            this._onCanPlay();\n        }\n\n        this._load = new Promise((resolve): void =>\n        {\n            if (this.valid)\n            {\n                resolve(this);\n            }\n            else\n            {\n                this._resolve = resolve;\n\n                source.load();\n            }\n        });\n\n        return this._load;\n    }\n\n    /**\n     * Handle video error events.\n     * @param event\n     */\n    private _onError(event: ErrorEvent): void\n    {\n        (this.source as HTMLVideoElement).removeEventListener('error', this._onError, true);\n        this.onError.emit(event);\n    }\n\n    /**\n     * Returns true if the underlying source is playing.\n     * @returns - True if playing.\n     */\n    private _isSourcePlaying(): boolean\n    {\n        const source = this.source as HTMLVideoElement;\n\n        return (!source.paused && !source.ended && this._isSourceReady());\n    }\n\n    /**\n     * Returns true if the underlying source is ready for playing.\n     * @returns - True if ready.\n     */\n    private _isSourceReady(): boolean\n    {\n        const source = this.source as HTMLVideoElement;\n\n        return source.readyState > 2;\n    }\n\n    /** Runs the update loop when the video is ready to play. */\n    private _onPlayStart(): void\n    {\n        // Just in case the video has not received its can play even yet..\n        if (!this.valid)\n        {\n            this._onCanPlay();\n        }\n\n        if (this.autoUpdate && !this._isConnectedToTicker)\n        {\n            Ticker.shared.add(this.update, this);\n            this._isConnectedToTicker = true;\n        }\n    }\n\n    /** Fired when a pause event is triggered, stops the update loop. */\n    private _onPlayStop(): void\n    {\n        if (this._isConnectedToTicker)\n        {\n            Ticker.shared.remove(this.update, this);\n            this._isConnectedToTicker = false;\n        }\n    }\n\n    /** Fired when the video is loaded and ready to play. */\n    private _onCanPlay(): void\n    {\n        const source = this.source as HTMLVideoElement;\n\n        source.removeEventListener('canplay', this._onCanPlay);\n        source.removeEventListener('canplaythrough', this._onCanPlay);\n\n        const valid = this.valid;\n\n        this.resize(source.videoWidth, source.videoHeight);\n\n        // prevent multiple loaded dispatches..\n        if (!valid && this._resolve)\n        {\n            this._resolve(this);\n            this._resolve = null;\n        }\n\n        if (this._isSourcePlaying())\n        {\n            this._onPlayStart();\n        }\n        else if (this.autoPlay)\n        {\n            source.play();\n        }\n    }\n\n    /** Destroys this texture. */\n    dispose(): void\n    {\n        if (this._isConnectedToTicker)\n        {\n            Ticker.shared.remove(this.update, this);\n            this._isConnectedToTicker = false;\n        }\n\n        const source = this.source as HTMLVideoElement;\n\n        if (source)\n        {\n            source.removeEventListener('error', this._onError, true);\n            source.pause();\n            source.src = '';\n            source.load();\n        }\n        super.dispose();\n    }\n\n    /** Should the base texture automatically update itself, set to true by default. */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n\n            if (!this._autoUpdate && this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.update, this);\n                this._isConnectedToTicker = false;\n            }\n            else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying())\n            {\n                Ticker.shared.add(this.update, this);\n                this._isConnectedToTicker = true;\n            }\n        }\n    }\n\n    /**\n     * How many times a second to update the texture from the video. Leave at 0 to update at every render.\n     * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n     */\n    get updateFPS(): number\n    {\n        return this._updateFPS;\n    }\n\n    set updateFPS(value: number)\n    {\n        if (value !== this._updateFPS)\n        {\n            this._updateFPS = value;\n        }\n    }\n\n    /**\n     * Used to auto-detect the type of resource.\n     * @param {*} source - The source object\n     * @param {string} extension - The extension of source, if set\n     * @returns {boolean} `true` if video source\n     */\n    static test(source: unknown, extension?: string): source is HTMLVideoElement\n    {\n        return (globalThis.HTMLVideoElement && source instanceof HTMLVideoElement)\n            || VideoResource.TYPES.includes(extension);\n    }\n\n    /**\n     * List of common video file extensions supported by VideoResource.\n     * @readonly\n     */\n    static TYPES: Array<string> = ['mp4', 'm4v', 'webm', 'ogg', 'ogv', 'h264', 'avi', 'mov'];\n\n    /**\n     * Map of video MIME types that can't be directly derived from file extensions.\n     * @readonly\n     */\n    static MIME_TYPES: Dict<string> = {\n        ogv: 'video/ogg',\n        mov: 'video/quicktime',\n        m4v: 'video/mp4',\n    };\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}