{"ast":null,"code":"import { Matrix, ObjectRenderer, QuadUv, State, Shader, WRAP_MODES, utils, ExtensionType, extensions } from '@pixi/core';\nimport gl2FragmentSrc from './sprite-tiling.mjs';\nimport gl2VertexSrc from './sprite-tiling2.mjs';\nimport gl1FragmentSrc from './sprite-tiling-fallback.mjs';\nimport gl1VertexSrc from './sprite-tiling-fallback2.mjs';\nimport fragmentSimpleSrc from './sprite-tiling-simple.mjs';\nconst tempMat = new Matrix();\nclass TilingSpriteRenderer extends ObjectRenderer {\n  constructor(renderer) {\n    super(renderer);\n    renderer.runners.contextChange.add(this);\n    this.quad = new QuadUv();\n    this.state = State.for2d();\n  }\n  contextChange() {\n    const renderer = this.renderer;\n    const uniforms = {\n      globals: renderer.globalUniforms\n    };\n    this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);\n    this.shader = renderer.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);\n  }\n  render(ts) {\n    const renderer = this.renderer;\n    const quad = this.quad;\n    let vertices = quad.vertices;\n    vertices[0] = vertices[6] = ts._width * -ts.anchor.x;\n    vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n    vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);\n    vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);\n    const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;\n    const anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;\n    vertices = quad.uvs;\n    vertices[0] = vertices[6] = -anchorX;\n    vertices[1] = vertices[3] = -anchorY;\n    vertices[2] = vertices[4] = 1 - anchorX;\n    vertices[5] = vertices[7] = 1 - anchorY;\n    quad.invalidate();\n    const tex = ts._texture;\n    const baseTex = tex.baseTexture;\n    const premultiplied = baseTex.alphaMode > 0;\n    const lt = ts.tileTransform.localTransform;\n    const uv = ts.uvMatrix;\n    let isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n    if (isSimple) {\n      if (!baseTex._glTextures[renderer.CONTEXT_UID]) {\n        if (baseTex.wrapMode === WRAP_MODES.CLAMP) {\n          baseTex.wrapMode = WRAP_MODES.REPEAT;\n        }\n      } else {\n        isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;\n      }\n    }\n    const shader = isSimple ? this.simpleShader : this.shader;\n    const w = tex.width;\n    const h = tex.height;\n    const W = ts._width;\n    const H = ts._height;\n    tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);\n    tempMat.invert();\n    if (isSimple) {\n      tempMat.prepend(uv.mapCoord);\n    } else {\n      shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n      shader.uniforms.uClampFrame = uv.uClampFrame;\n      shader.uniforms.uClampOffset = uv.uClampOffset;\n    }\n    shader.uniforms.uTransform = tempMat.toArray(true);\n    shader.uniforms.uColor = utils.premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, premultiplied);\n    shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);\n    shader.uniforms.uSampler = tex;\n    renderer.shader.bind(shader);\n    renderer.geometry.bind(quad);\n    this.state.blendMode = utils.correctBlendMode(ts.blendMode, premultiplied);\n    renderer.state.set(this.state);\n    renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n  }\n}\nTilingSpriteRenderer.extension = {\n  name: \"tilingSprite\",\n  type: ExtensionType.RendererPlugin\n};\nextensions.add(TilingSpriteRenderer);\nexport { TilingSpriteRenderer };","map":{"version":3,"mappings":"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","names":["tempMat","Matrix","TilingSpriteRenderer","ObjectRenderer","constructor","renderer","contextChange","QuadUv","State","for2d","uniforms","globals","globalUniforms","simpleShader","from","fragmentSimpleSrc","shader","context","Shader","gl2VertexSrc","gl1FragmentSrc","render","ts","quad","vertices","_width","anchor","_height","anchorX","uvRespectAnchor","x","anchorY","y","invalidate","tex","baseTex","alphaMode","tileTransform","uv","width","frame","isSimple","_glTextures","CONTEXT_UID","wrapMode","CLAMP","WRAP_MODES","w","h","W","H","lt","a","d","tx","invert","mapCoord","toArray","uClampFrame","uClampOffset","uColor","premultiplyTintToRgba","tint","worldAlpha","premultiplied","translationMatrix","transform","uSampler","bind","state","blendMode","correctBlendMode","set","geometry","draw","gl","extension","name","type","ExtensionType","extensions","add"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/sprite-tiling/src/TilingSpriteRenderer.ts"],"sourcesContent":["import { extensions, ExtensionType, Matrix, ObjectRenderer, QuadUv, Shader, State, utils, WRAP_MODES } from '@pixi/core';\nimport gl2FragmentSrc from './sprite-tiling.frag';\nimport gl2VertexSrc from './sprite-tiling.vert';\nimport gl1FragmentSrc from './sprite-tiling-fallback.frag';\nimport gl1VertexSrc from './sprite-tiling-fallback.vert';\nimport fragmentSimpleSrc from './sprite-tiling-simple.frag';\n\nimport type { ExtensionMetadata, Renderer } from '@pixi/core';\nimport type { TilingSprite } from './TilingSprite';\n\nconst tempMat = new Matrix();\n\n/**\n * WebGL renderer plugin for tiling sprites\n * @class\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\nexport class TilingSpriteRenderer extends ObjectRenderer\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'tilingSprite',\n        type: ExtensionType.RendererPlugin,\n    };\n\n    public shader: Shader;\n    public simpleShader: Shader;\n    public quad: QuadUv;\n    public readonly state: State;\n\n    /**\n     * constructor for renderer\n     * @param {PIXI.Renderer} renderer - The renderer this tiling awesomeness works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        // WebGL version is not available during initialization!\n        renderer.runners.contextChange.add(this);\n\n        this.quad = new QuadUv();\n\n        /**\n         * The WebGL state in which this renderer will work.\n         * @member {PIXI.State}\n         * @readonly\n         */\n        this.state = State.for2d();\n    }\n\n    /** Creates shaders when context is initialized. */\n    contextChange(): void\n    {\n        const renderer = this.renderer;\n        const uniforms = { globals: renderer.globalUniforms };\n\n        this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);\n        this.shader = renderer.context.webGLVersion > 1\n            ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms)\n            : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);\n    }\n\n    /**\n     * @param {PIXI.TilingSprite} ts - tilingSprite to be rendered\n     */\n    public render(ts: TilingSprite): void\n    {\n        const renderer = this.renderer;\n        const quad = this.quad;\n\n        let vertices = quad.vertices;\n\n        vertices[0] = vertices[6] = (ts._width) * -ts.anchor.x;\n        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n\n        vertices[2] = vertices[4] = (ts._width) * (1.0 - ts.anchor.x);\n        vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);\n\n        const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;\n        const anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;\n\n        vertices = quad.uvs;\n\n        vertices[0] = vertices[6] = -anchorX;\n        vertices[1] = vertices[3] = -anchorY;\n\n        vertices[2] = vertices[4] = 1.0 - anchorX;\n        vertices[5] = vertices[7] = 1.0 - anchorY;\n\n        quad.invalidate();\n\n        const tex = ts._texture;\n        const baseTex = tex.baseTexture;\n        const premultiplied = baseTex.alphaMode > 0;\n        const lt = ts.tileTransform.localTransform;\n        const uv = ts.uvMatrix;\n        let isSimple = baseTex.isPowerOfTwo\n            && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n\n        // auto, force repeat wrapMode for big tiling textures\n        if (isSimple)\n        {\n            if (!baseTex._glTextures[renderer.CONTEXT_UID])\n            {\n                if (baseTex.wrapMode === WRAP_MODES.CLAMP)\n                {\n                    baseTex.wrapMode = WRAP_MODES.REPEAT;\n                }\n            }\n            else\n            {\n                isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;\n            }\n        }\n\n        const shader = isSimple ? this.simpleShader : this.shader;\n\n        const w = tex.width;\n        const h = tex.height;\n        const W = ts._width;\n        const H = ts._height;\n\n        tempMat.set(lt.a * w / W,\n            lt.b * w / H,\n            lt.c * h / W,\n            lt.d * h / H,\n            lt.tx / W,\n            lt.ty / H);\n\n        // that part is the same as above:\n        // tempMat.identity();\n        // tempMat.scale(tex.width, tex.height);\n        // tempMat.prepend(lt);\n        // tempMat.scale(1.0 / ts._width, 1.0 / ts._height);\n\n        tempMat.invert();\n        if (isSimple)\n        {\n            tempMat.prepend(uv.mapCoord);\n        }\n        else\n        {\n            shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n            shader.uniforms.uClampFrame = uv.uClampFrame;\n            shader.uniforms.uClampOffset = uv.uClampOffset;\n        }\n\n        shader.uniforms.uTransform = tempMat.toArray(true);\n        shader.uniforms.uColor = utils.premultiplyTintToRgba(ts.tint, ts.worldAlpha,\n            shader.uniforms.uColor, premultiplied);\n        shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);\n        shader.uniforms.uSampler = tex;\n\n        renderer.shader.bind(shader);\n        renderer.geometry.bind(quad);\n\n        this.state.blendMode = utils.correctBlendMode(ts.blendMode, premultiplied);\n        renderer.state.set(this.state);\n        renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n    }\n}\n\nextensions.add(TilingSpriteRenderer);\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}