{"ast":null,"code":"import { ALPHA_MODES } from '@pixi/constants';\nimport { settings } from '@pixi/settings';\nimport { BaseImageResource } from './BaseImageResource.mjs';\nclass ImageBitmapResource extends BaseImageResource {\n  constructor(source, options) {\n    var _options$crossOrigin;\n    options = options || {};\n    let baseSource;\n    let url;\n    if (typeof source === \"string\") {\n      baseSource = ImageBitmapResource.EMPTY;\n      url = source;\n    } else {\n      baseSource = source;\n      url = null;\n    }\n    super(baseSource);\n    this.url = url;\n    this.crossOrigin = (_options$crossOrigin = options.crossOrigin) !== null && _options$crossOrigin !== void 0 ? _options$crossOrigin : true;\n    this.alphaMode = typeof options.alphaMode === \"number\" ? options.alphaMode : null;\n    this._load = null;\n    if (options.autoLoad !== false) {\n      this.load();\n    }\n  }\n  load() {\n    if (this._load) {\n      return this._load;\n    }\n    this._load = new Promise(async (resolve, reject) => {\n      if (this.url === null) {\n        resolve(this);\n        return;\n      }\n      try {\n        const response = await settings.ADAPTER.fetch(this.url, {\n          mode: this.crossOrigin ? \"cors\" : \"no-cors\"\n        });\n        if (this.destroyed) return;\n        const imageBlob = await response.blob();\n        if (this.destroyed) return;\n        const imageBitmap = await createImageBitmap(imageBlob, {\n          premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? \"premultiply\" : \"none\"\n        });\n        if (this.destroyed) return;\n        this.source = imageBitmap;\n        this.update();\n        resolve(this);\n      } catch (e) {\n        if (this.destroyed) return;\n        reject(e);\n        this.onError.emit(e);\n      }\n    });\n    return this._load;\n  }\n  upload(renderer, baseTexture, glTexture) {\n    if (!(this.source instanceof ImageBitmap)) {\n      this.load();\n      return false;\n    }\n    if (typeof this.alphaMode === \"number\") {\n      baseTexture.alphaMode = this.alphaMode;\n    }\n    return super.upload(renderer, baseTexture, glTexture);\n  }\n  dispose() {\n    if (this.source instanceof ImageBitmap) {\n      this.source.close();\n    }\n    super.dispose();\n    this._load = null;\n  }\n  static test(source) {\n    return !!globalThis.createImageBitmap && typeof ImageBitmap !== \"undefined\" && (typeof source === \"string\" || source instanceof ImageBitmap);\n  }\n  static get EMPTY() {\n    var _ImageBitmapResource$;\n    ImageBitmapResource._EMPTY = (_ImageBitmapResource$ = ImageBitmapResource._EMPTY) !== null && _ImageBitmapResource$ !== void 0 ? _ImageBitmapResource$ : settings.ADAPTER.createCanvas(0, 0);\n    return ImageBitmapResource._EMPTY;\n  }\n}\nexport { ImageBitmapResource };","map":{"version":3,"mappings":";;;AAyBO,MAAMA,4BAA4BC,iBACzC;EA+BIC,YAAYC,QAA8BC,OAC1C;IAAA;IACIA,UAAUA,WAAW,EAAC;IAElB;IACA;IAEA,WAAOD,WAAW,QACtB;MACIE,aAAaL,mBAAoB;MAC3BM;IAAA,CAGV;MACiBD;MACPC;IAAA;IAIV,MAAMD,UAAU;IAChB,KAAKC,GAAM;IAEN,2CAAcF,QAAQG,WAAe;IAC1C,KAAKC,YAAY,OAAOJ,QAAQI,SAAc,gBAAWJ,QAAQI,SAAY;IAE7E,KAAKC,KAAQ;IAET,YAAQC,aAAa,KACzB;MACI,KAAKC,IAAK;IAAA;EACd;EAGJA,IACAA;IACI,IAAI,KAAKF,KACT;MACI,OAAO,IAAK;IAAA;IAGhB,KAAKA,KAAQ,OAAIG,OAAQ,QAAOC,SAASC,MACzC;MACQ,SAAKR,QAAQ,IACjB;QACIO,QAAQ,IAAI;QAEZ;MAAA;MAIJ;QACI,MAAME,WAAW,MAAMC,SAASC,OAAQ,OAAM,KAAKX,GAAK;UACpDY,MAAM,IAAK,eAAc,MAAS;QAAA,CACrC;QAED,IAAI,IAAK,YAAW;QAEd,kBAAY,MAAMH,SAASI,IAAK;QAEtC,IAAI,IAAK,YAAW;QAEd,oBAAc,MAAMC,kBAAkBC,SAAW;UACnDC,kBAAkB,KAAKd,SAAc,aAAQ,KAAKA,SAAc,iBAAYe,SACtE,aAAgB;QAAA,CACzB;QAED,IAAI,IAAK,YAAW;QAEpB,KAAKpB,MAAS;QACd,KAAKqB,MAAO;QAEZX,QAAQ,IAAI;MAAA,SAETY,CAAP;QAEI,IAAI,IAAK,YAAW;QAEpBX,OAAOW,CAAC;QACH,aAAQC,KAAKD,CAAC;MAAA;IACvB,CACH;IAED,OAAO,IAAK;EAAA;EAUhBE,MAASA,CAAOC,QAAoB,eAA0BC,SAC9D;IACQ,MAAO,uBAAkBC,WAC7B;MACI,KAAKnB,IAAK;MAEH;IAAA;IAGP,WAAO,IAAK,eAAc,QAC9B;MACIoB,YAAYvB,YAAY,IAAK;IAAA;IAGjC,OAAO,KAAM,QAAOoB,QAAU,eAAaC,SAAS;EAAA;EAIxDG,OACAA;IACQ,SAAK7B,kBAAkB2B,WAC3B;MACI,KAAK3B,OAAO8B,KAAM;IAAA;IAGtB,MAAMD,OAAQ;IAEd,KAAKvB,KAAQ;EAAA;EAQjB,OAAgByB,KAAK/B,MACrB;IACW,QAAC,CAACgC,WAAWf,iBAAqB,WAAOU,gBAAgB,WACxD,YAAO3B,MAAW,iBAAYA,MAAkB;EAAA;EAc5D,WAAmBiC,KACnBA;IAAA;IACIpC,oBAAoBqC,kCAASrC,mBAAoB,gFAAUgB,SAASC,OAAQ,cAAa,GAAG,CAAC;IAE7F,OAAOjB,mBAAoB;EAAA;AAEnC","names":["ImageBitmapResource","BaseImageResource","constructor","source","options","baseSource","url","crossOrigin","alphaMode","_load","autoLoad","load","Promise","resolve","reject","response","settings","ADAPTER","mode","blob","createImageBitmap","imageBlob","premultiplyAlpha","UNPACK","update","e","emit","upload","renderer","glTexture","ImageBitmap","baseTexture","dispose","close","test","globalThis","EMPTY","_EMPTY"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/core/src/textures/resources/ImageBitmapResource.ts"],"sourcesContent":["import { ALPHA_MODES } from '@pixi/constants';\nimport { settings } from '@pixi/settings';\nimport { BaseImageResource } from './BaseImageResource';\n\nimport type { ICanvas } from '@pixi/settings';\nimport type { Renderer } from '../../Renderer';\nimport type { BaseTexture } from '../BaseTexture';\nimport type { GLTexture } from '../GLTexture';\n\nexport interface IImageBitmapResourceOptions\n{\n    /** Start loading process automatically when constructed. */\n    autoLoad?: boolean;\n\n    /** Load image using cross origin. */\n    crossOrigin?: boolean;\n\n    /** Alpha mode used when creating the ImageBitmap. */\n    alphaMode?: ALPHA_MODES;\n}\n\n/**\n * Resource type for ImageBitmap.\n * @memberof PIXI\n */\nexport class ImageBitmapResource extends BaseImageResource\n{\n    /** URL of the image source. */\n    url: string | null;\n\n    /**\n     * Load image using cross origin.\n     * @default false\n     */\n    crossOrigin: boolean;\n\n    /**\n     * Controls texture alphaMode field\n     * Copies from options\n     * Default is `null`, copies option from baseTexture\n     * @readonly\n     */\n    alphaMode: ALPHA_MODES | null;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<ImageBitmapResource>;\n\n    /**\n     * @param source - ImageBitmap or URL to use\n     * @param options\n     * @param {boolean} [options.autoLoad=true] - Start loading process automatically when constructed.\n     * @param {boolean} [options.crossOrigin=true] - Load image using cross origin.\n     * @param {PIXI.ALPHA_MODES} [options.alphaMode=null] - Alpha mode used when creating the ImageBitmap.\n     */\n    constructor(source: ImageBitmap | string, options?: IImageBitmapResourceOptions)\n    {\n        options = options || {};\n\n        let baseSource;\n        let url;\n\n        if (typeof source === 'string')\n        {\n            baseSource = ImageBitmapResource.EMPTY;\n            url = source;\n        }\n        else\n        {\n            baseSource = source;\n            url = null;\n        }\n        // Using super() in if() can cause transpilation problems in some cases, so take it out of if().\n        // See https://github.com/pixijs/pixijs/pull/9093 for details.\n        super(baseSource);\n        this.url = url;\n\n        this.crossOrigin = options.crossOrigin ?? true;\n        this.alphaMode = typeof options.alphaMode === 'number' ? options.alphaMode : null;\n\n        this._load = null;\n\n        if (options.autoLoad !== false)\n        {\n            this.load();\n        }\n    }\n\n    load(): Promise<ImageBitmapResource>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        this._load = new Promise(async (resolve, reject) =>\n        {\n            if (this.url === null)\n            {\n                resolve(this);\n\n                return;\n            }\n\n            try\n            {\n                const response = await settings.ADAPTER.fetch(this.url, {\n                    mode: this.crossOrigin ? 'cors' : 'no-cors'\n                });\n\n                if (this.destroyed) return;\n\n                const imageBlob = await response.blob();\n\n                if (this.destroyed) return;\n\n                const imageBitmap = await createImageBitmap(imageBlob, {\n                    premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK\n                        ? 'premultiply' : 'none',\n                });\n\n                if (this.destroyed) return;\n\n                this.source = imageBitmap;\n                this.update();\n\n                resolve(this);\n            }\n            catch (e)\n            {\n                if (this.destroyed) return;\n\n                reject(e);\n                this.onError.emit(e);\n            }\n        });\n\n        return this._load;\n    }\n\n    /**\n     * Upload the image bitmap resource to GPU.\n     * @param renderer - Renderer to upload to\n     * @param baseTexture - BaseTexture for this resource\n     * @param glTexture - GLTexture to use\n     * @returns {boolean} true is success\n     */\n    override upload(renderer: Renderer, baseTexture: BaseTexture, glTexture: GLTexture): boolean\n    {\n        if (!(this.source instanceof ImageBitmap))\n        {\n            this.load();\n\n            return false;\n        }\n\n        if (typeof this.alphaMode === 'number')\n        {\n            baseTexture.alphaMode = this.alphaMode;\n        }\n\n        return super.upload(renderer, baseTexture, glTexture);\n    }\n\n    /** Destroys this resource. */\n    override dispose(): void\n    {\n        if (this.source instanceof ImageBitmap)\n        {\n            this.source.close();\n        }\n\n        super.dispose();\n\n        this._load = null;\n    }\n\n    /**\n     * Used to auto-detect the type of resource.\n     * @param {*} source - The source object\n     * @returns {boolean} `true` if current environment support ImageBitmap, and source is string or ImageBitmap\n     */\n    static override test(source: unknown): source is string | ImageBitmap\n    {\n        return !!globalThis.createImageBitmap && typeof ImageBitmap !== 'undefined'\n            && (typeof source === 'string' || source instanceof ImageBitmap);\n    }\n\n    /**\n     * Cached empty placeholder canvas.\n     * @see EMPTY\n     */\n    private static _EMPTY: ICanvas;\n\n    /**\n     * ImageBitmap cannot be created synchronously, so a empty placeholder canvas is needed when loading from URLs.\n     * Only for internal usage.\n     * @returns The cached placeholder canvas.\n     */\n    private static get EMPTY(): ICanvas\n    {\n        ImageBitmapResource._EMPTY = ImageBitmapResource._EMPTY ?? settings.ADAPTER.createCanvas(0, 0);\n\n        return ImageBitmapResource._EMPTY;\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}