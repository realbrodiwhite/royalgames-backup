{"ast":null,"code":"import { ObservablePoint, settings, Point, Texture, utils, BLEND_MODES, Program } from '@pixi/core';\nimport { Container } from '@pixi/display';\nimport { MeshGeometry, MeshMaterial, Mesh } from '@pixi/mesh';\nimport { BitmapFont } from './BitmapFont.mjs';\nimport msdfFrag from './shader/msdf.mjs';\nimport msdfVert from './shader/msdf2.mjs';\nimport './utils/index.mjs';\nimport { splitTextToCharacters } from './utils/splitTextToCharacters.mjs';\nimport { extractCharCode } from './utils/extractCharCode.mjs';\nconst pageMeshDataDefaultPageMeshData = [];\nconst pageMeshDataMSDFPageMeshData = [];\nconst charRenderDataPool = [];\nconst _BitmapText = class extends Container {\n  constructor(text) {\n    let style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this._tint = 16777215;\n    const {\n      align,\n      tint,\n      maxWidth,\n      letterSpacing,\n      fontName,\n      fontSize\n    } = Object.assign({}, _BitmapText.styleDefaults, style);\n    if (!BitmapFont.available[fontName]) {\n      throw new Error(\"Missing BitmapFont \\\"\".concat(fontName, \"\\\"\"));\n    }\n    this._activePagesMeshData = [];\n    this._textWidth = 0;\n    this._textHeight = 0;\n    this._align = align;\n    this._tint = tint;\n    this._font = void 0;\n    this._fontName = fontName;\n    this._fontSize = fontSize;\n    this.text = text;\n    this._maxWidth = maxWidth;\n    this._maxLineHeight = 0;\n    this._letterSpacing = letterSpacing;\n    this._anchor = new ObservablePoint(() => {\n      this.dirty = true;\n    }, this, 0, 0);\n    this._roundPixels = settings.ROUND_PIXELS;\n    this.dirty = true;\n    this._resolution = settings.RESOLUTION;\n    this._autoResolution = true;\n    this._textureCache = {};\n  }\n  updateText() {\n    const data = BitmapFont.available[this._fontName];\n    const fontSize = this.fontSize;\n    const scale = fontSize / data.size;\n    const pos = new Point();\n    const chars = [];\n    const lineWidths = [];\n    const lineSpaces = [];\n    const text = this._text.replace(/(?:\\r\\n|\\r)/g, \"\\n\") || \" \";\n    const charsInput = splitTextToCharacters(text);\n    const maxWidth = this._maxWidth * data.size / fontSize;\n    const pageMeshDataPool = data.distanceFieldType === \"none\" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n    let prevCharCode = null;\n    let lastLineWidth = 0;\n    let maxLineWidth = 0;\n    let line = 0;\n    let lastBreakPos = -1;\n    let lastBreakWidth = 0;\n    let spacesRemoved = 0;\n    let maxLineHeight = 0;\n    let spaceCount = 0;\n    for (let i = 0; i < charsInput.length; i++) {\n      const char = charsInput[i];\n      const charCode = extractCharCode(char);\n      if (/(?:\\s)/.test(char)) {\n        lastBreakPos = i;\n        lastBreakWidth = lastLineWidth;\n        spaceCount++;\n      }\n      if (char === \"\\r\" || char === \"\\n\") {\n        lineWidths.push(lastLineWidth);\n        lineSpaces.push(-1);\n        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n        ++line;\n        ++spacesRemoved;\n        pos.x = 0;\n        pos.y += data.lineHeight;\n        prevCharCode = null;\n        spaceCount = 0;\n        continue;\n      }\n      const charData = data.chars[charCode];\n      if (!charData) {\n        continue;\n      }\n      if (prevCharCode && charData.kerning[prevCharCode]) {\n        pos.x += charData.kerning[prevCharCode];\n      }\n      const charRenderData = charRenderDataPool.pop() || {\n        texture: Texture.EMPTY,\n        line: 0,\n        charCode: 0,\n        prevSpaces: 0,\n        position: new Point()\n      };\n      charRenderData.texture = charData.texture;\n      charRenderData.line = line;\n      charRenderData.charCode = charCode;\n      charRenderData.position.x = Math.round(pos.x + charData.xOffset + this._letterSpacing / 2);\n      charRenderData.position.y = Math.round(pos.y + charData.yOffset);\n      charRenderData.prevSpaces = spaceCount;\n      chars.push(charRenderData);\n      lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);\n      pos.x += charData.xAdvance + this._letterSpacing;\n      maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);\n      prevCharCode = charCode;\n      if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {\n        ++spacesRemoved;\n        utils.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);\n        i = lastBreakPos;\n        lastBreakPos = -1;\n        lineWidths.push(lastBreakWidth);\n        lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);\n        maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);\n        line++;\n        pos.x = 0;\n        pos.y += data.lineHeight;\n        prevCharCode = null;\n        spaceCount = 0;\n      }\n    }\n    const lastChar = charsInput[charsInput.length - 1];\n    if (lastChar !== \"\\r\" && lastChar !== \"\\n\") {\n      if (/(?:\\s)/.test(lastChar)) {\n        lastLineWidth = lastBreakWidth;\n      }\n      lineWidths.push(lastLineWidth);\n      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n      lineSpaces.push(-1);\n    }\n    const lineAlignOffsets = [];\n    for (let i = 0; i <= line; i++) {\n      let alignOffset = 0;\n      if (this._align === \"right\") {\n        alignOffset = maxLineWidth - lineWidths[i];\n      } else if (this._align === \"center\") {\n        alignOffset = (maxLineWidth - lineWidths[i]) / 2;\n      } else if (this._align === \"justify\") {\n        alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i];\n      }\n      lineAlignOffsets.push(alignOffset);\n    }\n    const lenChars = chars.length;\n    const pagesMeshData = {};\n    const newPagesMeshData = [];\n    const activePagesMeshData = this._activePagesMeshData;\n    pageMeshDataPool.push(...activePagesMeshData);\n    for (let i = 0; i < lenChars; i++) {\n      const texture = chars[i].texture;\n      const baseTextureUid = texture.baseTexture.uid;\n      if (!pagesMeshData[baseTextureUid]) {\n        let pageMeshData = pageMeshDataPool.pop();\n        if (!pageMeshData) {\n          const geometry = new MeshGeometry();\n          let material;\n          let meshBlendMode;\n          if (data.distanceFieldType === \"none\") {\n            material = new MeshMaterial(Texture.EMPTY);\n            meshBlendMode = BLEND_MODES.NORMAL;\n          } else {\n            material = new MeshMaterial(Texture.EMPTY, {\n              program: Program.from(msdfVert, msdfFrag),\n              uniforms: {\n                uFWidth: 0\n              }\n            });\n            meshBlendMode = BLEND_MODES.NORMAL_NPM;\n          }\n          const mesh = new Mesh(geometry, material);\n          mesh.blendMode = meshBlendMode;\n          pageMeshData = {\n            index: 0,\n            indexCount: 0,\n            vertexCount: 0,\n            uvsCount: 0,\n            total: 0,\n            mesh,\n            vertices: null,\n            uvs: null,\n            indices: null\n          };\n        }\n        pageMeshData.index = 0;\n        pageMeshData.indexCount = 0;\n        pageMeshData.vertexCount = 0;\n        pageMeshData.uvsCount = 0;\n        pageMeshData.total = 0;\n        const {\n          _textureCache\n        } = this;\n        _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);\n        pageMeshData.mesh.texture = _textureCache[baseTextureUid];\n        pageMeshData.mesh.tint = this._tint;\n        newPagesMeshData.push(pageMeshData);\n        pagesMeshData[baseTextureUid] = pageMeshData;\n      }\n      pagesMeshData[baseTextureUid].total++;\n    }\n    for (let i = 0; i < activePagesMeshData.length; i++) {\n      if (!newPagesMeshData.includes(activePagesMeshData[i])) {\n        this.removeChild(activePagesMeshData[i].mesh);\n      }\n    }\n    for (let i = 0; i < newPagesMeshData.length; i++) {\n      if (newPagesMeshData[i].mesh.parent !== this) {\n        this.addChild(newPagesMeshData[i].mesh);\n      }\n    }\n    this._activePagesMeshData = newPagesMeshData;\n    for (const i in pagesMeshData) {\n      var _pageMeshData$indices;\n      const pageMeshData = pagesMeshData[i];\n      const total = pageMeshData.total;\n      if (!(((_pageMeshData$indices = pageMeshData.indices) === null || _pageMeshData$indices === void 0 ? void 0 : _pageMeshData$indices.length) > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2) {\n        pageMeshData.vertices = new Float32Array(4 * 2 * total);\n        pageMeshData.uvs = new Float32Array(4 * 2 * total);\n        pageMeshData.indices = new Uint16Array(6 * total);\n      } else {\n        const total2 = pageMeshData.total;\n        const vertices = pageMeshData.vertices;\n        for (let i2 = total2 * 4 * 2; i2 < vertices.length; i2++) {\n          vertices[i2] = 0;\n        }\n      }\n      pageMeshData.mesh.size = 6 * total;\n    }\n    for (let i = 0; i < lenChars; i++) {\n      const char = chars[i];\n      let offset = char.position.x + lineAlignOffsets[char.line] * (this._align === \"justify\" ? char.prevSpaces : 1);\n      if (this._roundPixels) {\n        offset = Math.round(offset);\n      }\n      const xPos = offset * scale;\n      const yPos = char.position.y * scale;\n      const texture = char.texture;\n      const pageMesh = pagesMeshData[texture.baseTexture.uid];\n      const textureFrame = texture.frame;\n      const textureUvs = texture._uvs;\n      const index = pageMesh.index++;\n      pageMesh.indices[index * 6 + 0] = 0 + index * 4;\n      pageMesh.indices[index * 6 + 1] = 1 + index * 4;\n      pageMesh.indices[index * 6 + 2] = 2 + index * 4;\n      pageMesh.indices[index * 6 + 3] = 0 + index * 4;\n      pageMesh.indices[index * 6 + 4] = 2 + index * 4;\n      pageMesh.indices[index * 6 + 5] = 3 + index * 4;\n      pageMesh.vertices[index * 8 + 0] = xPos;\n      pageMesh.vertices[index * 8 + 1] = yPos;\n      pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale;\n      pageMesh.vertices[index * 8 + 3] = yPos;\n      pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale;\n      pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale;\n      pageMesh.vertices[index * 8 + 6] = xPos;\n      pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale;\n      pageMesh.uvs[index * 8 + 0] = textureUvs.x0;\n      pageMesh.uvs[index * 8 + 1] = textureUvs.y0;\n      pageMesh.uvs[index * 8 + 2] = textureUvs.x1;\n      pageMesh.uvs[index * 8 + 3] = textureUvs.y1;\n      pageMesh.uvs[index * 8 + 4] = textureUvs.x2;\n      pageMesh.uvs[index * 8 + 5] = textureUvs.y2;\n      pageMesh.uvs[index * 8 + 6] = textureUvs.x3;\n      pageMesh.uvs[index * 8 + 7] = textureUvs.y3;\n    }\n    this._textWidth = maxLineWidth * scale;\n    this._textHeight = (pos.y + data.lineHeight) * scale;\n    for (const i in pagesMeshData) {\n      const pageMeshData = pagesMeshData[i];\n      if (this.anchor.x !== 0 || this.anchor.y !== 0) {\n        let vertexCount = 0;\n        const anchorOffsetX = this._textWidth * this.anchor.x;\n        const anchorOffsetY = this._textHeight * this.anchor.y;\n        for (let i2 = 0; i2 < pageMeshData.total; i2++) {\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n        }\n      }\n      this._maxLineHeight = maxLineHeight * scale;\n      const vertexBuffer = pageMeshData.mesh.geometry.getBuffer(\"aVertexPosition\");\n      const textureBuffer = pageMeshData.mesh.geometry.getBuffer(\"aTextureCoord\");\n      const indexBuffer = pageMeshData.mesh.geometry.getIndex();\n      vertexBuffer.data = pageMeshData.vertices;\n      textureBuffer.data = pageMeshData.uvs;\n      indexBuffer.data = pageMeshData.indices;\n      vertexBuffer.update();\n      textureBuffer.update();\n      indexBuffer.update();\n    }\n    for (let i = 0; i < chars.length; i++) {\n      charRenderDataPool.push(chars[i]);\n    }\n    this._font = data;\n    this.dirty = false;\n  }\n  updateTransform() {\n    this.validate();\n    this.containerUpdateTransform();\n  }\n  _render(renderer) {\n    if (this._autoResolution && this._resolution !== renderer.resolution) {\n      this._resolution = renderer.resolution;\n      this.dirty = true;\n    }\n    const {\n      distanceFieldRange,\n      distanceFieldType,\n      size\n    } = BitmapFont.available[this._fontName];\n    if (distanceFieldType !== \"none\") {\n      const {\n        a,\n        b,\n        c,\n        d\n      } = this.worldTransform;\n      const dx = Math.sqrt(a * a + b * b);\n      const dy = Math.sqrt(c * c + d * d);\n      const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n      const fontScale = this.fontSize / size;\n      const resolution = renderer._view.resolution;\n      for (const mesh of this._activePagesMeshData) {\n        mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;\n      }\n    }\n    super._render(renderer);\n  }\n  getLocalBounds() {\n    this.validate();\n    return super.getLocalBounds();\n  }\n  validate() {\n    const font = BitmapFont.available[this._fontName];\n    if (!font) {\n      throw new Error(\"Missing BitmapFont \\\"\".concat(this._fontName, \"\\\"\"));\n    }\n    if (this._font !== font) {\n      this.dirty = true;\n    }\n    if (this.dirty) {\n      this.updateText();\n    }\n  }\n  get tint() {\n    return this._tint;\n  }\n  set tint(value) {\n    if (this._tint === value) return;\n    this._tint = value;\n    for (let i = 0; i < this._activePagesMeshData.length; i++) {\n      this._activePagesMeshData[i].mesh.tint = value;\n    }\n  }\n  get align() {\n    return this._align;\n  }\n  set align(value) {\n    if (this._align !== value) {\n      this._align = value;\n      this.dirty = true;\n    }\n  }\n  get fontName() {\n    return this._fontName;\n  }\n  set fontName(value) {\n    if (!BitmapFont.available[value]) {\n      throw new Error(\"Missing BitmapFont \\\"\".concat(value, \"\\\"\"));\n    }\n    if (this._fontName !== value) {\n      this._fontName = value;\n      this.dirty = true;\n    }\n  }\n  get fontSize() {\n    var _this$_fontSize;\n    return (_this$_fontSize = this._fontSize) !== null && _this$_fontSize !== void 0 ? _this$_fontSize : BitmapFont.available[this._fontName].size;\n  }\n  set fontSize(value) {\n    if (this._fontSize !== value) {\n      this._fontSize = value;\n      this.dirty = true;\n    }\n  }\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    if (typeof value === \"number\") {\n      this._anchor.set(value);\n    } else {\n      this._anchor.copyFrom(value);\n    }\n  }\n  get text() {\n    return this._text;\n  }\n  set text(text) {\n    text = String(text === null || text === void 0 ? \"\" : text);\n    if (this._text === text) {\n      return;\n    }\n    this._text = text;\n    this.dirty = true;\n  }\n  get maxWidth() {\n    return this._maxWidth;\n  }\n  set maxWidth(value) {\n    if (this._maxWidth === value) {\n      return;\n    }\n    this._maxWidth = value;\n    this.dirty = true;\n  }\n  get maxLineHeight() {\n    this.validate();\n    return this._maxLineHeight;\n  }\n  get textWidth() {\n    this.validate();\n    return this._textWidth;\n  }\n  get letterSpacing() {\n    return this._letterSpacing;\n  }\n  set letterSpacing(value) {\n    if (this._letterSpacing !== value) {\n      this._letterSpacing = value;\n      this.dirty = true;\n    }\n  }\n  get roundPixels() {\n    return this._roundPixels;\n  }\n  set roundPixels(value) {\n    if (value !== this._roundPixels) {\n      this._roundPixels = value;\n      this.dirty = true;\n    }\n  }\n  get textHeight() {\n    this.validate();\n    return this._textHeight;\n  }\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(value) {\n    this._autoResolution = false;\n    if (this._resolution === value) {\n      return;\n    }\n    this._resolution = value;\n    this.dirty = true;\n  }\n  destroy(options) {\n    const {\n      _textureCache\n    } = this;\n    const data = BitmapFont.available[this._fontName];\n    const pageMeshDataPool = data.distanceFieldType === \"none\" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n    pageMeshDataPool.push(...this._activePagesMeshData);\n    for (const pageMeshData of this._activePagesMeshData) {\n      this.removeChild(pageMeshData.mesh);\n    }\n    this._activePagesMeshData = [];\n    pageMeshDataPool.filter(page => _textureCache[page.mesh.texture.baseTexture.uid]).forEach(page => {\n      page.mesh.texture = Texture.EMPTY;\n    });\n    for (const id in _textureCache) {\n      const texture = _textureCache[id];\n      texture.destroy();\n      delete _textureCache[id];\n    }\n    this._font = null;\n    this._textureCache = null;\n    super.destroy(options);\n  }\n};\nlet BitmapText = _BitmapText;\nBitmapText.styleDefaults = {\n  align: \"left\",\n  tint: 16777215,\n  maxWidth: 0,\n  letterSpacing: 0\n};\nexport { BitmapText };","map":{"version":3,"mappings":"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","names":["pageMeshDataDefaultPageMeshData","pageMeshDataMSDFPageMeshData","charRenderDataPool","_BitmapText","Container","constructor","style","_tint","align","tint","maxWidth","letterSpacing","fontName","fontSize","assign","styleDefaults","BitmapFont","Error","_activePagesMeshData","_textWidth","_textHeight","_align","_font","_fontName","_fontSize","text","_maxWidth","_maxLineHeight","_letterSpacing","ObservablePoint","dirty","_roundPixels","settings","_resolution","_autoResolution","_textureCache","updateText","data","Point","chars","lineWidths","lineSpaces","replace","splitTextToCharacters","size","pageMeshDataPool","distanceFieldType","prevCharCode","lastLineWidth","maxLineWidth","line","lastBreakPos","lastBreakWidth","spacesRemoved","maxLineHeight","spaceCount","i","length","char","charsInput","extractCharCode","test","push","max","pos","x","y","charData","kerning","texture","Texture","charCode","prevSpaces","position","charRenderData","round","yOffset","xAdvance","xOffset","width","Math","height","utils","removeItems","lineAlignOffsets","alignOffset","lenChars","pagesMeshData","newPagesMeshData","activePagesMeshData","baseTexture","baseTextureUid","pop","pageMeshData","MeshGeometry","material","MeshMaterial","EMPTY","meshBlendMode","BLEND_MODES","program","Program","msdfVert","uniforms","uFWidth","mesh","Mesh","blendMode","index","indexCount","vertexCount","uvsCount","total","vertices","uvs","indices","includes","Float32Array","Uint16Array","total2","i2","offset","xPos","textureFrame","textureUvs","pageMesh","lineHeight","anchor","anchorOffsetX","anchorOffsetY","vertexBuffer","getBuffer","textureBuffer","indexBuffer","getIndex","update","updateTransform","validate","containerUpdateTransform","_render","renderer","resolution","distanceFieldRange","available","a","b","c","d","dx","dy","abs","_view","shader","fontScale","getLocalBounds","font","value","set","copyFrom","String","_text","textWidth","roundPixels","textHeight","destroy","options","filter","page","uid","forEach","id","BitmapText"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/text-bitmap/src/BitmapText.ts"],"sourcesContent":["import { BLEND_MODES, ObservablePoint, Point, Program, settings, Texture, utils } from '@pixi/core';\nimport { Container } from '@pixi/display';\nimport { Mesh, MeshGeometry, MeshMaterial } from '@pixi/mesh';\nimport { BitmapFont } from './BitmapFont';\nimport msdfFrag from './shader/msdf.frag';\nimport msdfVert from './shader/msdf.vert';\nimport { extractCharCode, splitTextToCharacters } from './utils';\n\nimport type { Rectangle, Renderer } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\nimport type { TextStyleAlign } from '@pixi/text';\nimport type { IBitmapTextStyle } from './BitmapTextStyle';\n\ninterface PageMeshData\n{\n    index: number;\n    indexCount: number;\n    vertexCount: number;\n    uvsCount: number;\n    total: number;\n    mesh: Mesh;\n    vertices?: Float32Array;\n    uvs?: Float32Array;\n    indices?: Uint16Array;\n}\ninterface CharRenderData\n{\n    texture: Texture;\n    line: number;\n    charCode: number;\n    position: Point;\n    prevSpaces: number;\n}\n\n// If we ever need more than two pools, please make a Dict or something better.\nconst pageMeshDataDefaultPageMeshData: PageMeshData[] = [];\nconst pageMeshDataMSDFPageMeshData: PageMeshData[] = [];\nconst charRenderDataPool: CharRenderData[] = [];\n\n/**\n * A BitmapText object will create a line or multiple lines of text using bitmap font.\n *\n * The primary advantage of this class over Text is that all of your textures are pre-generated and loading,\n * meaning that rendering is fast, and changing text has no performance implications.\n *\n * Supporting character sets other than latin, such as CJK languages, may be impractical due to the number of characters.\n *\n * To split a line you can use '\\n', '\\r' or '\\r\\n' in your string.\n *\n * PixiJS can auto-generate fonts on-the-fly using BitmapFont or use fnt files provided by:\n * http://www.angelcode.com/products/bmfont/ for Windows or\n * http://www.bmglyph.com/ for Mac.\n *\n * You can also use SDF, MSDF and MTSDF BitmapFonts for vector-like scaling appearance provided by:\n * https://github.com/soimy/msdf-bmfont-xml for SDF and MSDF fnt files or\n * https://github.com/Chlumsky/msdf-atlas-gen for SDF, MSDF and MTSDF json files\n *\n * A BitmapText can only be created when the font is loaded.\n * @example\n * import { BitmapText } from 'pixi.js';\n *\n * // in this case the font is in a file called 'desyrel.fnt'\n * const bitmapText = new BitmapText('text using a fancy font!', {\n *     fontName: 'Desyrel',\n *     fontSize: 35,\n *     align: 'right',\n * });\n * @memberof PIXI\n */\nexport class BitmapText extends Container\n{\n    public static styleDefaults: Partial<IBitmapTextStyle> = {\n        align: 'left',\n        tint: 0xFFFFFF,\n        maxWidth: 0,\n        letterSpacing: 0,\n    };\n\n    /** Set to `true` if the BitmapText needs to be redrawn. */\n    public dirty: boolean;\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     *\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @default PIXI.settings.RESOLUTION\n     */\n    _resolution: number;\n    _autoResolution: boolean;\n\n    /**\n     * Private tracker for the width of the overall text.\n     * @private\n     */\n    protected _textWidth: number;\n\n    /**\n     * Private tracker for the height of the overall text.\n     * @private\n     */\n    protected _textHeight: number;\n\n    /**\n     * Private tracker for the current text.\n     * @private\n     */\n    protected _text: string;\n\n    /**\n     * The max width of this bitmap text in pixels. If the text provided is longer than the\n     * value provided, line breaks will be automatically inserted in the last whitespace.\n     * Disable by setting value to 0\n     * @private\n     */\n    protected _maxWidth: number;\n\n    /**\n     * The max line height. This is useful when trying to use the total height of the Text,\n     * ie: when trying to vertically align. (Internally used)\n     * @private\n     */\n    protected _maxLineHeight: number;\n\n    /**\n     * Letter spacing. This is useful for setting the space between characters.\n     * @private\n     */\n    protected _letterSpacing: number;\n\n    /**\n     * Text anchor.\n     * @readonly\n     * @private\n     */\n    protected _anchor: ObservablePoint;\n\n    /**\n     * Private tracker for the current font.\n     * @private\n     */\n    protected _font?: BitmapFont;\n\n    /**\n     * Private tracker for the current font name.\n     * @private\n     */\n    protected _fontName: string;\n\n    /**\n     * Private tracker for the current font size.\n     * @private\n     */\n    protected _fontSize?: number;\n\n    /**\n     * Private tracker for the current text align.\n     * @type {string}\n     * @private\n     */\n    protected _align: TextStyleAlign;\n\n    /** Collection of page mesh data. */\n    protected _activePagesMeshData: PageMeshData[];\n\n    /**\n     * Private tracker for the current tint.\n     * @private\n     */\n    protected _tint = 0xFFFFFF;\n\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering.\n     * @default PIXI.settings.ROUND_PIXELS\n     */\n    protected _roundPixels: boolean;\n\n    /** Cached char texture is destroyed when BitmapText is destroyed. */\n    private _textureCache: Record<number, Texture>;\n\n    /**\n     * @param text - A string that you would like the text to display.\n     * @param style - The style parameters.\n     * @param {string} style.fontName - The installed BitmapFont name.\n     * @param {number} [style.fontSize] - The size of the font in pixels, e.g. 24. If undefined,\n     *.     this will default to the BitmapFont size.\n     * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center', 'right' or 'justify'),\n     *      does not affect single line text.\n     * @param {number} [style.tint=0xFFFFFF] - The tint color.\n     * @param {number} [style.letterSpacing=0] - The amount of spacing between letters.\n     * @param {number} [style.maxWidth=0] - The max width of the text before line wrapping.\n     */\n    constructor(text: string, style: Partial<IBitmapTextStyle> = {})\n    {\n        super();\n\n        // Apply the defaults\n        const { align, tint, maxWidth, letterSpacing, fontName, fontSize } = Object.assign(\n            {}, BitmapText.styleDefaults, style);\n\n        if (!BitmapFont.available[fontName])\n        {\n            throw new Error(`Missing BitmapFont \"${fontName}\"`);\n        }\n\n        this._activePagesMeshData = [];\n        this._textWidth = 0;\n        this._textHeight = 0;\n        this._align = align;\n        this._tint = tint;\n        this._font = undefined;\n        this._fontName = fontName;\n        this._fontSize = fontSize;\n        this.text = text;\n        this._maxWidth = maxWidth;\n        this._maxLineHeight = 0;\n        this._letterSpacing = letterSpacing;\n        this._anchor = new ObservablePoint((): void => { this.dirty = true; }, this, 0, 0);\n        this._roundPixels = settings.ROUND_PIXELS;\n        this.dirty = true;\n        this._resolution = settings.RESOLUTION;\n        this._autoResolution = true;\n        this._textureCache = {};\n    }\n\n    /** Renders text and updates it when needed. This should only be called if the BitmapFont is regenerated. */\n    public updateText(): void\n    {\n        const data = BitmapFont.available[this._fontName];\n        const fontSize = this.fontSize;\n        const scale = fontSize / data.size;\n        const pos = new Point();\n        const chars: CharRenderData[] = [];\n        const lineWidths = [];\n        const lineSpaces = [];\n        const text = this._text.replace(/(?:\\r\\n|\\r)/g, '\\n') || ' ';\n        const charsInput = splitTextToCharacters(text);\n        const maxWidth = this._maxWidth * data.size / fontSize;\n        const pageMeshDataPool = data.distanceFieldType === 'none'\n            ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n\n        let prevCharCode = null;\n        let lastLineWidth = 0;\n        let maxLineWidth = 0;\n        let line = 0;\n        let lastBreakPos = -1;\n        let lastBreakWidth = 0;\n        let spacesRemoved = 0;\n        let maxLineHeight = 0;\n        let spaceCount = 0;\n\n        for (let i = 0; i < charsInput.length; i++)\n        {\n            const char = charsInput[i];\n            const charCode = extractCharCode(char);\n\n            if ((/(?:\\s)/).test(char))\n            {\n                lastBreakPos = i;\n                lastBreakWidth = lastLineWidth;\n                spaceCount++;\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                lineWidths.push(lastLineWidth);\n                lineSpaces.push(-1);\n                maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n                ++line;\n                ++spacesRemoved;\n\n                pos.x = 0;\n                pos.y += data.lineHeight;\n                prevCharCode = null;\n                spaceCount = 0;\n                continue;\n            }\n\n            const charData = data.chars[charCode];\n\n            if (!charData)\n            {\n                continue;\n            }\n\n            if (prevCharCode && charData.kerning[prevCharCode])\n            {\n                pos.x += charData.kerning[prevCharCode];\n            }\n\n            const charRenderData: CharRenderData = charRenderDataPool.pop() || {\n                texture: Texture.EMPTY,\n                line: 0,\n                charCode: 0,\n                prevSpaces: 0,\n                position: new Point(),\n            };\n\n            charRenderData.texture = charData.texture;\n            charRenderData.line = line;\n            charRenderData.charCode = charCode;\n            charRenderData.position.x = Math.round(pos.x + charData.xOffset + (this._letterSpacing / 2));\n            charRenderData.position.y = Math.round(pos.y + charData.yOffset);\n            charRenderData.prevSpaces = spaceCount;\n\n            chars.push(charRenderData);\n\n            lastLineWidth = charRenderData.position.x\n                + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);\n            pos.x += charData.xAdvance + this._letterSpacing;\n            maxLineHeight = Math.max(maxLineHeight, (charData.yOffset + charData.texture.height));\n            prevCharCode = charCode;\n\n            if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth)\n            {\n                ++spacesRemoved;\n                utils.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);\n                i = lastBreakPos;\n                lastBreakPos = -1;\n\n                lineWidths.push(lastBreakWidth);\n                lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);\n                maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);\n                line++;\n\n                pos.x = 0;\n                pos.y += data.lineHeight;\n                prevCharCode = null;\n                spaceCount = 0;\n            }\n        }\n\n        const lastChar = charsInput[charsInput.length - 1];\n\n        if (lastChar !== '\\r' && lastChar !== '\\n')\n        {\n            if ((/(?:\\s)/).test(lastChar))\n            {\n                lastLineWidth = lastBreakWidth;\n            }\n\n            lineWidths.push(lastLineWidth);\n            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n            lineSpaces.push(-1);\n        }\n\n        const lineAlignOffsets = [];\n\n        for (let i = 0; i <= line; i++)\n        {\n            let alignOffset = 0;\n\n            if (this._align === 'right')\n            {\n                alignOffset = maxLineWidth - lineWidths[i];\n            }\n            else if (this._align === 'center')\n            {\n                alignOffset = (maxLineWidth - lineWidths[i]) / 2;\n            }\n            else if (this._align === 'justify')\n            {\n                alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i];\n            }\n\n            lineAlignOffsets.push(alignOffset);\n        }\n\n        const lenChars = chars.length;\n\n        const pagesMeshData: Record<number, PageMeshData> = {};\n\n        const newPagesMeshData: PageMeshData[] = [];\n\n        const activePagesMeshData = this._activePagesMeshData;\n\n        pageMeshDataPool.push(...activePagesMeshData);\n\n        for (let i = 0; i < lenChars; i++)\n        {\n            const texture = chars[i].texture;\n            const baseTextureUid = texture.baseTexture.uid;\n\n            if (!pagesMeshData[baseTextureUid])\n            {\n                let pageMeshData = pageMeshDataPool.pop();\n\n                if (!pageMeshData)\n                {\n                    const geometry = new MeshGeometry();\n                    let material: MeshMaterial;\n                    let meshBlendMode: BLEND_MODES;\n\n                    if (data.distanceFieldType === 'none')\n                    {\n                        material = new MeshMaterial(Texture.EMPTY);\n                        meshBlendMode = BLEND_MODES.NORMAL;\n                    }\n                    else\n                    {\n                        material = new MeshMaterial(Texture.EMPTY,\n                            { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } });\n                        meshBlendMode = BLEND_MODES.NORMAL_NPM;\n                    }\n\n                    const mesh = new Mesh(geometry, material);\n\n                    mesh.blendMode = meshBlendMode;\n\n                    pageMeshData = {\n                        index: 0,\n                        indexCount: 0,\n                        vertexCount: 0,\n                        uvsCount: 0,\n                        total: 0,\n                        mesh,\n                        vertices: null,\n                        uvs: null,\n                        indices: null,\n                    };\n                }\n\n                // reset data..\n                pageMeshData.index = 0;\n                pageMeshData.indexCount = 0;\n                pageMeshData.vertexCount = 0;\n                pageMeshData.uvsCount = 0;\n                pageMeshData.total = 0;\n\n                // TODO need to get page texture here somehow..\n                const { _textureCache } = this;\n\n                _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);\n                pageMeshData.mesh.texture = _textureCache[baseTextureUid];\n\n                pageMeshData.mesh.tint = this._tint;\n\n                newPagesMeshData.push(pageMeshData);\n\n                pagesMeshData[baseTextureUid] = pageMeshData;\n            }\n\n            pagesMeshData[baseTextureUid].total++;\n        }\n\n        // lets find any previously active pageMeshDatas that are no longer required for\n        // the updated text (if any), removed and return them to the pool.\n        for (let i = 0; i < activePagesMeshData.length; i++)\n        {\n            if (!newPagesMeshData.includes(activePagesMeshData[i]))\n            {\n                this.removeChild(activePagesMeshData[i].mesh);\n            }\n        }\n\n        // next lets add any new meshes, that have not yet been added to this BitmapText\n        // we only add if its not already a child of this BitmapObject\n        for (let i = 0; i < newPagesMeshData.length; i++)\n        {\n            if (newPagesMeshData[i].mesh.parent !== this)\n            {\n                this.addChild(newPagesMeshData[i].mesh);\n            }\n        }\n\n        // active page mesh datas are set to be the new pages added.\n        this._activePagesMeshData = newPagesMeshData;\n\n        for (const i in pagesMeshData)\n        {\n            const pageMeshData = pagesMeshData[i];\n            const total = pageMeshData.total;\n\n            // lets only allocate new buffers if we can fit the new text in the current ones..\n            // unless that is, we will be batching. Currently batching dose not respect the size property of mesh\n            if (!(pageMeshData.indices?.length > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2)\n            {\n                pageMeshData.vertices = new Float32Array(4 * 2 * total);\n                pageMeshData.uvs = new Float32Array(4 * 2 * total);\n                pageMeshData.indices = new Uint16Array(6 * total);\n            }\n            else\n            {\n                const total = pageMeshData.total;\n                const vertices = pageMeshData.vertices;\n\n                // Clear the garbage at the end of the vertices buffer. This will prevent the bounds miscalculation.\n                for (let i = total * 4 * 2; i < vertices.length; i++)\n                {\n                    vertices[i] = 0;\n                }\n            }\n\n            // as a buffer maybe bigger than the current word, we set the size of the meshMaterial\n            // to match the number of letters needed\n            pageMeshData.mesh.size = 6 * total;\n        }\n\n        for (let i = 0; i < lenChars; i++)\n        {\n            const char = chars[i];\n            let offset = char.position.x + (lineAlignOffsets[char.line] * (this._align === 'justify' ? char.prevSpaces : 1));\n\n            if (this._roundPixels)\n            {\n                offset = Math.round(offset);\n            }\n\n            const xPos = offset * scale;\n            const yPos = char.position.y * scale;\n            const texture = char.texture;\n\n            const pageMesh = pagesMeshData[texture.baseTexture.uid];\n\n            const textureFrame = texture.frame;\n            const textureUvs = texture._uvs;\n\n            const index = pageMesh.index++;\n\n            pageMesh.indices[(index * 6) + 0] = 0 + (index * 4);\n            pageMesh.indices[(index * 6) + 1] = 1 + (index * 4);\n            pageMesh.indices[(index * 6) + 2] = 2 + (index * 4);\n            pageMesh.indices[(index * 6) + 3] = 0 + (index * 4);\n            pageMesh.indices[(index * 6) + 4] = 2 + (index * 4);\n            pageMesh.indices[(index * 6) + 5] = 3 + (index * 4);\n\n            pageMesh.vertices[(index * 8) + 0] = xPos;\n            pageMesh.vertices[(index * 8) + 1] = yPos;\n\n            pageMesh.vertices[(index * 8) + 2] = xPos + (textureFrame.width * scale);\n            pageMesh.vertices[(index * 8) + 3] = yPos;\n\n            pageMesh.vertices[(index * 8) + 4] = xPos + (textureFrame.width * scale);\n            pageMesh.vertices[(index * 8) + 5] = yPos + (textureFrame.height * scale);\n\n            pageMesh.vertices[(index * 8) + 6] = xPos;\n            pageMesh.vertices[(index * 8) + 7] = yPos + (textureFrame.height * scale);\n\n            pageMesh.uvs[(index * 8) + 0] = textureUvs.x0;\n            pageMesh.uvs[(index * 8) + 1] = textureUvs.y0;\n\n            pageMesh.uvs[(index * 8) + 2] = textureUvs.x1;\n            pageMesh.uvs[(index * 8) + 3] = textureUvs.y1;\n\n            pageMesh.uvs[(index * 8) + 4] = textureUvs.x2;\n            pageMesh.uvs[(index * 8) + 5] = textureUvs.y2;\n\n            pageMesh.uvs[(index * 8) + 6] = textureUvs.x3;\n            pageMesh.uvs[(index * 8) + 7] = textureUvs.y3;\n        }\n\n        this._textWidth = maxLineWidth * scale;\n        this._textHeight = (pos.y + data.lineHeight) * scale;\n\n        for (const i in pagesMeshData)\n        {\n            const pageMeshData = pagesMeshData[i];\n\n            // apply anchor\n            if (this.anchor.x !== 0 || this.anchor.y !== 0)\n            {\n                let vertexCount = 0;\n\n                const anchorOffsetX = this._textWidth * this.anchor.x;\n                const anchorOffsetY = this._textHeight * this.anchor.y;\n\n                for (let i = 0; i < pageMeshData.total; i++)\n                {\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n                }\n            }\n\n            this._maxLineHeight = maxLineHeight * scale;\n\n            const vertexBuffer = pageMeshData.mesh.geometry.getBuffer('aVertexPosition');\n            const textureBuffer = pageMeshData.mesh.geometry.getBuffer('aTextureCoord');\n            const indexBuffer = pageMeshData.mesh.geometry.getIndex();\n\n            vertexBuffer.data = pageMeshData.vertices;\n            textureBuffer.data = pageMeshData.uvs;\n            indexBuffer.data = pageMeshData.indices;\n\n            vertexBuffer.update();\n            textureBuffer.update();\n            indexBuffer.update();\n        }\n\n        for (let i = 0; i < chars.length; i++)\n        {\n            charRenderDataPool.push(chars[i]);\n        }\n\n        this._font = data;\n        this.dirty = false;\n    }\n\n    updateTransform(): void\n    {\n        this.validate();\n        this.containerUpdateTransform();\n    }\n\n    _render(renderer: Renderer): void\n    {\n        if (this._autoResolution && this._resolution !== renderer.resolution)\n        {\n            this._resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        // Update the uniform\n        const { distanceFieldRange, distanceFieldType, size } = BitmapFont.available[this._fontName];\n\n        if (distanceFieldType !== 'none')\n        {\n            // Inject the shader code with the correct value\n            const { a, b, c, d } = this.worldTransform;\n\n            const dx = Math.sqrt((a * a) + (b * b));\n            const dy = Math.sqrt((c * c) + (d * d));\n            const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n            const fontScale = this.fontSize / size;\n\n            const resolution = renderer._view.resolution;\n\n            for (const mesh of this._activePagesMeshData)\n            {\n                mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;\n            }\n        }\n\n        super._render(renderer);\n    }\n\n    /**\n     * Validates text before calling parent's getLocalBounds\n     * @returns - The rectangular bounding area\n     */\n    public getLocalBounds(): Rectangle\n    {\n        this.validate();\n\n        return super.getLocalBounds();\n    }\n\n    /**\n     * Updates text when needed\n     * @private\n     */\n    protected validate(): void\n    {\n        const font = BitmapFont.available[this._fontName];\n\n        if (!font)\n        {\n            throw new Error(`Missing BitmapFont \"${this._fontName}\"`);\n        }\n        if (this._font !== font)\n        {\n            this.dirty = true;\n        }\n\n        if (this.dirty)\n        {\n            this.updateText();\n        }\n    }\n\n    /**\n     * The tint of the BitmapText object.\n     * @default 0xffffff\n     */\n    public get tint(): number\n    {\n        return this._tint;\n    }\n\n    public set tint(value: number)\n    {\n        if (this._tint === value) return;\n\n        this._tint = value;\n\n        for (let i = 0; i < this._activePagesMeshData.length; i++)\n        {\n            this._activePagesMeshData[i].mesh.tint = value;\n        }\n    }\n\n    /**\n     * The alignment of the BitmapText object.\n     * @member {string}\n     * @default 'left'\n     */\n    public get align(): TextStyleAlign\n    {\n        return this._align;\n    }\n\n    public set align(value: TextStyleAlign)\n    {\n        if (this._align !== value)\n        {\n            this._align = value;\n            this.dirty = true;\n        }\n    }\n\n    /** The name of the BitmapFont. */\n    public get fontName(): string\n    {\n        return this._fontName;\n    }\n\n    public set fontName(value: string)\n    {\n        if (!BitmapFont.available[value])\n        {\n            throw new Error(`Missing BitmapFont \"${value}\"`);\n        }\n\n        if (this._fontName !== value)\n        {\n            this._fontName = value;\n            this.dirty = true;\n        }\n    }\n\n    /** The size of the font to display. */\n    public get fontSize(): number\n    {\n        return this._fontSize ?? BitmapFont.available[this._fontName].size;\n    }\n\n    public set fontSize(value: number | undefined)\n    {\n        if (this._fontSize !== value)\n        {\n            this._fontSize = value;\n            this.dirty = true;\n        }\n    }\n\n    /**\n     * The anchor sets the origin point of the text.\n     *\n     * The default is `(0,0)`, this means the text's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n     */\n    public get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    public set anchor(value: ObservablePoint)\n    {\n        if (typeof value === 'number')\n        {\n            this._anchor.set(value);\n        }\n        else\n        {\n            this._anchor.copyFrom(value);\n        }\n    }\n\n    /** The text of the BitmapText object. */\n    public get text(): string\n    {\n        return this._text;\n    }\n\n    public set text(text: string)\n    {\n        text = String(text === null || text === undefined ? '' : text);\n\n        if (this._text === text)\n        {\n            return;\n        }\n        this._text = text;\n        this.dirty = true;\n    }\n\n    /**\n     * The max width of this bitmap text in pixels. If the text provided is longer than the\n     * value provided, line breaks will be automatically inserted in the last whitespace.\n     * Disable by setting the value to 0.\n     */\n    public get maxWidth(): number\n    {\n        return this._maxWidth;\n    }\n\n    public set maxWidth(value: number)\n    {\n        if (this._maxWidth === value)\n        {\n            return;\n        }\n        this._maxWidth = value;\n        this.dirty = true;\n    }\n\n    /**\n     * The max line height. This is useful when trying to use the total height of the Text,\n     * i.e. when trying to vertically align.\n     * @readonly\n     */\n    public get maxLineHeight(): number\n    {\n        this.validate();\n\n        return this._maxLineHeight;\n    }\n\n    /**\n     * The width of the overall text, different from fontSize,\n     * which is defined in the style object.\n     * @readonly\n     */\n    public get textWidth(): number\n    {\n        this.validate();\n\n        return this._textWidth;\n    }\n\n    /** Additional space between characters. */\n    public get letterSpacing(): number\n    {\n        return this._letterSpacing;\n    }\n\n    public set letterSpacing(value: number)\n    {\n        if (this._letterSpacing !== value)\n        {\n            this._letterSpacing = value;\n            this.dirty = true;\n        }\n    }\n\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n     * The main disadvantage is movement of objects may appear less smooth.\n     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}\n     * @default PIXI.settings.ROUND_PIXELS\n     */\n    public get roundPixels(): boolean\n    {\n        return this._roundPixels;\n    }\n\n    public set roundPixels(value: boolean)\n    {\n        if (value !== this._roundPixels)\n        {\n            this._roundPixels = value;\n            this.dirty = true;\n        }\n    }\n\n    /**\n     * The height of the overall text, different from fontSize,\n     * which is defined in the style object.\n     * @readonly\n     */\n    public get textHeight(): number\n    {\n        this.validate();\n\n        return this._textHeight;\n    }\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     *\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @default 1\n     */\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this._autoResolution = false;\n\n        if (this._resolution === value)\n        {\n            return;\n        }\n\n        this._resolution = value;\n        this.dirty = true;\n    }\n\n    destroy(options?: boolean | IDestroyOptions): void\n    {\n        const { _textureCache } = this;\n        const data = BitmapFont.available[this._fontName];\n        const pageMeshDataPool = data.distanceFieldType === 'none'\n            ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n\n        pageMeshDataPool.push(...this._activePagesMeshData);\n        for (const pageMeshData of this._activePagesMeshData)\n        {\n            this.removeChild(pageMeshData.mesh);\n        }\n        this._activePagesMeshData = [];\n\n        // Release references to any cached textures in page pool\n        pageMeshDataPool\n            .filter((page) => _textureCache[page.mesh.texture.baseTexture.uid])\n            .forEach((page) =>\n            {\n                page.mesh.texture = Texture.EMPTY;\n            });\n\n        for (const id in _textureCache)\n        {\n            const texture = _textureCache[id];\n\n            texture.destroy();\n            delete _textureCache[id];\n        }\n\n        this._font = null;\n        this._textureCache = null;\n\n        super.destroy(options);\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}