{"ast":null,"code":"import { Point, SHAPES } from '@pixi/core';\nimport { LINE_CAP, LINE_JOIN, curves } from '../const.mjs';\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n  const ix = x - nx * innerWeight;\n  const iy = y - ny * innerWeight;\n  const ox = x + nx * outerWeight;\n  const oy = y + ny * outerWeight;\n  let exx;\n  let eyy;\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  const eix = ix + exx;\n  const eiy = iy + eyy;\n  const eox = ox + exx;\n  const eoy = oy + eyy;\n  verts.push(eix, eiy);\n  verts.push(eox, eoy);\n  return 2;\n}\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  const cx2p0x = sx - cx;\n  const cy2p0y = sy - cy;\n  let angle0 = Math.atan2(cx2p0x, cy2p0y);\n  let angle1 = Math.atan2(ex - cx, ey - cy);\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n  let startAngle = angle0;\n  const angleDiff = angle1 - angle0;\n  const absAngleDiff = Math.abs(angleDiff);\n  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  const angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n  if (clockwise) {\n    verts.push(cx, cy);\n    verts.push(sx, sy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx, cy);\n      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n    }\n    verts.push(cx, cy);\n    verts.push(ex, ey);\n  } else {\n    verts.push(sx, sy);\n    verts.push(cx, cy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n      verts.push(cx, cy);\n    }\n    verts.push(ex, ey);\n    verts.push(cx, cy);\n  }\n  return segCount * 2;\n}\nfunction buildNonNativeLine(graphicsData, graphicsGeometry) {\n  const shape = graphicsData.shape;\n  let points = graphicsData.points || shape.points.slice();\n  const eps = graphicsGeometry.closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  const style = graphicsData.lineStyle;\n  const firstPoint = new Point(points[0], points[1]);\n  const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n  const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  if (closedShape) {\n    points = points.slice();\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n  const verts = graphicsGeometry.points;\n  const length = points.length / 2;\n  let indexCount = points.length;\n  const indexStart = verts.length / 2;\n  const width = style.width / 2;\n  const widthSquared = width * width;\n  const miterLimitSquared = style.miterLimit * style.miterLimit;\n  let x0 = points[0];\n  let y0 = points[1];\n  let x1 = points[2];\n  let y1 = points[3];\n  let x2 = 0;\n  let y2 = 0;\n  let perpx = -(y0 - y1);\n  let perpy = x0 - x1;\n  let perp1x = 0;\n  let perp1y = 0;\n  let dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist;\n  perpy /= dist;\n  perpx *= width;\n  perpy *= width;\n  const ratio = style.alignment;\n  const innerWeight = (1 - ratio) * 2;\n  const outerWeight = ratio * 2;\n  if (!closedShape) {\n    if (style.cap === LINE_CAP.ROUND) {\n      indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;\n    } else if (style.cap === LINE_CAP.SQUARE) {\n      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);\n    }\n  }\n  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight);\n  verts.push(x0 + perpx * outerWeight, y0 + perpy * outerWeight);\n  for (let i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2];\n    y0 = points[(i - 1) * 2 + 1];\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    x2 = points[(i + 1) * 2];\n    y2 = points[(i + 1) * 2 + 1];\n    perpx = -(y0 - y1);\n    perpy = x0 - x1;\n    dist = Math.sqrt(perpx * perpx + perpy * perpy);\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    const dx0 = x1 - x0;\n    const dy0 = y0 - y1;\n    const dx1 = x1 - x2;\n    const dy1 = y2 - y1;\n    const dot = dx0 * dx1 + dy0 * dy1;\n    const cross = dy0 * dx1 - dy1 * dx0;\n    const clockwise = cross < 0;\n    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n      if (dot >= 0) {\n        if (style.join === LINE_JOIN.ROUND) {\n          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n        } else {\n          indexCount += 2;\n        }\n        verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight);\n        verts.push(x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);\n      }\n      continue;\n    }\n    const c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);\n    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    const px = (dx0 * c2 - dx1 * c1) / cross;\n    const py = (dy1 * c1 - dy0 * c2) / cross;\n    const pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    const imx = x1 + (px - x1) * innerWeight;\n    const imy = y1 + (py - y1) * innerWeight;\n    const omx = x1 - (px - x1) * outerWeight;\n    const omy = y1 - (py - y1) * outerWeight;\n    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n    const insideWeight = clockwise ? innerWeight : outerWeight;\n    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n    const insideMiterOk = pdist <= smallerInsideDiagonalSq;\n    if (insideMiterOk) {\n      if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared) {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n          verts.push(omx, omy);\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n        indexCount += 2;\n      } else if (style.join === LINE_JOIN.ROUND) {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n          indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n          verts.push(omx, omy);\n          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n      } else {\n        verts.push(imx, imy);\n        verts.push(omx, omy);\n      }\n    } else {\n      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n      if (style.join === LINE_JOIN.ROUND) {\n        if (clockwise) {\n          indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;\n        } else {\n          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;\n        }\n      } else if (style.join === LINE_JOIN.MITER && pdist / widthSquared <= miterLimitSquared) {\n        if (clockwise) {\n          verts.push(omx, omy);\n          verts.push(omx, omy);\n        } else {\n          verts.push(imx, imy);\n          verts.push(imx, imy);\n        }\n        indexCount += 2;\n      }\n      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n      indexCount += 2;\n    }\n  }\n  x0 = points[(length - 2) * 2];\n  y0 = points[(length - 2) * 2 + 1];\n  x1 = points[(length - 1) * 2];\n  y1 = points[(length - 1) * 2 + 1];\n  perpx = -(y0 - y1);\n  perpy = x0 - x1;\n  dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist;\n  perpy /= dist;\n  perpx *= width;\n  perpy *= width;\n  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n  verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n  if (!closedShape) {\n    if (style.cap === LINE_CAP.ROUND) {\n      indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;\n    } else if (style.cap === LINE_CAP.SQUARE) {\n      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);\n    }\n  }\n  const indices = graphicsGeometry.indices;\n  const eps2 = curves.epsilon * curves.epsilon;\n  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {\n    x0 = verts[i * 2];\n    y0 = verts[i * 2 + 1];\n    x1 = verts[(i + 1) * 2];\n    y1 = verts[(i + 1) * 2 + 1];\n    x2 = verts[(i + 2) * 2];\n    y2 = verts[(i + 2) * 2 + 1];\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n    indices.push(i, i + 1, i + 2);\n  }\n}\nfunction buildNativeLine(graphicsData, graphicsGeometry) {\n  let i = 0;\n  const shape = graphicsData.shape;\n  const points = graphicsData.points || shape.points;\n  const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n  if (points.length === 0) return;\n  const verts = graphicsGeometry.points;\n  const indices = graphicsGeometry.indices;\n  const length = points.length / 2;\n  const startIndex = verts.length / 2;\n  let currentIndex = startIndex;\n  verts.push(points[0], points[1]);\n  for (i = 1; i < length; i++) {\n    verts.push(points[i * 2], points[i * 2 + 1]);\n    indices.push(currentIndex, currentIndex + 1);\n    currentIndex++;\n  }\n  if (closedShape) {\n    indices.push(currentIndex, startIndex);\n  }\n}\nfunction buildLine(graphicsData, graphicsGeometry) {\n  if (graphicsData.lineStyle.native) {\n    buildNativeLine(graphicsData, graphicsGeometry);\n  } else {\n    buildNonNativeLine(graphicsData, graphicsGeometry);\n  }\n}\nexport { buildLine };","map":{"version":3,"mappings":"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","names":["x","y","ny","innerWeight","clockwise","verts","nx","exx","eyy","eix","ix","eiy","iy","eox","ox","eoy","oy","cx","cy","sy","ex","cx2p0x","sx","cy2p0y","angle0","atan2","angle1","Math","ey","PI","startAngle","angleDiff","radius","absAngleDiff","sqrt","angleInc","angle","i","segCount","push","graphicsData","graphicsGeometry","shape","points","slice","eps","length","style","firstPoint","Point","closedShape","type","POLY","closedPath","abs","lastPoint","pop","midPointX","midPointY","indexCount","width","widthSquared","x0","y0","x1","y1","x2","y2","perpy","perp1x","perp1y","dist","perpx","ratio","outerWeight","cap","ROUND","SQUARE","dx0","dy0","dx1","dy1","cross","dot","join","round","px","c2","c1","py","pdist","smallerInsideSegmentSq","insideWeight","insideMiterOk","BEVEL","miterLimitSquared","imx","imy","omx","omy","LINE_JOIN","MITER","indices","curves","indexStart","eps2","currentIndex","startIndex","lineStyle","native","buildNativeLine","buildNonNativeLine"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/graphics/src/utils/buildLine.ts"],"sourcesContent":["import { Point, SHAPES } from '@pixi/core';\nimport { curves, LINE_CAP, LINE_JOIN } from '../const';\n\nimport type { Polygon } from '@pixi/core';\nimport type { GraphicsData } from '../GraphicsData';\nimport type { GraphicsGeometry } from '../GraphicsGeometry';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {number} innerWeight - Weight of inner points\n * @param {number} outerWeight - Weight of outer points\n * @param {boolean} clockwise - Whether the cap is drawn clockwise\n * @param {Array<number>} verts - vertex buffer\n * @returns {number} - no. of vertices pushed\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array<number>} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: Array<number>,\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    /* if (absAngleDiff >= PI_LBOUND && absAngleDiff <= PI_UBOUND)\n    {\n        const r1x = cx - nxtPx;\n        const r1y = cy - nxtPy;\n\n        if (r1x === 0)\n        {\n            if (r1y > 0)\n            {\n                angleDiff = -angleDiff;\n            }\n        }\n        else if (r1x >= -curves.epsilon)\n        {\n            angleDiff = -angleDiff;\n        }\n    }*/\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx, cy);\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    }\n    else\n    {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n            verts.push(cx, cy);\n        }\n\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNonNativeLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    const shape = graphicsData.shape as Polygon;\n    let points = graphicsData.points || shape.points.slice();\n    const eps = graphicsGeometry.closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n    // if the line width is an odd number add 0.5 to align to a whole pixel\n    // commenting this out fixes #711 and #1620\n    // if (graphicsData.lineWidth%2)\n    // {\n    //     for (i = 0; i < points.length; i++)\n    //     {\n    //         points[i] += 0.5;\n    //     }\n    // }\n\n    const style = graphicsData.lineStyle;\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = graphicsGeometry.points;\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpx = -(y0 - y1);\n    let perpy = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    const ratio = style.alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === LINE_CAP.ROUND)\n        {\n            indexCount += round(\n                x0 - (perpx * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpy * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpx * innerWeight),\n                y0 - (perpy * innerWeight),\n                x0 + (perpx * outerWeight),\n                y0 + (perpy * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === LINE_CAP.SQUARE)\n        {\n            indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpx * innerWeight),\n        y0 - (perpy * innerWeight));\n    verts.push(\n        x0 + (perpx * outerWeight),\n        y0 + (perpy * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpx = -(y0 - y1);\n        perpy = x0 - x1;\n\n        dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n        perpx /= dist;\n        perpy /= dist;\n        perpx *= width;\n        perpy *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle < 90 degree, -ve if internal angle > 90 degree. */\n        const dot = (dx0 * dx1) + (dy0 * dy1);\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly parallel? */\n        /* atan(0.001) ~= 0.001 rad ~= 0.057 degree */\n        if (Math.abs(cross) < 0.001 * Math.abs(dot))\n        {\n            verts.push(\n                x1 - (perpx * innerWeight),\n                y1 - (perpy * innerWeight));\n            verts.push(\n                x1 + (perpx * outerWeight),\n                y1 + (perpy * outerWeight));\n\n            /* 180 degree corner? */\n            if (dot >= 0)\n            {\n                if (style.join === LINE_JOIN.ROUND)\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false) + 4;\n                }\n                else\n                {\n                    indexCount += 2;\n                }\n\n                verts.push(\n                    x1 - (perp1x * outerWeight),\n                    y1 - (perp1y * outerWeight));\n                verts.push(\n                    x1 + (perp1x * innerWeight),\n                    y1 + (perp1y * innerWeight));\n            }\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pdist is the distance between miter point and p1. */\n        const c1 = ((-perpx + x0) * (-perpy + y1)) - ((-perpx + x1) * (-perpy + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pdist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pdist <= smallerInsideDiagonalSq;\n\n        if (insideMiterOk)\n        {\n            if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared)\n            {\n                if (clockwise) /* rotating at inner angle */\n                {\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight)); // first segment's outer vertex\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n                }\n                else /* rotating at outer angle */\n                {\n                    verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight)); // first segment's inner vertex\n                    verts.push(omx, omy); // outer miter point\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's outer vertex\n                    verts.push(omx, omy); // outer miter point\n                }\n\n                indexCount += 2;\n            }\n            else if (style.join === LINE_JOIN.ROUND)\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpx * outerWeight), y1 + (perpy * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 4;\n\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                }\n                else /* arc is inside */\n                {\n                    verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight));\n                    verts.push(omx, omy);\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 4;\n\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));\n                    verts.push(omx, omy);\n                }\n            }\n            else\n            {\n                verts.push(imx, imy);\n                verts.push(omx, omy);\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight)); // first segment's inner vertex\n            verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight)); // first segment's outer vertex\n            if (style.join === LINE_JOIN.ROUND)\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpx * outerWeight), y1 + (perpy * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 2;\n                }\n                else /* arc is inside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 2;\n                }\n            }\n            else if (style.join === LINE_JOIN.MITER && pdist / widthSquared <= miterLimitSquared)\n            {\n                if (clockwise)\n                {\n                    verts.push(omx, omy); // inner miter point\n                    verts.push(omx, omy); // inner miter point\n                }\n                else\n                {\n                    verts.push(imx, imy); // outer miter point\n                    verts.push(imx, imy); // outer miter point\n                }\n                indexCount += 2;\n            }\n            verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's inner vertex\n            verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpx = -(y0 - y1);\n    perpy = x0 - x1;\n\n    dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight));\n    verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === LINE_CAP.ROUND)\n        {\n            indexCount += round(\n                x1 - (perpx * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpy * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpx * innerWeight),\n                y1 - (perpy * innerWeight),\n                x1 + (perpx * outerWeight),\n                y1 + (perpy * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === LINE_CAP.SQUARE)\n        {\n            indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    const indices = graphicsGeometry.indices;\n    const eps2 = curves.epsilon * curves.epsilon;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n/**\n * Builds a line to draw using the gl.drawArrays(gl.LINES) method\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNativeLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    let i = 0;\n\n    const shape = graphicsData.shape as Polygon;\n    const points = graphicsData.points || shape.points;\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n\n    if (points.length === 0) return;\n\n    const verts = graphicsGeometry.points;\n    const indices = graphicsGeometry.indices;\n    const length = points.length / 2;\n\n    const startIndex = verts.length / 2;\n    let currentIndex = startIndex;\n\n    verts.push(points[0], points[1]);\n\n    for (i = 1; i < length; i++)\n    {\n        verts.push(points[i * 2], points[(i * 2) + 1]);\n        indices.push(currentIndex, currentIndex + 1);\n\n        currentIndex++;\n    }\n\n    if (closedShape)\n    {\n        indices.push(currentIndex, startIndex);\n    }\n}\n\n/**\n * Builds a line to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nexport function buildLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    if (graphicsData.lineStyle.native)\n    {\n        buildNativeLine(graphicsData, graphicsGeometry);\n    }\n    else\n    {\n        buildNonNativeLine(graphicsData, graphicsGeometry);\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}