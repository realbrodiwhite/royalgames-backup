{"ast":null,"code":"import { settings } from '@pixi/settings';\nimport { uid } from '@pixi/utils';\nimport { BaseImageResource } from './BaseImageResource.mjs';\nconst _SVGResource = class extends BaseImageResource {\n  constructor(sourceBase64, options) {\n    options = options || {};\n    super(settings.ADAPTER.createCanvas());\n    this._width = 0;\n    this._height = 0;\n    this.svg = sourceBase64;\n    this.scale = options.scale || 1;\n    this._overrideWidth = options.width;\n    this._overrideHeight = options.height;\n    this._resolve = null;\n    this._crossorigin = options.crossorigin;\n    this._load = null;\n    if (options.autoLoad !== false) {\n      this.load();\n    }\n  }\n  load() {\n    if (this._load) {\n      return this._load;\n    }\n    this._load = new Promise(resolve => {\n      this._resolve = () => {\n        this.resize(this.source.width, this.source.height);\n        resolve(this);\n      };\n      if (_SVGResource.SVG_XML.test(this.svg.trim())) {\n        if (!btoa) {\n          throw new Error(\"Your browser doesn't support base64 conversions.\");\n        }\n        this.svg = \"data:image/svg+xml;base64,\".concat(btoa(unescape(encodeURIComponent(this.svg))));\n      }\n      this._loadSvg();\n    });\n    return this._load;\n  }\n  _loadSvg() {\n    const tempImage = new Image();\n    BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);\n    tempImage.src = this.svg;\n    tempImage.onerror = event => {\n      if (!this._resolve) {\n        return;\n      }\n      tempImage.onerror = null;\n      this.onError.emit(event);\n    };\n    tempImage.onload = () => {\n      if (!this._resolve) {\n        return;\n      }\n      const svgWidth = tempImage.width;\n      const svgHeight = tempImage.height;\n      if (!svgWidth || !svgHeight) {\n        throw new Error(\"The SVG image must have width and height defined (in pixels), canvas API needs them.\");\n      }\n      let width = svgWidth * this.scale;\n      let height = svgHeight * this.scale;\n      if (this._overrideWidth || this._overrideHeight) {\n        width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth;\n        height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight;\n      }\n      width = Math.round(width);\n      height = Math.round(height);\n      const canvas = this.source;\n      canvas.width = width;\n      canvas.height = height;\n      canvas._pixiId = \"canvas_\".concat(uid());\n      canvas.getContext(\"2d\").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);\n      this._resolve();\n      this._resolve = null;\n    };\n  }\n  static getSize(svgString) {\n    const sizeMatch = _SVGResource.SVG_SIZE.exec(svgString);\n    const size = {};\n    if (sizeMatch) {\n      size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));\n      size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));\n    }\n    return size;\n  }\n  dispose() {\n    super.dispose();\n    this._resolve = null;\n    this._crossorigin = null;\n  }\n  static test(source, extension) {\n    return extension === \"svg\" || typeof source === \"string\" && source.startsWith(\"data:image/svg+xml\") || typeof source === \"string\" && _SVGResource.SVG_XML.test(source);\n  }\n};\nlet SVGResource = _SVGResource;\nSVGResource.SVG_XML = /^(<\\?xml[^?]+\\?>)?\\s*(<!--[^(-->)]*-->)?\\s*\\<svg/m;\nSVGResource.SVG_SIZE = /<svg[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*>/i;\nexport { SVGResource };","map":{"version":3,"mappings":"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","names":["_SVGResource","BaseImageResource","constructor","sourceBase64","options","ADAPTER","_width","_height","svg","scale","_overrideWidth","_overrideHeight","_resolve","_crossorigin","_load","autoLoad","load","Promise","resolve","resize","width","source","height","SVG_XML","btoa","Error","unescape","encodeURIComponent","_loadSvg","Image","crossOrigin","tempImage","src","event","onerror","emit","onload","svgWidth","svgHeight","round","canvas","_pixiId","uid","getContext","getSize","svgString","sizeMatch","SVG_SIZE","size","parseFloat","dispose","test","extension","SVGResource"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/core/src/textures/resources/SVGResource.ts"],"sourcesContent":["import { settings } from '@pixi/settings';\nimport { uid } from '@pixi/utils';\nimport { BaseImageResource } from './BaseImageResource';\n\nimport type { ISize } from '@pixi/math';\nimport type { ICanvas } from '@pixi/settings';\n\nexport interface ISVGResourceOptions\n{\n    source?: string;\n    scale?: number;\n    width?: number;\n    height?: number;\n    autoLoad?: boolean;\n    crossorigin?: boolean | string;\n}\n/**\n * Resource type for SVG elements and graphics.\n * @memberof PIXI\n */\nexport class SVGResource extends BaseImageResource\n{\n    /** Base64 encoded SVG element or URL for SVG file. */\n    public readonly svg: string;\n\n    /** The source scale to apply when rasterizing on load. */\n    public readonly scale: number;\n\n    /** A width override for rasterization on load. */\n    public readonly _overrideWidth: number;\n\n    /** A height override for rasterization on load. */\n    public readonly _overrideHeight: number;\n\n    /** Call when completely loaded. */\n    private _resolve: () => void;\n\n    /** Promise when loading */\n    private _load: Promise<SVGResource>;\n\n    /** Cross origin value to use */\n    private _crossorigin?: boolean | string;\n\n    /**\n     * @param sourceBase64 - Base64 encoded SVG element or URL for SVG file.\n     * @param {object} [options] - Options to use\n     * @param {number} [options.scale=1] - Scale to apply to SVG. Overridden by...\n     * @param {number} [options.width] - Rasterize SVG this wide. Aspect ratio preserved if height not specified.\n     * @param {number} [options.height] - Rasterize SVG this high. Aspect ratio preserved if width not specified.\n     * @param {boolean} [options.autoLoad=true] - Start loading right away.\n     */\n    constructor(sourceBase64: string, options?: ISVGResourceOptions)\n    {\n        options = options || {};\n\n        super(settings.ADAPTER.createCanvas());\n        this._width = 0;\n        this._height = 0;\n\n        this.svg = sourceBase64;\n        this.scale = options.scale || 1;\n        this._overrideWidth = options.width;\n        this._overrideHeight = options.height;\n\n        this._resolve = null;\n        this._crossorigin = options.crossorigin;\n        this._load = null;\n\n        if (options.autoLoad !== false)\n        {\n            this.load();\n        }\n    }\n\n    load(): Promise<SVGResource>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        this._load = new Promise((resolve): void =>\n        {\n            // Save this until after load is finished\n            this._resolve = (): void =>\n            {\n                this.resize(this.source.width, this.source.height);\n                resolve(this);\n            };\n\n            // Convert SVG inline string to data-uri\n            if (SVGResource.SVG_XML.test(this.svg.trim()))\n            {\n                if (!btoa)\n                {\n                    throw new Error('Your browser doesn\\'t support base64 conversions.');\n                }\n                (this as any).svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;\n            }\n\n            this._loadSvg();\n        });\n\n        return this._load;\n    }\n\n    /** Loads an SVG image from `imageUrl` or `data URL`. */\n    private _loadSvg(): void\n    {\n        const tempImage = new Image();\n\n        BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);\n        tempImage.src = this.svg;\n\n        tempImage.onerror = (event): void =>\n        {\n            if (!this._resolve)\n            {\n                return;\n            }\n\n            tempImage.onerror = null;\n            this.onError.emit(event);\n        };\n\n        tempImage.onload = (): void =>\n        {\n            if (!this._resolve)\n            {\n                return;\n            }\n\n            const svgWidth = tempImage.width;\n            const svgHeight = tempImage.height;\n\n            if (!svgWidth || !svgHeight)\n            {\n                throw new Error('The SVG image must have width and height defined (in pixels), canvas API needs them.');\n            }\n\n            // Set render size\n            let width = svgWidth * this.scale;\n            let height = svgHeight * this.scale;\n\n            if (this._overrideWidth || this._overrideHeight)\n            {\n                width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth;\n                height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight;\n            }\n            width = Math.round(width);\n            height = Math.round(height);\n\n            // Create a canvas element\n            const canvas = this.source as ICanvas;\n\n            canvas.width = width;\n            canvas.height = height;\n            (canvas as any)._pixiId = `canvas_${uid()}`;\n\n            // Draw the Svg to the canvas\n            canvas\n                .getContext('2d')\n                .drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);\n\n            this._resolve();\n            this._resolve = null;\n        };\n    }\n\n    /**\n     * Get size from an svg string using a regular expression.\n     * @param svgString - a serialized svg element\n     * @returns - image extension\n     */\n    static getSize(svgString?: string): ISize\n    {\n        const sizeMatch = SVGResource.SVG_SIZE.exec(svgString);\n        const size: any = {};\n\n        if (sizeMatch)\n        {\n            size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));\n            size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));\n        }\n\n        return size;\n    }\n\n    /** Destroys this texture. */\n    dispose(): void\n    {\n        super.dispose();\n        this._resolve = null;\n        this._crossorigin = null;\n    }\n\n    /**\n     * Used to auto-detect the type of resource.\n     * @param {*} source - The source object\n     * @param {string} extension - The extension of source, if set\n     * @returns {boolean} - If the source is a SVG source or data file\n     */\n    static test(source: unknown, extension?: string): boolean\n    {\n        // url file extension is SVG\n        return extension === 'svg'\n            // source is SVG data-uri\n            || (typeof source === 'string' && source.startsWith('data:image/svg+xml'))\n            // source is SVG inline\n            || (typeof source === 'string' && SVGResource.SVG_XML.test(source));\n    }\n\n    /**\n     * Regular expression for SVG XML document.\n     * @example &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!-- image/svg --&gt;&lt;svg\n     * @readonly\n     */\n    static SVG_XML = /^(<\\?xml[^?]+\\?>)?\\s*(<!--[^(-->)]*-->)?\\s*\\<svg/m;\n\n    /**\n     * Regular expression for SVG size.\n     * @example &lt;svg width=\"100\" height=\"100\"&gt;&lt;/svg&gt;\n     * @readonly\n     */\n    static SVG_SIZE = /<svg[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*>/i; // eslint-disable-line max-len\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}