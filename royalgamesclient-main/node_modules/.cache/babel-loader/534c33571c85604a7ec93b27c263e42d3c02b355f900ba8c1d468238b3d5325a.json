{"ast":null,"code":"import { curves } from '../const.mjs';\nclass BezierUtils {\n  static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {\n    const n = 10;\n    let result = 0;\n    let t = 0;\n    let t2 = 0;\n    let t3 = 0;\n    let nt = 0;\n    let nt2 = 0;\n    let nt3 = 0;\n    let x = 0;\n    let y = 0;\n    let dx = 0;\n    let dy = 0;\n    let prevX = fromX;\n    let prevY = fromY;\n    for (let i = 1; i <= n; ++i) {\n      t = i / n;\n      t2 = t * t;\n      t3 = t2 * t;\n      nt = 1 - t;\n      nt2 = nt * nt;\n      nt3 = nt2 * nt;\n      x = nt3 * fromX + 3 * nt2 * t * cpX + 3 * nt * t2 * cpX2 + t3 * toX;\n      y = nt3 * fromY + 3 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;\n      dx = prevX - x;\n      dy = prevY - y;\n      prevX = x;\n      prevY = y;\n      result += Math.sqrt(dx * dx + dy * dy);\n    }\n    return result;\n  }\n  static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    points.length -= 2;\n    const n = curves._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));\n    let dt = 0;\n    let dt2 = 0;\n    let dt3 = 0;\n    let t2 = 0;\n    let t3 = 0;\n    points.push(fromX, fromY);\n    for (let i = 1, j = 0; i <= n; ++i) {\n      j = i / n;\n      dt = 1 - j;\n      dt2 = dt * dt;\n      dt3 = dt2 * dt;\n      t2 = j * j;\n      t3 = t2 * j;\n      points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);\n    }\n  }\n}\nexport { BezierUtils };","map":{"version":3,"mappings":";AAMO,MAAMA,WACb;EAgBI,OAAOC,YACHC,KAAe,SACfC,KAAaC,GACb,QAAcC,IACd,OAAaC,GACjB;IACI,MAAMC,CAAI;IACV,IAAIC,MAAS;IACb,IAAIC,CAAI;IACR,IAAIC,EAAK;IACT,IAAIC,EAAK;IACT,IAAIC,EAAK;IACT,IAAIC,GAAM;IACV,IAAIC,GAAM;IACV,IAAIC,CAAI;IACR,IAAIC,CAAI;IACR,IAAIC,EAAK;IACT,IAAIC,EAAK;IACT,IAAIC,KAAQ;IACZ,IAAIC,KAAQ;IAEZ,SAASC,CAAI,MAAGA,CAAK,OAAG,EAAEA,CAC1B;MACIZ,IAAIY,CAAI;MACRX,KAAKD,CAAI;MACTE,KAAKD,EAAK;MACVE,KAAM,CAAM;MACZC,MAAMD,EAAK;MACXE,MAAMD,GAAM;MAEPE,UAAMb,KAAU,OAAMW,GAAM,OAAIV,MAAQ,CAAM,QAAKO,EAAK,UAASC,EAAK;MACtEK,UAAMM,KAAU,OAAMT,GAAM,OAAIT,MAAQ,CAAI,QAAKM,EAAK,UAASC,EAAK;MACzEM,KAAKE,KAAQ;MACbD,KAAKE,KAAQ;MACLD;MACAC;MAERZ,UAAUe,IAAK,MAAMN,EAAK,QAAOC,KAAKA,EAAG;IAAA;IAGtC;EAAA;EAgBX,OAAOM,QACHrB,GAAa,OACbsB,MAAcpB,IACd,OAAaC,KACboB,MACJ;IACU,cAAQA,MAAO,QAAOC,MAAS;IAC/B,cAAQD,MAAO,QAAOC,MAAS;IAErCD,OAAOC,MAAU;IAEjB,MAAMpB,CAAI,UAAOqB,cACb,aAAY3B,WAAY,QAAOqB,KAAO,OAAKlB,GAAK,QAAMC,IAAM,OAAKC,GAAG,CACxE;IAEA,IAAIuB,EAAK;IACT,IAAIC,GAAM;IACV,IAAIC,GAAM;IACV,IAAIrB,EAAK;IACT,IAAIC,EAAK;IAEFe,YAAKxB,OAAOoB,KAAK;IAExB,SAASD,IAAI,CAAG,MAAI,GAAGA,CAAK,OAAG,EAAEA,CACjC;MACIW,IAAIX,CAAI;MAERQ,KAAM,CAAI;MACVC,MAAMD,EAAK;MACXE,MAAMD,GAAM;MAEZpB,KAAKsB,CAAI;MACTrB,KAAKD,EAAK;MAEHgB,YACFK,GAAM,WAAU,CAAI,SAAMC,IAAI7B,GAAQ,OAAI0B,EAAK,QAAKJ,IAAS,QAAKQ,KAClEF,GAAM,WAAU,CAAI,SAAMC,CAAI,SAAQ,IAAIH,EAAK,QAAKxB,IAAS,QAAKC,GACvE;IAAA;EACJ;AAER","names":["BezierUtils","curveLength","fromX","cpX","cpY","cpY2","toY","n","result","t","t2","t3","nt","nt2","nt3","x","y","dx","dy","prevX","prevY","i","fromY","Math","curveTo","cpX2","points","length","_segmentsCount","dt","dt2","dt3","j","toX"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/graphics/src/utils/BezierUtils.ts"],"sourcesContent":["import { curves } from '../const';\n\n/**\n * Utilities for bezier curves\n * @private\n */\nexport class BezierUtils\n{\n    /**\n     * Calculate length of bezier curve.\n     * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n     * Therefore numerical solution is used.\n     * @private\n     * @param fromX - Starting point x\n     * @param fromY - Starting point y\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param cpX2 - Second Control point x\n     * @param cpY2 - Second Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @returns - Length of bezier curve\n     */\n    static curveLength(\n        fromX: number, fromY: number,\n        cpX: number, cpY: number,\n        cpX2: number, cpY2: number,\n        toX: number, toY: number): number\n    {\n        const n = 10;\n        let result = 0.0;\n        let t = 0.0;\n        let t2 = 0.0;\n        let t3 = 0.0;\n        let nt = 0.0;\n        let nt2 = 0.0;\n        let nt3 = 0.0;\n        let x = 0.0;\n        let y = 0.0;\n        let dx = 0.0;\n        let dy = 0.0;\n        let prevX = fromX;\n        let prevY = fromY;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            t = i / n;\n            t2 = t * t;\n            t3 = t2 * t;\n            nt = (1.0 - t);\n            nt2 = nt * nt;\n            nt3 = nt2 * nt;\n\n            x = (nt3 * fromX) + (3.0 * nt2 * t * cpX) + (3.0 * nt * t2 * cpX2) + (t3 * toX);\n            y = (nt3 * fromY) + (3.0 * nt2 * t * cpY) + (3 * nt * t2 * cpY2) + (t3 * toY);\n            dx = prevX - x;\n            dy = prevY - y;\n            prevX = x;\n            prevY = y;\n\n            result += Math.sqrt((dx * dx) + (dy * dy));\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * Ignored from docs since it is not directly exposed.\n     * @ignore\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param cpX2 - Second Control point x\n     * @param cpY2 - Second Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @param points - Path array to push points into\n     */\n    static curveTo(\n        cpX: number, cpY: number,\n        cpX2: number, cpY2: number,\n        toX: number, toY: number,\n        points: Array<number>): void\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        points.length -= 2;\n\n        const n = curves._segmentsCount(\n            BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)\n        );\n\n        let dt = 0;\n        let dt2 = 0;\n        let dt3 = 0;\n        let t2 = 0;\n        let t3 = 0;\n\n        points.push(fromX, fromY);\n\n        for (let i = 1, j = 0; i <= n; ++i)\n        {\n            j = i / n;\n\n            dt = (1 - j);\n            dt2 = dt * dt;\n            dt3 = dt2 * dt;\n\n            t2 = j * j;\n            t3 = t2 * j;\n\n            points.push(\n                (dt3 * fromX) + (3 * dt2 * j * cpX) + (3 * dt * t2 * cpX2) + (t3 * toX),\n                (dt3 * fromY) + (3 * dt2 * j * cpY) + (3 * dt * t2 * cpY2) + (t3 * toY)\n            );\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}