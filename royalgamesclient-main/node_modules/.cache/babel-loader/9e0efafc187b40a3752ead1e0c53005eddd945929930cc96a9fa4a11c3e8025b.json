{"ast":null,"code":"import { settings, ExtensionType, BaseTexture, utils, extensions } from '@pixi/core';\nimport { checkDataUrl } from '../../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../../utils/checkExtension.mjs';\nimport { LoaderParserPriority } from '../LoaderParser.mjs';\nimport { WorkerManager } from '../WorkerManager.mjs';\nimport { createTexture } from './utils/createTexture.mjs';\nconst validImageExtensions = [\".jpeg\", \".jpg\", \".png\", \".webp\", \".avif\"];\nconst validImageMIMEs = [\"image/jpeg\", \"image/png\", \"image/webp\", \"image/avif\"];\nasync function loadImageBitmap(url) {\n  const response = await settings.ADAPTER.fetch(url);\n  if (!response.ok) {\n    throw new Error(\"[loadImageBitmap] Failed to fetch \".concat(url, \": \").concat(response.status, \" \").concat(response.statusText));\n  }\n  const imageBlob = await response.blob();\n  const imageBitmap = await createImageBitmap(imageBlob);\n  return imageBitmap;\n}\nconst loadTextures = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.High\n  },\n  config: {\n    preferWorkers: true\n  },\n  test(url) {\n    return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n  },\n  async load(url, asset, loader) {\n    let src = null;\n    if (globalThis.createImageBitmap) {\n      if (this.config.preferWorkers && (await WorkerManager.isImageBitmapSupported())) {\n        src = await WorkerManager.loadImageBitmap(url);\n      } else {\n        src = await loadImageBitmap(url);\n      }\n    } else {\n      src = await new Promise(resolve => {\n        src = new Image();\n        src.crossOrigin = \"anonymous\";\n        src.src = url;\n        if (src.complete) {\n          resolve(src);\n        } else {\n          src.onload = () => {\n            resolve(src);\n          };\n        }\n      });\n    }\n    const base = new BaseTexture(src, {\n      resolution: utils.getResolutionOfUrl(url),\n      ...asset.data\n    });\n    base.resource.src = url;\n    return createTexture(base, loader, url);\n  },\n  unload(texture) {\n    texture.destroy(true);\n  }\n};\nextensions.add(loadTextures);\nexport { loadImageBitmap, loadTextures };","map":{"version":3,"mappings":";;;;;;AAYA,MAAMA,uBAAuB,CAAC,SAAS,MAAQ,UAAQ,SAAS,OAAO;AACvE,MAAMC,eAAkB,IACpB,cACA,aACA,cACA,aACJ;AAQA,+BAAsCC,GACtC;EACI,MAAMC,QAAW,SAAMC,QAAS,SAAQC,MAAMH,GAAG;EAE7C,KAACC,SAASG,EACd;IACI,MAAM,IAAIC,KAAM,6CAAqCL,kBAC5CC,QAAS,qBAAUA,SAASK,UAAY;EAAA;EAG/C,kBAAY,MAAML,SAASM,IAAK;EAChC,oBAAc,MAAMC,kBAAkBC,SAAS;EAE9C;AACX;AAQO,MAAMC,YAAe;EACxBC,SAAW;IACPC,MAAMC,aAAc;IACpBC,UAAUC,oBAAqB;EAAA,CACnC;EAEAC,MAAQ;IACJC,aAAe;EAAA,CACnB;EAEAC,KAAKlB,GACL;IACI,OAAOmB,aAAanB,GAAK,iBAAe,CAAK,mBAAeA,KAAKF,oBAAoB;EAAA,CACzF;EAEA,MAAMsB,KAAKpB,GAAa,SAAuCqB,MAC/D;IACI,IAAIC,GAAW;IAEf,IAAIC,WAAWf,iBACf;MACI,IAAI,KAAKQ,MAAO,mBAAiB,MAAMQ,cAAcC,wBACrD;QACUH,YAAME,aAAc,iBAAgBxB,GAAG;MAAA,CAGjD;QACUsB,YAAMI,gBAAgB1B,GAAG;MAAA;IACnC,CAGJ;MACIsB,MAAM,MAAM,IAAIK,OAAQ,CAACC,OACzB;QACIN,MAAM,IAAIO,KAAM;QAChBP,IAAIQ,WAAc;QAElBR,IAAIA,GAAM;QACV,IAAIA,IAAIS,QACR;UACIH,QAAQN,GAAG;QAAA,CAGf;UACIA,IAAIU,SAAS,MACb;YACIJ,QAAQN,GAAG;UAAA,CACf;QAAA;MACJ,CACH;IAAA;IAGC,aAAO,IAAIW,YAAYX,GAAK;MAC9BY,YAAYC,KAAM,oBAAmBnC,GAAG;MACxC,GAAGoC,KAAM;IAAA,CACZ;IAEDC,KAAKC,SAAShB,GAAM;IAEb,qBAAce,IAAM,UAAQrC,GAAG;EAAA,CAC1C;EAEAuC,OAAOC,OACP;IACIA,QAAQC,QAAQ,IAAI;EAAA;AAE5B;AAEAC,WAAWC,IAAIjC,YAAY","names":["validImageExtensions","validImageMIMEs","url","response","settings","fetch","ok","Error","statusText","blob","createImageBitmap","imageBlob","loadTextures","extension","type","ExtensionType","priority","LoaderParserPriority","config","preferWorkers","test","checkDataUrl","load","loader","src","globalThis","WorkerManager","isImageBitmapSupported","loadImageBitmap","Promise","resolve","Image","crossOrigin","complete","onload","BaseTexture","resolution","utils","asset","base","resource","unload","texture","destroy","extensions","add"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/assets/src/loader/parsers/textures/loadTextures.ts"],"sourcesContent":["import { BaseTexture, extensions, ExtensionType, settings, utils } from '@pixi/core';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { LoaderParserPriority } from '../LoaderParser';\nimport { WorkerManager } from '../WorkerManager';\nimport { createTexture } from './utils/createTexture';\n\nimport type { IBaseTextureOptions, Texture } from '@pixi/core';\nimport type { Loader } from '../../Loader';\nimport type { LoadAsset } from '../../types';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validImageExtensions = ['.jpeg', '.jpg', '.png', '.webp', '.avif'];\nconst validImageMIMEs = [\n    'image/jpeg',\n    'image/png',\n    'image/webp',\n    'image/avif',\n];\n\n/**\n * Returns a promise that resolves an ImageBitmaps.\n * This function is designed to be used by a worker.\n * Part of WorkerManager!\n * @param url - The image to load an image bitmap for\n */\nexport async function loadImageBitmap(url: string): Promise<ImageBitmap>\n{\n    const response = await settings.ADAPTER.fetch(url);\n\n    if (!response.ok)\n    {\n        throw new Error(`[loadImageBitmap] Failed to fetch ${url}: `\n            + `${response.status} ${response.statusText}`);\n    }\n\n    const imageBlob = await response.blob();\n    const imageBitmap = await createImageBitmap(imageBlob);\n\n    return imageBitmap;\n}\n\n/**\n * Loads our textures!\n * this makes use of imageBitmaps where available.\n * We load the ImageBitmap on a different thread using the WorkerManager\n * We can then use the ImageBitmap as a source for a Pixi Texture\n */\nexport const loadTextures = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n    },\n\n    config: {\n        preferWorkers: true,\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n    },\n\n    async load(url: string, asset: LoadAsset<IBaseTextureOptions>, loader: Loader): Promise<Texture>\n    {\n        let src: any = null;\n\n        if (globalThis.createImageBitmap)\n        {\n            if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported())\n            {\n                src = await WorkerManager.loadImageBitmap(url);\n            }\n            else\n            {\n                src = await loadImageBitmap(url);\n            }\n        }\n        else\n        {\n            src = await new Promise((resolve) =>\n            {\n                src = new Image();\n                src.crossOrigin = 'anonymous';\n\n                src.src = url;\n                if (src.complete)\n                {\n                    resolve(src);\n                }\n                else\n                {\n                    src.onload = (): void =>\n                    {\n                        resolve(src);\n                    };\n                }\n            });\n        }\n\n        const base = new BaseTexture(src, {\n            resolution: utils.getResolutionOfUrl(url),\n            ...asset.data,\n        });\n\n        base.resource.src = url;\n\n        return createTexture(base, loader, url);\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n} as LoaderParser<Texture, IBaseTextureOptions>;\n\nextensions.add(loadTextures);\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}