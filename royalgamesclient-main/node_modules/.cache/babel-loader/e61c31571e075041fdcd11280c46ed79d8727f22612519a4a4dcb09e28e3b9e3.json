{"ast":null,"code":"import { BufferResource, ViewableBuffer } from '@pixi/core';\nclass BlobResource extends BufferResource {\n  constructor(source) {\n    var _data2;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      width: 1,\n      height: 1,\n      autoLoad: true\n    };\n    let origin;\n    let data;\n    if (typeof source === \"string\") {\n      origin = source;\n      data = new Uint8Array();\n    } else {\n      origin = null;\n      data = source;\n    }\n    super(data, options);\n    this.origin = origin;\n    this.buffer = data ? new ViewableBuffer(data) : null;\n    if (this.origin && options.autoLoad !== false) {\n      this.load();\n    }\n    if ((_data2 = data) !== null && _data2 !== void 0 && _data2.length) {\n      this.loaded = true;\n      this.onBlobLoaded(this.buffer.rawBinaryData);\n    }\n  }\n  onBlobLoaded(_data) {}\n  async load() {\n    const response = await fetch(this.origin);\n    const blob = await response.blob();\n    const arrayBuffer = await blob.arrayBuffer();\n    this.data = new Uint32Array(arrayBuffer);\n    this.buffer = new ViewableBuffer(arrayBuffer);\n    this.loaded = true;\n    this.onBlobLoaded(arrayBuffer);\n    this.update();\n    return this;\n  }\n}\nexport { BlobResource };","map":{"version":3,"mappings":";AAiBO,MAAeA,qBAAqBC,cAC3C;EAaIC,YAAYC,MACR,EACJ;IAAA;IAAA,IADIC,8EAAwB;MAAEC,OAAO;MAAGC,MAAQ;MAAGC,QAAU;IAAA,CAC7D;IACQ;IACA;IAEA,WAAOJ,WAAW,QACtB;MACaK;MACTC,OAAO,IAAIC,UAAW;IAAA,CAG1B;MACaF;MACFC;IAAA;IAGX,MAAMA,MAAML,OAAO;IAMnB,KAAKI,MAAS;IAOd,KAAKG,MAAS,UAAO,IAAIC,eAAeH,IAAI,CAAI;IAGhD,IAAI,IAAK,WAAUL,OAAQ,cAAa,KACxC;MACI,KAAKS,IAAK;IAAA;IAEd,cAAIJ,8CAAMK,MACV;MACI,KAAKC,MAAS;MACT,kBAAa,IAAK,QAAOC,aAAa;IAAA;EAC/C;EAGMC,aAAaC,KACvB;EAKA,MAAML,IACNA;IACI,MAAMM,QAAW,SAAMC,KAAM,MAAKZ,MAAM;IAClC,aAAO,MAAMW,SAASE,IAAK;IAC3B,oBAAc,MAAMA,KAAKC,WAAY;IAEtC,YAAO,IAAIC,YAAYD,WAAW;IAClC,cAAS,IAAIV,eAAeU,WAAW;IAC5C,KAAKP,MAAS;IAEd,KAAKE,aAAaK,WAAW;IAC7B,KAAKE,MAAO;IAEL;EAAA;AAEf","names":["BlobResource","BufferResource","constructor","source","options","width","height","autoLoad","origin","data","Uint8Array","buffer","ViewableBuffer","load","length","loaded","rawBinaryData","onBlobLoaded","_data","response","fetch","blob","arrayBuffer","Uint32Array","update"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/compressed-textures/src/resources/BlobResource.ts"],"sourcesContent":["import { BufferResource, ViewableBuffer } from '@pixi/core';\n\nimport type { Resource } from '@pixi/core';\n\ninterface IBlobOptions\n{\n    autoLoad?: boolean;\n    width: number;\n    height: number;\n}\n\n/**\n * Resource that fetches texture data over the network and stores it in a buffer.\n * @class\n * @extends PIXI.Resource\n * @memberof PIXI\n */\nexport abstract class BlobResource extends BufferResource\n{\n    protected origin: string;\n    protected buffer: ViewableBuffer;\n    protected loaded: boolean;\n\n    /**\n     * @param {string} source - the URL of the texture file\n     * @param {PIXI.IBlobOptions} options\n     * @param {boolean}[options.autoLoad] - whether to fetch the data immediately;\n     *  you can fetch it later via {@link BlobResource#load}\n     * @param {boolean}[options.width] - the width in pixels.\n     * @param {boolean}[options.height] - the height in pixels.\n     */\n    constructor(source: string | Uint8Array | Uint32Array | Float32Array,\n        options: IBlobOptions = { width: 1, height: 1, autoLoad: true })\n    {\n        let origin: string;\n        let data: Uint8Array | Uint32Array | Float32Array;\n\n        if (typeof source === 'string')\n        {\n            origin = source;\n            data = new Uint8Array();\n        }\n        else\n        {\n            origin = null;\n            data = source;\n        }\n\n        super(data, options);\n\n        /**\n         * The URL of the texture file\n         * @member {string}\n         */\n        this.origin = origin;\n\n        /**\n         * The viewable buffer on the data\n         * @member {ViewableBuffer}\n         */\n        // HINT: BlobResource allows \"null\" sources, assuming the child class provides an alternative\n        this.buffer = data ? new ViewableBuffer(data) : null;\n\n        // Allow autoLoad = \"undefined\" still load the resource by default\n        if (this.origin && options.autoLoad !== false)\n        {\n            this.load();\n        }\n        if (data?.length)\n        {\n            this.loaded = true;\n            this.onBlobLoaded(this.buffer.rawBinaryData);\n        }\n    }\n\n    protected onBlobLoaded(_data: ArrayBuffer): void\n    {\n        // TODO: Override this method\n    }\n\n    /** Loads the blob */\n    async load(): Promise<Resource>\n    {\n        const response = await fetch(this.origin);\n        const blob = await response.blob();\n        const arrayBuffer = await blob.arrayBuffer();\n\n        this.data = new Uint32Array(arrayBuffer);\n        this.buffer = new ViewableBuffer(arrayBuffer);\n        this.loaded = true;\n\n        this.onBlobLoaded(arrayBuffer);\n        this.update();\n\n        return this;\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}