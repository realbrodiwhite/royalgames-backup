{"ast":null,"code":"import { Point, BatchGeometry, WRAP_MODES, BaseTexture, BatchDrawCall, BatchTextureArray, DRAW_MODES, utils } from '@pixi/core';\nimport { Bounds } from '@pixi/display';\nimport { GraphicsData } from './GraphicsData.mjs';\nimport { DRAW_CALL_POOL, BATCH_POOL, FILL_COMMANDS } from './utils/index.mjs';\nimport { BatchPart } from './utils/BatchPart.mjs';\nimport { buildPoly } from './utils/buildPoly.mjs';\nimport { buildLine } from './utils/buildLine.mjs';\nconst tmpPoint = new Point();\nconst _GraphicsGeometry = class extends BatchGeometry {\n  constructor() {\n    super();\n    this.closePointEps = 1e-4;\n    this.boundsPadding = 0;\n    this.uvsFloat32 = null;\n    this.indicesUint16 = null;\n    this.batchable = false;\n    this.points = [];\n    this.colors = [];\n    this.uvs = [];\n    this.indices = [];\n    this.textureIds = [];\n    this.graphicsData = [];\n    this.drawCalls = [];\n    this.batchDirty = -1;\n    this.batches = [];\n    this.dirty = 0;\n    this.cacheDirty = -1;\n    this.clearDirty = 0;\n    this.shapeIndex = 0;\n    this._bounds = new Bounds();\n    this.boundsDirty = -1;\n  }\n  get bounds() {\n    this.updateBatches();\n    if (this.boundsDirty !== this.dirty) {\n      this.boundsDirty = this.dirty;\n      this.calculateBounds();\n    }\n    return this._bounds;\n  }\n  invalidate() {\n    this.boundsDirty = -1;\n    this.dirty++;\n    this.batchDirty++;\n    this.shapeIndex = 0;\n    this.points.length = 0;\n    this.colors.length = 0;\n    this.uvs.length = 0;\n    this.indices.length = 0;\n    this.textureIds.length = 0;\n    for (let i = 0; i < this.drawCalls.length; i++) {\n      this.drawCalls[i].texArray.clear();\n      DRAW_CALL_POOL.push(this.drawCalls[i]);\n    }\n    this.drawCalls.length = 0;\n    for (let i = 0; i < this.batches.length; i++) {\n      const batchPart = this.batches[i];\n      batchPart.reset();\n      BATCH_POOL.push(batchPart);\n    }\n    this.batches.length = 0;\n  }\n  clear() {\n    if (this.graphicsData.length > 0) {\n      this.invalidate();\n      this.clearDirty++;\n      this.graphicsData.length = 0;\n    }\n    return this;\n  }\n  drawShape(shape) {\n    let fillStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let lineStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let matrix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n    this.graphicsData.push(data);\n    this.dirty++;\n    return this;\n  }\n  drawHole(shape) {\n    let matrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (!this.graphicsData.length) {\n      return null;\n    }\n    const data = new GraphicsData(shape, null, null, matrix);\n    const lastShape = this.graphicsData[this.graphicsData.length - 1];\n    data.lineStyle = lastShape.lineStyle;\n    lastShape.holes.push(data);\n    this.dirty++;\n    return this;\n  }\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.graphicsData.length; ++i) {\n      this.graphicsData[i].destroy();\n    }\n    this.points.length = 0;\n    this.points = null;\n    this.colors.length = 0;\n    this.colors = null;\n    this.uvs.length = 0;\n    this.uvs = null;\n    this.indices.length = 0;\n    this.indices = null;\n    this.indexBuffer.destroy();\n    this.indexBuffer = null;\n    this.graphicsData.length = 0;\n    this.graphicsData = null;\n    this.drawCalls.length = 0;\n    this.drawCalls = null;\n    this.batches.length = 0;\n    this.batches = null;\n    this._bounds = null;\n  }\n  containsPoint(point) {\n    const graphicsData = this.graphicsData;\n    for (let i = 0; i < graphicsData.length; ++i) {\n      const data = graphicsData[i];\n      if (!data.fillStyle.visible) {\n        continue;\n      }\n      if (data.shape) {\n        if (data.matrix) {\n          data.matrix.applyInverse(point, tmpPoint);\n        } else {\n          tmpPoint.copyFrom(point);\n        }\n        if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {\n          let hitHole = false;\n          if (data.holes) {\n            for (let i2 = 0; i2 < data.holes.length; i2++) {\n              const hole = data.holes[i2];\n              if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {\n                hitHole = true;\n                break;\n              }\n            }\n          }\n          if (!hitHole) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  updateBatches() {\n    if (!this.graphicsData.length) {\n      this.batchable = true;\n      return;\n    }\n    if (!this.validateBatching()) {\n      return;\n    }\n    this.cacheDirty = this.dirty;\n    const uvs = this.uvs;\n    const graphicsData = this.graphicsData;\n    let batchPart = null;\n    let currentStyle = null;\n    if (this.batches.length > 0) {\n      batchPart = this.batches[this.batches.length - 1];\n      currentStyle = batchPart.style;\n    }\n    for (let i = this.shapeIndex; i < graphicsData.length; i++) {\n      this.shapeIndex++;\n      const data = graphicsData[i];\n      const fillStyle = data.fillStyle;\n      const lineStyle = data.lineStyle;\n      const command = FILL_COMMANDS[data.type];\n      command.build(data);\n      if (data.matrix) {\n        this.transformPoints(data.points, data.matrix);\n      }\n      if (fillStyle.visible || lineStyle.visible) {\n        this.processHoles(data.holes);\n      }\n      for (let j = 0; j < 2; j++) {\n        const style = j === 0 ? fillStyle : lineStyle;\n        if (!style.visible) continue;\n        const nextTexture = style.texture.baseTexture;\n        const index2 = this.indices.length;\n        const attribIndex = this.points.length / 2;\n        nextTexture.wrapMode = WRAP_MODES.REPEAT;\n        if (j === 0) {\n          this.processFill(data);\n        } else {\n          this.processLine(data);\n        }\n        const size = this.points.length / 2 - attribIndex;\n        if (size === 0) continue;\n        if (batchPart && !this._compareStyles(currentStyle, style)) {\n          batchPart.end(index2, attribIndex);\n          batchPart = null;\n        }\n        if (!batchPart) {\n          batchPart = BATCH_POOL.pop() || new BatchPart();\n          batchPart.begin(style, index2, attribIndex);\n          this.batches.push(batchPart);\n          currentStyle = style;\n        }\n        this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n      }\n    }\n    const index = this.indices.length;\n    const attrib = this.points.length / 2;\n    if (batchPart) {\n      batchPart.end(index, attrib);\n    }\n    if (this.batches.length === 0) {\n      this.batchable = true;\n      return;\n    }\n    const need32 = attrib > 65535;\n    if (this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2) {\n      this.indicesUint16.set(this.indices);\n    } else {\n      this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);\n    }\n    this.batchable = this.isBatchable();\n    if (this.batchable) {\n      this.packBatches();\n    } else {\n      this.buildDrawCalls();\n    }\n  }\n  _compareStyles(styleA, styleB) {\n    if (!styleA || !styleB) {\n      return false;\n    }\n    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {\n      return false;\n    }\n    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {\n      return false;\n    }\n    if (!!styleA.native !== !!styleB.native) {\n      return false;\n    }\n    return true;\n  }\n  validateBatching() {\n    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {\n      return false;\n    }\n    for (let i = 0, l = this.graphicsData.length; i < l; i++) {\n      const data = this.graphicsData[i];\n      const fill = data.fillStyle;\n      const line = data.lineStyle;\n      if (fill && !fill.texture.baseTexture.valid) return false;\n      if (line && !line.texture.baseTexture.valid) return false;\n    }\n    return true;\n  }\n  packBatches() {\n    this.batchDirty++;\n    this.uvsFloat32 = new Float32Array(this.uvs);\n    const batches = this.batches;\n    for (let i = 0, l = batches.length; i < l; i++) {\n      const batch = batches[i];\n      for (let j = 0; j < batch.size; j++) {\n        const index = batch.start + j;\n        this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n      }\n    }\n  }\n  isBatchable() {\n    if (this.points.length > 65535 * 2) {\n      return false;\n    }\n    const batches = this.batches;\n    for (let i = 0; i < batches.length; i++) {\n      if (batches[i].style.native) {\n        return false;\n      }\n    }\n    return this.points.length < _GraphicsGeometry.BATCHABLE_SIZE * 2;\n  }\n  buildDrawCalls() {\n    let TICK = ++BaseTexture._globalBatch;\n    for (let i = 0; i < this.drawCalls.length; i++) {\n      this.drawCalls[i].texArray.clear();\n      DRAW_CALL_POOL.push(this.drawCalls[i]);\n    }\n    this.drawCalls.length = 0;\n    const colors = this.colors;\n    const textureIds = this.textureIds;\n    let currentGroup = DRAW_CALL_POOL.pop();\n    if (!currentGroup) {\n      currentGroup = new BatchDrawCall();\n      currentGroup.texArray = new BatchTextureArray();\n    }\n    currentGroup.texArray.count = 0;\n    currentGroup.start = 0;\n    currentGroup.size = 0;\n    currentGroup.type = DRAW_MODES.TRIANGLES;\n    let textureCount = 0;\n    let currentTexture = null;\n    let textureId = 0;\n    let native = false;\n    let drawMode = DRAW_MODES.TRIANGLES;\n    let index = 0;\n    this.drawCalls.push(currentGroup);\n    for (let i = 0; i < this.batches.length; i++) {\n      const data = this.batches[i];\n      const maxTextures = 8;\n      const style = data.style;\n      const nextTexture = style.texture.baseTexture;\n      if (native !== !!style.native) {\n        native = !!style.native;\n        drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;\n        currentTexture = null;\n        textureCount = maxTextures;\n        TICK++;\n      }\n      if (currentTexture !== nextTexture) {\n        currentTexture = nextTexture;\n        if (nextTexture._batchEnabled !== TICK) {\n          if (textureCount === maxTextures) {\n            TICK++;\n            textureCount = 0;\n            if (currentGroup.size > 0) {\n              currentGroup = DRAW_CALL_POOL.pop();\n              if (!currentGroup) {\n                currentGroup = new BatchDrawCall();\n                currentGroup.texArray = new BatchTextureArray();\n              }\n              this.drawCalls.push(currentGroup);\n            }\n            currentGroup.start = index;\n            currentGroup.size = 0;\n            currentGroup.texArray.count = 0;\n            currentGroup.type = drawMode;\n          }\n          nextTexture.touched = 1;\n          nextTexture._batchEnabled = TICK;\n          nextTexture._batchLocation = textureCount;\n          nextTexture.wrapMode = WRAP_MODES.REPEAT;\n          currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;\n          textureCount++;\n        }\n      }\n      currentGroup.size += data.size;\n      index += data.size;\n      textureId = nextTexture._batchLocation;\n      this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);\n      this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);\n    }\n    BaseTexture._globalBatch = TICK;\n    this.packAttributes();\n  }\n  packAttributes() {\n    const verts = this.points;\n    const uvs = this.uvs;\n    const colors = this.colors;\n    const textureIds = this.textureIds;\n    const glPoints = new ArrayBuffer(verts.length * 3 * 4);\n    const f32 = new Float32Array(glPoints);\n    const u32 = new Uint32Array(glPoints);\n    let p = 0;\n    for (let i = 0; i < verts.length / 2; i++) {\n      f32[p++] = verts[i * 2];\n      f32[p++] = verts[i * 2 + 1];\n      f32[p++] = uvs[i * 2];\n      f32[p++] = uvs[i * 2 + 1];\n      u32[p++] = colors[i];\n      f32[p++] = textureIds[i];\n    }\n    this._buffer.update(glPoints);\n    this._indexBuffer.update(this.indicesUint16);\n  }\n  processFill(data) {\n    if (data.holes.length) {\n      buildPoly.triangulate(data, this);\n    } else {\n      const command = FILL_COMMANDS[data.type];\n      command.triangulate(data, this);\n    }\n  }\n  processLine(data) {\n    buildLine(data, this);\n    for (let i = 0; i < data.holes.length; i++) {\n      buildLine(data.holes[i], this);\n    }\n  }\n  processHoles(holes) {\n    for (let i = 0; i < holes.length; i++) {\n      const hole = holes[i];\n      const command = FILL_COMMANDS[hole.type];\n      command.build(hole);\n      if (hole.matrix) {\n        this.transformPoints(hole.points, hole.matrix);\n      }\n    }\n  }\n  calculateBounds() {\n    const bounds = this._bounds;\n    bounds.clear();\n    bounds.addVertexData(this.points, 0, this.points.length);\n    bounds.pad(this.boundsPadding, this.boundsPadding);\n  }\n  transformPoints(points, matrix) {\n    for (let i = 0; i < points.length / 2; i++) {\n      const x = points[i * 2];\n      const y = points[i * 2 + 1];\n      points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx;\n      points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;\n    }\n  }\n  addColors(colors, color, alpha, size) {\n    let offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    const rgb = (color >> 16) + (color & 65280) + ((color & 255) << 16);\n    const rgba = utils.premultiplyTint(rgb, alpha);\n    colors.length = Math.max(colors.length, offset + size);\n    for (let i = 0; i < size; i++) {\n      colors[offset + i] = rgba;\n    }\n  }\n  addTextureIds(textureIds, id, size) {\n    let offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    textureIds.length = Math.max(textureIds.length, offset + size);\n    for (let i = 0; i < size; i++) {\n      textureIds[offset + i] = id;\n    }\n  }\n  addUvs(verts, uvs, texture, start, size) {\n    let matrix = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    let index = 0;\n    const uvsStart = uvs.length;\n    const frame = texture.frame;\n    while (index < size) {\n      let x = verts[(start + index) * 2];\n      let y = verts[(start + index) * 2 + 1];\n      if (matrix) {\n        const nx = matrix.a * x + matrix.c * y + matrix.tx;\n        y = matrix.b * x + matrix.d * y + matrix.ty;\n        x = nx;\n      }\n      index++;\n      uvs.push(x / frame.width, y / frame.height);\n    }\n    const baseTexture = texture.baseTexture;\n    if (frame.width < baseTexture.width || frame.height < baseTexture.height) {\n      this.adjustUvs(uvs, texture, uvsStart, size);\n    }\n  }\n  adjustUvs(uvs, texture, start, size) {\n    const baseTexture = texture.baseTexture;\n    const eps = 1e-6;\n    const finish = start + size * 2;\n    const frame = texture.frame;\n    const scaleX = frame.width / baseTexture.width;\n    const scaleY = frame.height / baseTexture.height;\n    let offsetX = frame.x / frame.width;\n    let offsetY = frame.y / frame.height;\n    let minX = Math.floor(uvs[start] + eps);\n    let minY = Math.floor(uvs[start + 1] + eps);\n    for (let i = start + 2; i < finish; i += 2) {\n      minX = Math.min(minX, Math.floor(uvs[i] + eps));\n      minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n    }\n    offsetX -= minX;\n    offsetY -= minY;\n    for (let i = start; i < finish; i += 2) {\n      uvs[i] = (uvs[i] + offsetX) * scaleX;\n      uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n    }\n  }\n};\nlet GraphicsGeometry = _GraphicsGeometry;\nGraphicsGeometry.BATCHABLE_SIZE = 100;\nexport { GraphicsGeometry };","map":{"version":3,"mappings":"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","names":["tmpPoint","Point","_GraphicsGeometry","BatchGeometry","constructor","closePointEps","boundsPadding","dirty","cacheDirty","clearDirty","shapeIndex","Bounds","boundsDirty","bounds","updateBatches","calculateBounds","invalidate","points","length","colors","uvs","indices","textureIds","i","clear","DRAW_CALL_POOL","drawCalls","batches","batchPart","reset","BATCH_POOL","push","graphicsData","drawShape","shape","fillStyle","lineStyle","matrix","data","GraphicsData","drawHole","lastShape","destroy","indexBuffer","_bounds","containsPoint","point","visible","applyInverse","copyFrom","x","y","hitHole","holes","i2","hole","batchable","currentStyle","FILL_COMMANDS","command","build","transformPoints","j","style","texture","nextTexture","wrapMode","WRAP_MODES","processFill","processLine","size","_compareStyles","index2","attribIndex","BatchPart","index","attrib","need32","indicesUint16","set","Uint32Array","Uint16Array","isBatchable","packBatches","buildDrawCalls","styleB","styleA","baseTexture","color","alpha","native","validateBatching","l","fill","line","uvsFloat32","Float32Array","batch","start","BATCHABLE_SIZE","BaseTexture","pop","currentGroup","BatchDrawCall","BatchTextureArray","texArray","count","type","DRAW_MODES","textureCount","currentTexture","textureId","drawMode","maxTextures","TICK","_batchEnabled","touched","_batchLocation","attribSize","attribStart","addTextureIds","_globalBatch","packAttributes","verts","glPoints","ArrayBuffer","p","f32","u32","update","buildPoly","buildLine","processHoles","addVertexData","pad","b","d","addColors","offset","rgb","rgba","premultiplyTint","Math","id","addUvs","uvsStart","frame","nx","width","height","adjustUvs","eps","minX","floor","minY","min","offsetX","offsetY","GraphicsGeometry"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/graphics/src/GraphicsGeometry.ts"],"sourcesContent":["import {\n    BaseTexture,\n    BatchDrawCall,\n    BatchGeometry,\n    BatchTextureArray,\n    DRAW_MODES,\n    Point,\n    utils,\n    WRAP_MODES,\n} from '@pixi/core';\nimport { Bounds } from '@pixi/display';\nimport { GraphicsData } from './GraphicsData';\nimport {\n    BATCH_POOL,\n    BatchPart,\n    buildLine,\n    buildPoly,\n    DRAW_CALL_POOL,\n    FILL_COMMANDS,\n} from './utils';\n\nimport type { Circle, Ellipse, IPointData, Matrix, Polygon, Rectangle, RoundedRectangle, Texture } from '@pixi/core';\nimport type { FillStyle } from './styles/FillStyle';\nimport type { LineStyle } from './styles/LineStyle';\n\n/*\n * Complex shape type\n * @todo Move to Math shapes\n */\ntype IShape = Circle | Ellipse | Polygon | Rectangle | RoundedRectangle;\n\nconst tmpPoint = new Point();\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * GraphicsGeometry is designed to not be continually updating the geometry since it's expensive\n * to re-tesselate using **earcut**. Consider using {@link PIXI.Mesh} for this use-case, it's much faster.\n * @memberof PIXI\n */\nexport class GraphicsGeometry extends BatchGeometry\n{\n    /** The maximum number of points to consider an object \"batchable\", able to be batched by the renderer's batch system. */\n    public static BATCHABLE_SIZE = 100;\n\n    /** Minimal distance between points that are considered different. Affects line tesselation. */\n    public closePointEps = 1e-4;\n\n    /** Padding to add to the bounds. */\n    public boundsPadding = 0;\n\n    uvsFloat32: Float32Array = null;\n    indicesUint16: Uint16Array | Uint32Array = null;\n    batchable = false;\n\n    /** An array of points to draw, 2 numbers per point */\n    points: number[] = [];\n\n    /** The collection of colors */\n    colors: number[] = [];\n\n    /** The UVs collection */\n    uvs: number[] = [];\n\n    /** The indices of the vertices */\n    indices: number[] = [];\n\n    /** Reference to the texture IDs. */\n    textureIds: number[] = [];\n\n    /**\n     * The collection of drawn shapes.\n     * @member {PIXI.GraphicsData[]}\n     */\n    graphicsData: Array<GraphicsData> = [];\n\n    /**\n     * List of current draw calls drived from the batches.\n     * @member {PIXI.BatchDrawCall[]}\n     */\n    drawCalls: Array<BatchDrawCall> = [];\n\n    /** Batches need to regenerated if the geometry is updated. */\n    batchDirty = -1;\n\n    /**\n     * Intermediate abstract format sent to batch system.\n     * Can be converted to drawCalls or to batchable objects.\n     * @member {PIXI.graphicsUtils.BatchPart[]}\n     */\n    batches: Array<BatchPart> = [];\n\n    /** Used to detect if the graphics object has changed. */\n    protected dirty = 0;\n\n    /** Used to check if the cache is dirty. */\n    protected cacheDirty = -1;\n\n    /** Used to detect if we cleared the graphicsData. */\n    protected clearDirty = 0;\n\n    /** Index of the last batched shape in the stack of calls. */\n    protected shapeIndex = 0;\n\n    /** Cached bounds. */\n    protected _bounds: Bounds = new Bounds();\n\n    /** The bounds dirty flag. */\n    protected boundsDirty = -1;\n\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n    constructor()\n    {\n        super();\n    }\n\n    /**\n     * Get the current bounds of the graphic geometry.\n     *\n     * Since 6.5.0, bounds of the graphics geometry are calculated based on the vertices of generated geometry.\n     * Since shapes or strokes with full transparency (`alpha: 0`) will not generate geometry, they are not considered\n     * when calculating bounds for the graphics geometry. See PR [#8343]{@link https://github.com/pixijs/pixijs/pull/8343}\n     * and issue [#8623]{@link https://github.com/pixijs/pixijs/pull/8623}.\n     * @readonly\n     */\n    public get bounds(): Bounds\n    {\n        this.updateBatches();\n\n        if (this.boundsDirty !== this.dirty)\n        {\n            this.boundsDirty = this.dirty;\n            this.calculateBounds();\n        }\n\n        return this._bounds;\n    }\n\n    /** Call if you changed graphicsData manually. Empties all batch buffers. */\n    protected invalidate(): void\n    {\n        this.boundsDirty = -1;\n        this.dirty++;\n        this.batchDirty++;\n        this.shapeIndex = 0;\n\n        this.points.length = 0;\n        this.colors.length = 0;\n        this.uvs.length = 0;\n        this.indices.length = 0;\n        this.textureIds.length = 0;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].texArray.clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const batchPart = this.batches[i];\n\n            batchPart.reset();\n            BATCH_POOL.push(batchPart);\n        }\n\n        this.batches.length = 0;\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     * @returns - This GraphicsGeometry object. Good for chaining method calls\n     */\n    public clear(): GraphicsGeometry\n    {\n        if (this.graphicsData.length > 0)\n        {\n            this.invalidate();\n            this.clearDirty++;\n            this.graphicsData.length = 0;\n        }\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param fillStyle - Defines style of the fill.\n     * @param lineStyle - Defines style of the lines.\n     * @param matrix - Transform applied to the points of the shape.\n     * @returns - Returns geometry for chaining.\n     */\n    public drawShape(\n        shape: IShape,\n        fillStyle: FillStyle = null,\n        lineStyle: LineStyle = null,\n        matrix: Matrix = null): GraphicsGeometry\n    {\n        const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n\n        this.graphicsData.push(data);\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param matrix - Transform applied to the points of the shape.\n     * @returns - Returns geometry for chaining.\n     */\n    public drawHole(shape: IShape, matrix: Matrix = null): GraphicsGeometry\n    {\n        if (!this.graphicsData.length)\n        {\n            return null;\n        }\n\n        const data = new GraphicsData(shape, null, null, matrix);\n\n        const lastShape = this.graphicsData[this.graphicsData.length - 1];\n\n        data.lineStyle = lastShape.lineStyle;\n\n        lastShape.holes.push(data);\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /** Destroys the GraphicsGeometry object. */\n    public destroy(): void\n    {\n        super.destroy();\n\n        // destroy each of the GraphicsData objects\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            this.graphicsData[i].destroy();\n        }\n\n        this.points.length = 0;\n        this.points = null;\n        this.colors.length = 0;\n        this.colors = null;\n        this.uvs.length = 0;\n        this.uvs = null;\n        this.indices.length = 0;\n        this.indices = null;\n        this.indexBuffer.destroy();\n        this.indexBuffer = null;\n        this.graphicsData.length = 0;\n        this.graphicsData = null;\n        this.drawCalls.length = 0;\n        this.drawCalls = null;\n        this.batches.length = 0;\n        this.batches = null;\n        this._bounds = null;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     * @param point - Point to check if it's contained.\n     * @returns {boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        const graphicsData = this.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            if (!data.fillStyle.visible)\n            {\n                continue;\n            }\n\n            // only deal with fills..\n            if (data.shape)\n            {\n                if (data.matrix)\n                {\n                    data.matrix.applyInverse(point, tmpPoint);\n                }\n                else\n                {\n                    tmpPoint.copyFrom(point);\n                }\n\n                if (data.shape.contains(tmpPoint.x, tmpPoint.y))\n                {\n                    let hitHole = false;\n\n                    if (data.holes)\n                    {\n                        for (let i = 0; i < data.holes.length; i++)\n                        {\n                            const hole = data.holes[i];\n\n                            if (hole.shape.contains(tmpPoint.x, tmpPoint.y))\n                            {\n                                hitHole = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!hitHole)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Generates intermediate batch data. Either gets converted to drawCalls\n     * or used to convert to batch objects directly by the Graphics object.\n     */\n    updateBatches(): void\n    {\n        if (!this.graphicsData.length)\n        {\n            this.batchable = true;\n\n            return;\n        }\n\n        if (!this.validateBatching())\n        {\n            return;\n        }\n\n        this.cacheDirty = this.dirty;\n\n        const uvs = this.uvs;\n        const graphicsData = this.graphicsData;\n\n        let batchPart: BatchPart = null;\n\n        let currentStyle = null;\n\n        if (this.batches.length > 0)\n        {\n            batchPart = this.batches[this.batches.length - 1];\n            currentStyle = batchPart.style;\n        }\n\n        for (let i = this.shapeIndex; i < graphicsData.length; i++)\n        {\n            this.shapeIndex++;\n\n            const data = graphicsData[i];\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n            const command = FILL_COMMANDS[data.type];\n\n            // build out the shapes points..\n            command.build(data);\n\n            if (data.matrix)\n            {\n                this.transformPoints(data.points, data.matrix);\n            }\n\n            if (fillStyle.visible || lineStyle.visible)\n            {\n                this.processHoles(data.holes);\n            }\n\n            for (let j = 0; j < 2; j++)\n            {\n                const style = (j === 0) ? fillStyle : lineStyle;\n\n                if (!style.visible) continue;\n\n                const nextTexture = style.texture.baseTexture;\n                const index = this.indices.length;\n                const attribIndex = this.points.length / 2;\n\n                nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n                if (j === 0)\n                {\n                    this.processFill(data);\n                }\n                else\n                {\n                    this.processLine(data);\n                }\n\n                const size = (this.points.length / 2) - attribIndex;\n\n                if (size === 0) continue;\n                // close batch if style is different\n                if (batchPart && !this._compareStyles(currentStyle, style))\n                {\n                    batchPart.end(index, attribIndex);\n                    batchPart = null;\n                }\n                // spawn new batch if its first batch or previous was closed\n                if (!batchPart)\n                {\n                    batchPart = BATCH_POOL.pop() || new BatchPart();\n                    batchPart.begin(style, index, attribIndex);\n                    this.batches.push(batchPart);\n                    currentStyle = style;\n                }\n\n                this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n            }\n        }\n\n        const index = this.indices.length;\n        const attrib = this.points.length / 2;\n\n        if (batchPart)\n        {\n            batchPart.end(index, attrib);\n        }\n\n        if (this.batches.length === 0)\n        {\n            // there are no visible styles in GraphicsData\n            // its possible that someone wants Graphics just for the bounds\n            this.batchable = true;\n\n            return;\n        }\n\n        const need32 = attrib > 0xffff;\n\n        // prevent allocation when length is same as buffer\n        if (this.indicesUint16 && this.indices.length === this.indicesUint16.length\n            && need32 === (this.indicesUint16.BYTES_PER_ELEMENT > 2))\n        {\n            this.indicesUint16.set(this.indices);\n        }\n        else\n        {\n            this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);\n        }\n\n        // TODO make this a const..\n        this.batchable = this.isBatchable();\n\n        if (this.batchable)\n        {\n            this.packBatches();\n        }\n        else\n        {\n            this.buildDrawCalls();\n        }\n    }\n\n    /**\n     * Affinity check\n     * @param styleA\n     * @param styleB\n     */\n    protected _compareStyles(styleA: FillStyle | LineStyle, styleB: FillStyle | LineStyle): boolean\n    {\n        if (!styleA || !styleB)\n        {\n            return false;\n        }\n\n        if (styleA.texture.baseTexture !== styleB.texture.baseTexture)\n        {\n            return false;\n        }\n\n        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha)\n        {\n            return false;\n        }\n\n        if (!!(styleA as LineStyle).native !== !!(styleB as LineStyle).native)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /** Test geometry for batching process. */\n    protected validateBatching(): boolean\n    {\n        if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n        {\n            return false;\n        }\n\n        for (let i = 0, l = this.graphicsData.length; i < l; i++)\n        {\n            const data = this.graphicsData[i];\n            const fill = data.fillStyle;\n            const line = data.lineStyle;\n\n            if (fill && !fill.texture.baseTexture.valid) return false;\n            if (line && !line.texture.baseTexture.valid) return false;\n        }\n\n        return true;\n    }\n\n    /** Offset the indices so that it works with the batcher. */\n    protected packBatches(): void\n    {\n        this.batchDirty++;\n        this.uvsFloat32 = new Float32Array(this.uvs);\n\n        const batches = this.batches;\n\n        for (let i = 0, l = batches.length; i < l; i++)\n        {\n            const batch = batches[i];\n\n            for (let j = 0; j < batch.size; j++)\n            {\n                const index = batch.start + j;\n\n                this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n            }\n        }\n    }\n\n    /**\n     * Checks to see if this graphics geometry can be batched.\n     * Currently it needs to be small enough and not contain any native lines.\n     */\n    protected isBatchable(): boolean\n    {\n        // prevent heavy mesh batching\n        if (this.points.length > 0xffff * 2)\n        {\n            return false;\n        }\n\n        const batches = this.batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            if ((batches[i].style as LineStyle).native)\n            {\n                return false;\n            }\n        }\n\n        return (this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2);\n    }\n\n    /** Converts intermediate batches data to drawCalls. */\n    protected buildDrawCalls(): void\n    {\n        let TICK = ++BaseTexture._globalBatch;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].texArray.clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        let currentGroup: BatchDrawCall = DRAW_CALL_POOL.pop();\n\n        if (!currentGroup)\n        {\n            currentGroup = new BatchDrawCall();\n            currentGroup.texArray = new BatchTextureArray();\n        }\n        currentGroup.texArray.count = 0;\n        currentGroup.start = 0;\n        currentGroup.size = 0;\n        currentGroup.type = DRAW_MODES.TRIANGLES;\n\n        let textureCount = 0;\n        let currentTexture = null;\n        let textureId = 0;\n        let native = false;\n        let drawMode = DRAW_MODES.TRIANGLES;\n\n        let index = 0;\n\n        this.drawCalls.push(currentGroup);\n\n        // TODO - this can be simplified\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const data = this.batches[i];\n\n            // TODO add some full on MAX_TEXTURE CODE..\n            const maxTextures = 8;\n\n            // Forced cast for checking `native` without errors\n            const style = data.style as LineStyle;\n\n            const nextTexture = style.texture.baseTexture;\n\n            if (native !== !!style.native)\n            {\n                native = !!style.native;\n                drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;\n\n                // force the batch to break!\n                currentTexture = null;\n                textureCount = maxTextures;\n                TICK++;\n            }\n\n            if (currentTexture !== nextTexture)\n            {\n                currentTexture = nextTexture;\n\n                if (nextTexture._batchEnabled !== TICK)\n                {\n                    if (textureCount === maxTextures)\n                    {\n                        TICK++;\n\n                        textureCount = 0;\n\n                        if (currentGroup.size > 0)\n                        {\n                            currentGroup = DRAW_CALL_POOL.pop();\n                            if (!currentGroup)\n                            {\n                                currentGroup = new BatchDrawCall();\n                                currentGroup.texArray = new BatchTextureArray();\n                            }\n                            this.drawCalls.push(currentGroup);\n                        }\n\n                        currentGroup.start = index;\n                        currentGroup.size = 0;\n                        currentGroup.texArray.count = 0;\n                        currentGroup.type = drawMode;\n                    }\n\n                    // TODO add this to the render part..\n                    // Hack! Because texture has protected `touched`\n                    nextTexture.touched = 1;// touch;\n\n                    nextTexture._batchEnabled = TICK;\n                    nextTexture._batchLocation = textureCount;\n                    nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n                    currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;\n                    textureCount++;\n                }\n            }\n\n            currentGroup.size += data.size;\n            index += data.size;\n\n            textureId = nextTexture._batchLocation;\n\n            this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);\n            this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);\n        }\n\n        BaseTexture._globalBatch = TICK;\n\n        // upload..\n        // merge for now!\n        this.packAttributes();\n    }\n\n    /** Packs attributes to single buffer. */\n    protected packAttributes(): void\n    {\n        const verts = this.points;\n        const uvs = this.uvs;\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes\n        const glPoints = new ArrayBuffer(verts.length * 3 * 4);\n        const f32 = new Float32Array(glPoints);\n        const u32 = new Uint32Array(glPoints);\n\n        let p = 0;\n\n        for (let i = 0; i < verts.length / 2; i++)\n        {\n            f32[p++] = verts[i * 2];\n            f32[p++] = verts[(i * 2) + 1];\n\n            f32[p++] = uvs[i * 2];\n            f32[p++] = uvs[(i * 2) + 1];\n\n            u32[p++] = colors[i];\n\n            f32[p++] = textureIds[i];\n        }\n\n        this._buffer.update(glPoints);\n        this._indexBuffer.update(this.indicesUint16);\n    }\n\n    /**\n     * Process fill part of Graphics.\n     * @param data\n     */\n    protected processFill(data: GraphicsData): void\n    {\n        if (data.holes.length)\n        {\n            buildPoly.triangulate(data, this);\n        }\n        else\n        {\n            const command = FILL_COMMANDS[data.type];\n\n            command.triangulate(data, this);\n        }\n    }\n\n    /**\n     * Process line part of Graphics.\n     * @param data\n     */\n    protected processLine(data: GraphicsData): void\n    {\n        buildLine(data, this);\n\n        for (let i = 0; i < data.holes.length; i++)\n        {\n            buildLine(data.holes[i], this);\n        }\n    }\n\n    /**\n     * Process the holes data.\n     * @param holes\n     */\n    protected processHoles(holes: Array<GraphicsData>): void\n    {\n        for (let i = 0; i < holes.length; i++)\n        {\n            const hole = holes[i];\n            const command = FILL_COMMANDS[hole.type];\n\n            command.build(hole);\n\n            if (hole.matrix)\n            {\n                this.transformPoints(hole.points, hole.matrix);\n            }\n        }\n    }\n\n    /** Update the local bounds of the object. Expensive to use performance-wise. */\n    protected calculateBounds(): void\n    {\n        const bounds = this._bounds;\n\n        bounds.clear();\n        bounds.addVertexData((this.points as any), 0, this.points.length);\n        bounds.pad(this.boundsPadding, this.boundsPadding);\n    }\n\n    /**\n     * Transform points using matrix.\n     * @param points - Points to transform\n     * @param matrix - Transform matrix\n     */\n    protected transformPoints(points: Array<number>, matrix: Matrix): void\n    {\n        for (let i = 0; i < points.length / 2; i++)\n        {\n            const x = points[(i * 2)];\n            const y = points[(i * 2) + 1];\n\n            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n        }\n    }\n\n    /**\n     * Add colors.\n     * @param colors - List of colors to add to\n     * @param color - Color to add\n     * @param alpha - Alpha to use\n     * @param size - Number of colors to add\n     * @param offset\n     */\n    protected addColors(\n        colors: Array<number>,\n        color: number,\n        alpha: number,\n        size: number,\n        offset = 0): void\n    {\n        // TODO use the premultiply bits Ivan added\n        const rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\n\n        const rgba = utils.premultiplyTint(rgb, alpha);\n\n        colors.length = Math.max(colors.length, offset + size);\n\n        for (let i = 0; i < size; i++)\n        {\n            colors[offset + i] = rgba;\n        }\n    }\n\n    /**\n     * Add texture id that the shader/fragment wants to use.\n     * @param textureIds\n     * @param id\n     * @param size\n     * @param offset\n     */\n    protected addTextureIds(\n        textureIds: Array<number>,\n        id: number,\n        size: number,\n        offset = 0): void\n    {\n        textureIds.length = Math.max(textureIds.length, offset + size);\n\n        for (let i = 0; i < size; i++)\n        {\n            textureIds[offset + i] = id;\n        }\n    }\n\n    /**\n     * Generates the UVs for a shape.\n     * @param verts - Vertices\n     * @param uvs - UVs\n     * @param texture - Reference to Texture\n     * @param start - Index buffer start index.\n     * @param size - The size/length for index buffer.\n     * @param matrix - Optional transform for all points.\n     */\n    protected addUvs(\n        verts: Array<number>,\n        uvs: Array<number>,\n        texture: Texture,\n        start: number,\n        size: number,\n        matrix: Matrix = null): void\n    {\n        let index = 0;\n        const uvsStart = uvs.length;\n        const frame = texture.frame;\n\n        while (index < size)\n        {\n            let x = verts[(start + index) * 2];\n            let y = verts[((start + index) * 2) + 1];\n\n            if (matrix)\n            {\n                const nx = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n\n                y = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n                x = nx;\n            }\n\n            index++;\n\n            uvs.push(x / frame.width, y / frame.height);\n        }\n\n        const baseTexture = texture.baseTexture;\n\n        if (frame.width < baseTexture.width\n            || frame.height < baseTexture.height)\n        {\n            this.adjustUvs(uvs, texture, uvsStart, size);\n        }\n    }\n\n    /**\n     * Modify uvs array according to position of texture region\n     * Does not work with rotated or trimmed textures\n     * @param uvs - array\n     * @param texture - region\n     * @param start - starting index for uvs\n     * @param size - how many points to adjust\n     */\n    protected adjustUvs(uvs: Array<number>, texture: Texture, start: number, size: number): void\n    {\n        const baseTexture = texture.baseTexture;\n        const eps = 1e-6;\n        const finish = start + (size * 2);\n        const frame = texture.frame;\n        const scaleX = frame.width / baseTexture.width;\n        const scaleY = frame.height / baseTexture.height;\n        let offsetX = frame.x / frame.width;\n        let offsetY = frame.y / frame.height;\n        let minX = Math.floor(uvs[start] + eps);\n        let minY = Math.floor(uvs[start + 1] + eps);\n\n        for (let i = start + 2; i < finish; i += 2)\n        {\n            minX = Math.min(minX, Math.floor(uvs[i] + eps));\n            minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n        }\n        offsetX -= minX;\n        offsetY -= minY;\n        for (let i = start; i < finish; i += 2)\n        {\n            uvs[i] = (uvs[i] + offsetX) * scaleX;\n            uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}