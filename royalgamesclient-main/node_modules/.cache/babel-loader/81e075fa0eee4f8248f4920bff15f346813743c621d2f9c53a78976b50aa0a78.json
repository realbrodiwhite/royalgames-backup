{"ast":null,"code":"import { Matrix } from './Matrix.mjs';\nimport { ObservablePoint } from './ObservablePoint.mjs';\nconst _Transform = class {\n  constructor() {\n    this.worldTransform = new Matrix();\n    this.localTransform = new Matrix();\n    this.position = new ObservablePoint(this.onChange, this, 0, 0);\n    this.scale = new ObservablePoint(this.onChange, this, 1, 1);\n    this.pivot = new ObservablePoint(this.onChange, this, 0, 0);\n    this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);\n    this._rotation = 0;\n    this._cx = 1;\n    this._sx = 0;\n    this._cy = 0;\n    this._sy = 1;\n    this._localID = 0;\n    this._currentLocalID = 0;\n    this._worldID = 0;\n    this._parentID = 0;\n  }\n  onChange() {\n    this._localID++;\n  }\n  updateSkew() {\n    this._cx = Math.cos(this._rotation + this.skew.y);\n    this._sx = Math.sin(this._rotation + this.skew.y);\n    this._cy = -Math.sin(this._rotation - this.skew.x);\n    this._sy = Math.cos(this._rotation - this.skew.x);\n    this._localID++;\n  }\n  toString() {\n    return \"[@pixi/math:Transform position=(\".concat(this.position.x, \", \").concat(this.position.y, \") rotation=\").concat(this.rotation, \" scale=(\").concat(this.scale.x, \", \").concat(this.scale.y, \") skew=(\").concat(this.skew.x, \", \").concat(this.skew.y, \") ]\");\n  }\n  updateLocalTransform() {\n    const lt = this.localTransform;\n    if (this._localID !== this._currentLocalID) {\n      lt.a = this._cx * this.scale.x;\n      lt.b = this._sx * this.scale.x;\n      lt.c = this._cy * this.scale.y;\n      lt.d = this._sy * this.scale.y;\n      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);\n      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);\n      this._currentLocalID = this._localID;\n      this._parentID = -1;\n    }\n  }\n  updateTransform(parentTransform) {\n    const lt = this.localTransform;\n    if (this._localID !== this._currentLocalID) {\n      lt.a = this._cx * this.scale.x;\n      lt.b = this._sx * this.scale.x;\n      lt.c = this._cy * this.scale.y;\n      lt.d = this._sy * this.scale.y;\n      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);\n      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);\n      this._currentLocalID = this._localID;\n      this._parentID = -1;\n    }\n    if (this._parentID !== parentTransform._worldID) {\n      const pt = parentTransform.worldTransform;\n      const wt = this.worldTransform;\n      wt.a = lt.a * pt.a + lt.b * pt.c;\n      wt.b = lt.a * pt.b + lt.b * pt.d;\n      wt.c = lt.c * pt.a + lt.d * pt.c;\n      wt.d = lt.c * pt.b + lt.d * pt.d;\n      wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n      wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n      this._parentID = parentTransform._worldID;\n      this._worldID++;\n    }\n  }\n  setFromMatrix(matrix) {\n    matrix.decompose(this);\n    this._localID++;\n  }\n  get rotation() {\n    return this._rotation;\n  }\n  set rotation(value) {\n    if (this._rotation !== value) {\n      this._rotation = value;\n      this.updateSkew();\n    }\n  }\n};\nlet Transform = _Transform;\nTransform.IDENTITY = new _Transform();\nexport { Transform };","map":{"version":3,"mappings":"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","names":["_Transform","constructor","Matrix","position","ObservablePoint","onChange","scale","pivot","skew","updateSkew","_rotation","_cx","_sx","_cy","_sy","_localID","_currentLocalID","_worldID","_parentID","Math","y","x","toString","updateLocalTransform","lt","a","b","c","d","tx","ty","updateTransform","parentTransform","pt","wt","setFromMatrix","matrix","decompose","rotation","value","Transform","IDENTITY"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/math/src/Transform.ts"],"sourcesContent":["import { Matrix } from './Matrix';\nimport { ObservablePoint } from './ObservablePoint';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Transform extends GlobalMixins.Transform {}\n\n/**\n * Transform that takes care about its versions.\n * @memberof PIXI\n */\nexport class Transform\n{\n    /** A default (identity) transform. */\n    public static readonly IDENTITY = new Transform();\n\n    /** The world transformation matrix. */\n    public worldTransform: Matrix;\n\n    /** The local transformation matrix. */\n    public localTransform: Matrix;\n\n    /** The coordinate of the object relative to the local coordinates of the parent. */\n    public position: ObservablePoint;\n\n    /** The scale factor of the object. */\n    public scale: ObservablePoint;\n\n    /** The pivot point of the displayObject that it rotates around. */\n    public pivot: ObservablePoint;\n\n    /** The skew amount, on the x and y axis. */\n    public skew: ObservablePoint;\n\n    /** The locally unique ID of the parent's world transform used to calculate the current world transformation matrix. */\n    public _parentID: number;\n\n    /** The locally unique ID of the world transform. */\n    _worldID: number;\n\n    /** The rotation amount. */\n    protected _rotation: number;\n\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     */\n    protected _cx: number;\n\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     */\n    protected _sx: number;\n\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     */\n    protected _cy: number;\n\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     */\n    protected _sy: number;\n\n    /** The locally unique ID of the local transform. */\n    protected _localID: number;\n\n    /** The locally unique ID of the local transform used to calculate the current local transformation matrix. */\n    protected _currentLocalID: number;\n\n    constructor()\n    {\n        this.worldTransform = new Matrix();\n        this.localTransform = new Matrix();\n        this.position = new ObservablePoint(this.onChange, this, 0, 0);\n        this.scale = new ObservablePoint(this.onChange, this, 1, 1);\n        this.pivot = new ObservablePoint(this.onChange, this, 0, 0);\n        this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);\n\n        this._rotation = 0;\n        this._cx = 1;\n        this._sx = 0;\n        this._cy = 0;\n        this._sy = 1;\n        this._localID = 0;\n        this._currentLocalID = 0;\n\n        this._worldID = 0;\n        this._parentID = 0;\n    }\n\n    /** Called when a value changes. */\n    protected onChange(): void\n    {\n        this._localID++;\n    }\n\n    /** Called when the skew or the rotation changes. */\n    protected updateSkew(): void\n    {\n        this._cx = Math.cos(this._rotation + this.skew.y);\n        this._sx = Math.sin(this._rotation + this.skew.y);\n        this._cy = -Math.sin(this._rotation - this.skew.x); // cos, added PI/2\n        this._sy = Math.cos(this._rotation - this.skew.x); // sin, added PI/2\n\n        this._localID++;\n    }\n\n    // #if _DEBUG\n    toString(): string\n    {\n        return `[@pixi/math:Transform `\n            + `position=(${this.position.x}, ${this.position.y}) `\n            + `rotation=${this.rotation} `\n            + `scale=(${this.scale.x}, ${this.scale.y}) `\n            + `skew=(${this.skew.x}, ${this.skew.y}) `\n            + `]`;\n    }\n    // #endif\n\n    /** Updates the local transformation matrix. */\n    updateLocalTransform(): void\n    {\n        const lt = this.localTransform;\n\n        if (this._localID !== this._currentLocalID)\n        {\n            // get the matrix values of the displayobject based on its transform properties..\n            lt.a = this._cx * this.scale.x;\n            lt.b = this._sx * this.scale.x;\n            lt.c = this._cy * this.scale.y;\n            lt.d = this._sy * this.scale.y;\n\n            lt.tx = this.position.x - ((this.pivot.x * lt.a) + (this.pivot.y * lt.c));\n            lt.ty = this.position.y - ((this.pivot.x * lt.b) + (this.pivot.y * lt.d));\n            this._currentLocalID = this._localID;\n\n            // force an update..\n            this._parentID = -1;\n        }\n    }\n\n    /**\n     * Updates the local and the world transformation matrices.\n     * @param parentTransform - The parent transform\n     */\n    updateTransform(parentTransform: Transform): void\n    {\n        const lt = this.localTransform;\n\n        if (this._localID !== this._currentLocalID)\n        {\n            // get the matrix values of the displayobject based on its transform properties..\n            lt.a = this._cx * this.scale.x;\n            lt.b = this._sx * this.scale.x;\n            lt.c = this._cy * this.scale.y;\n            lt.d = this._sy * this.scale.y;\n\n            lt.tx = this.position.x - ((this.pivot.x * lt.a) + (this.pivot.y * lt.c));\n            lt.ty = this.position.y - ((this.pivot.x * lt.b) + (this.pivot.y * lt.d));\n            this._currentLocalID = this._localID;\n\n            // force an update..\n            this._parentID = -1;\n        }\n\n        if (this._parentID !== parentTransform._worldID)\n        {\n            // concat the parent matrix with the objects transform.\n            const pt = parentTransform.worldTransform;\n            const wt = this.worldTransform;\n\n            wt.a = (lt.a * pt.a) + (lt.b * pt.c);\n            wt.b = (lt.a * pt.b) + (lt.b * pt.d);\n            wt.c = (lt.c * pt.a) + (lt.d * pt.c);\n            wt.d = (lt.c * pt.b) + (lt.d * pt.d);\n            wt.tx = (lt.tx * pt.a) + (lt.ty * pt.c) + pt.tx;\n            wt.ty = (lt.tx * pt.b) + (lt.ty * pt.d) + pt.ty;\n\n            this._parentID = parentTransform._worldID;\n\n            // update the id of the transform..\n            this._worldID++;\n        }\n    }\n\n    /**\n     * Decomposes a matrix and sets the transforms properties based on it.\n     * @param matrix - The matrix to decompose\n     */\n    setFromMatrix(matrix: Matrix): void\n    {\n        matrix.decompose(this);\n        this._localID++;\n    }\n\n    /** The rotation of the object in radians. */\n    get rotation(): number\n    {\n        return this._rotation;\n    }\n\n    set rotation(value: number)\n    {\n        if (this._rotation !== value)\n        {\n            this._rotation = value;\n            this.updateSkew();\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}