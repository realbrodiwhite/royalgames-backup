{"ast":null,"code":"import { ExtensionType, extensions } from '@pixi/core';\nimport { EventBoundary } from './EventBoundary.mjs';\nimport { FederatedPointerEvent } from './FederatedPointerEvent.mjs';\nimport { FederatedWheelEvent } from './FederatedWheelEvent.mjs';\nconst MOUSE_POINTER_ID = 1;\nconst TOUCH_TO_POINTER = {\n  touchstart: \"pointerdown\",\n  touchend: \"pointerup\",\n  touchendoutside: \"pointerupoutside\",\n  touchmove: \"pointermove\",\n  touchcancel: \"pointercancel\"\n};\nclass EventSystem {\n  constructor(renderer) {\n    this.supportsTouchEvents = \"ontouchstart\" in globalThis;\n    this.supportsPointerEvents = !!globalThis.PointerEvent;\n    this.domElement = null;\n    this.resolution = 1;\n    this.renderer = renderer;\n    this.rootBoundary = new EventBoundary(null);\n    this.autoPreventDefault = true;\n    this.eventsAdded = false;\n    this.rootPointerEvent = new FederatedPointerEvent(null);\n    this.rootWheelEvent = new FederatedWheelEvent(null);\n    this.cursorStyles = {\n      default: \"inherit\",\n      pointer: \"pointer\"\n    };\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.onPointerOverOut = this.onPointerOverOut.bind(this);\n    this.onWheel = this.onWheel.bind(this);\n  }\n  init() {\n    const {\n      view,\n      resolution\n    } = this.renderer;\n    this.setTargetElement(view);\n    this.resolution = resolution;\n  }\n  resolutionChange(resolution) {\n    this.resolution = resolution;\n  }\n  destroy() {\n    this.setTargetElement(null);\n    this.renderer = null;\n  }\n  setCursor(mode) {\n    mode = mode || \"default\";\n    let applyStyles = true;\n    if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {\n      applyStyles = false;\n    }\n    if (this.currentCursor === mode) {\n      return;\n    }\n    this.currentCursor = mode;\n    const style = this.cursorStyles[mode];\n    if (style) {\n      switch (typeof style) {\n        case \"string\":\n          if (applyStyles) {\n            this.domElement.style.cursor = style;\n          }\n          break;\n        case \"function\":\n          style(mode);\n          break;\n        case \"object\":\n          if (applyStyles) {\n            Object.assign(this.domElement.style, style);\n          }\n          break;\n      }\n    } else if (applyStyles && typeof mode === \"string\" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      this.domElement.style.cursor = mode;\n    }\n  }\n  onPointerDown(nativeEvent) {\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    if (this.supportsTouchEvents && nativeEvent.pointerType === \"touch\") return;\n    const events = this.normalizeToPointerData(nativeEvent);\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      const cancelable = nativeEvent.cancelable || !(\"cancelable\" in nativeEvent);\n      if (cancelable) {\n        nativeEvent.preventDefault();\n      }\n    }\n    for (let i = 0, j = events.length; i < j; i++) {\n      const nativeEvent2 = events[i];\n      const federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent2);\n      this.rootBoundary.mapEvent(federatedEvent);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  onPointerMove(nativeEvent) {\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    if (this.supportsTouchEvents && nativeEvent.pointerType === \"touch\") return;\n    const normalizedEvents = this.normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  onPointerUp(nativeEvent) {\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    if (this.supportsTouchEvents && nativeEvent.pointerType === \"touch\") return;\n    let target = nativeEvent.target;\n    if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {\n      target = nativeEvent.composedPath()[0];\n    }\n    const outside = target !== this.domElement ? \"outside\" : \"\";\n    const normalizedEvents = this.normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n      event.type += outside;\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  onPointerOverOut(nativeEvent) {\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    if (this.supportsTouchEvents && nativeEvent.pointerType === \"touch\") return;\n    const normalizedEvents = this.normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  onWheel(nativeEvent) {\n    const wheelEvent = this.normalizeWheelEvent(nativeEvent);\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    this.rootBoundary.mapEvent(wheelEvent);\n  }\n  setTargetElement(element) {\n    this.removeEvents();\n    this.domElement = element;\n    this.addEvents();\n  }\n  addEvents() {\n    if (this.eventsAdded || !this.domElement) {\n      return;\n    }\n    const style = this.domElement.style;\n    if (style) {\n      if (globalThis.navigator.msPointerEnabled) {\n        style.msContentZooming = \"none\";\n        style.msTouchAction = \"none\";\n      } else if (this.supportsPointerEvents) {\n        style.touchAction = \"none\";\n      }\n    }\n    if (this.supportsPointerEvents) {\n      globalThis.document.addEventListener(\"pointermove\", this.onPointerMove, true);\n      this.domElement.addEventListener(\"pointerdown\", this.onPointerDown, true);\n      this.domElement.addEventListener(\"pointerleave\", this.onPointerOverOut, true);\n      this.domElement.addEventListener(\"pointerover\", this.onPointerOverOut, true);\n      globalThis.addEventListener(\"pointerup\", this.onPointerUp, true);\n    } else {\n      globalThis.document.addEventListener(\"mousemove\", this.onPointerMove, true);\n      this.domElement.addEventListener(\"mousedown\", this.onPointerDown, true);\n      this.domElement.addEventListener(\"mouseout\", this.onPointerOverOut, true);\n      this.domElement.addEventListener(\"mouseover\", this.onPointerOverOut, true);\n      globalThis.addEventListener(\"mouseup\", this.onPointerUp, true);\n    }\n    if (this.supportsTouchEvents) {\n      this.domElement.addEventListener(\"touchstart\", this.onPointerDown, true);\n      this.domElement.addEventListener(\"touchend\", this.onPointerUp, true);\n      this.domElement.addEventListener(\"touchmove\", this.onPointerMove, true);\n    }\n    this.domElement.addEventListener(\"wheel\", this.onWheel, {\n      passive: true,\n      capture: true\n    });\n    this.eventsAdded = true;\n  }\n  removeEvents() {\n    if (!this.eventsAdded || !this.domElement) {\n      return;\n    }\n    const style = this.domElement.style;\n    if (globalThis.navigator.msPointerEnabled) {\n      style.msContentZooming = \"\";\n      style.msTouchAction = \"\";\n    } else if (this.supportsPointerEvents) {\n      style.touchAction = \"\";\n    }\n    if (this.supportsPointerEvents) {\n      globalThis.document.removeEventListener(\"pointermove\", this.onPointerMove, true);\n      this.domElement.removeEventListener(\"pointerdown\", this.onPointerDown, true);\n      this.domElement.removeEventListener(\"pointerleave\", this.onPointerOverOut, true);\n      this.domElement.removeEventListener(\"pointerover\", this.onPointerOverOut, true);\n      globalThis.removeEventListener(\"pointerup\", this.onPointerUp, true);\n    } else {\n      globalThis.document.removeEventListener(\"mousemove\", this.onPointerMove, true);\n      this.domElement.removeEventListener(\"mousedown\", this.onPointerDown, true);\n      this.domElement.removeEventListener(\"mouseout\", this.onPointerOverOut, true);\n      this.domElement.removeEventListener(\"mouseover\", this.onPointerOverOut, true);\n      globalThis.removeEventListener(\"mouseup\", this.onPointerUp, true);\n    }\n    if (this.supportsTouchEvents) {\n      this.domElement.removeEventListener(\"touchstart\", this.onPointerDown, true);\n      this.domElement.removeEventListener(\"touchend\", this.onPointerUp, true);\n      this.domElement.removeEventListener(\"touchmove\", this.onPointerMove, true);\n    }\n    this.domElement.removeEventListener(\"wheel\", this.onWheel, true);\n    this.domElement = null;\n    this.eventsAdded = false;\n  }\n  mapPositionToPoint(point, x, y) {\n    let rect;\n    if (!this.domElement.parentElement) {\n      rect = {\n        x: 0,\n        y: 0,\n        width: this.domElement.width,\n        height: this.domElement.height,\n        left: 0,\n        top: 0\n      };\n    } else {\n      rect = this.domElement.getBoundingClientRect();\n    }\n    const resolutionMultiplier = 1 / this.resolution;\n    point.x = (x - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;\n    point.y = (y - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;\n  }\n  normalizeToPointerData(event) {\n    const normalizedEvents = [];\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n        if (typeof touch.button === \"undefined\") touch.button = 0;\n        if (typeof touch.buttons === \"undefined\") touch.buttons = 1;\n        if (typeof touch.isPrimary === \"undefined\") {\n          touch.isPrimary = event.touches.length === 1 && event.type === \"touchstart\";\n        }\n        if (typeof touch.width === \"undefined\") touch.width = touch.radiusX || 1;\n        if (typeof touch.height === \"undefined\") touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === \"undefined\") touch.tiltX = 0;\n        if (typeof touch.tiltY === \"undefined\") touch.tiltY = 0;\n        if (typeof touch.pointerType === \"undefined\") touch.pointerType = \"touch\";\n        if (typeof touch.pointerId === \"undefined\") touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === \"undefined\") touch.pressure = touch.force || 0.5;\n        if (typeof touch.twist === \"undefined\") touch.twist = 0;\n        if (typeof touch.tangentialPressure === \"undefined\") touch.tangentialPressure = 0;\n        if (typeof touch.layerX === \"undefined\") touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === \"undefined\") touch.layerY = touch.offsetY = touch.clientY;\n        touch.isNormalized = true;\n        touch.type = event.type;\n        normalizedEvents.push(touch);\n      }\n    } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {\n      const tempEvent = event;\n      if (typeof tempEvent.isPrimary === \"undefined\") tempEvent.isPrimary = true;\n      if (typeof tempEvent.width === \"undefined\") tempEvent.width = 1;\n      if (typeof tempEvent.height === \"undefined\") tempEvent.height = 1;\n      if (typeof tempEvent.tiltX === \"undefined\") tempEvent.tiltX = 0;\n      if (typeof tempEvent.tiltY === \"undefined\") tempEvent.tiltY = 0;\n      if (typeof tempEvent.pointerType === \"undefined\") tempEvent.pointerType = \"mouse\";\n      if (typeof tempEvent.pointerId === \"undefined\") tempEvent.pointerId = MOUSE_POINTER_ID;\n      if (typeof tempEvent.pressure === \"undefined\") tempEvent.pressure = 0.5;\n      if (typeof tempEvent.twist === \"undefined\") tempEvent.twist = 0;\n      if (typeof tempEvent.tangentialPressure === \"undefined\") tempEvent.tangentialPressure = 0;\n      tempEvent.isNormalized = true;\n      normalizedEvents.push(tempEvent);\n    } else {\n      normalizedEvents.push(event);\n    }\n    return normalizedEvents;\n  }\n  normalizeWheelEvent(nativeEvent) {\n    const event = this.rootWheelEvent;\n    this.transferMouseData(event, nativeEvent);\n    event.deltaX = nativeEvent.deltaX;\n    event.deltaY = nativeEvent.deltaY;\n    event.deltaZ = nativeEvent.deltaZ;\n    event.deltaMode = nativeEvent.deltaMode;\n    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n    event.global.copyFrom(event.screen);\n    event.offset.copyFrom(event.screen);\n    event.nativeEvent = nativeEvent;\n    event.type = nativeEvent.type;\n    return event;\n  }\n  bootstrapEvent(event, nativeEvent) {\n    event.originalEvent = null;\n    event.nativeEvent = nativeEvent;\n    event.pointerId = nativeEvent.pointerId;\n    event.width = nativeEvent.width;\n    event.height = nativeEvent.height;\n    event.isPrimary = nativeEvent.isPrimary;\n    event.pointerType = nativeEvent.pointerType;\n    event.pressure = nativeEvent.pressure;\n    event.tangentialPressure = nativeEvent.tangentialPressure;\n    event.tiltX = nativeEvent.tiltX;\n    event.tiltY = nativeEvent.tiltY;\n    event.twist = nativeEvent.twist;\n    this.transferMouseData(event, nativeEvent);\n    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n    event.global.copyFrom(event.screen);\n    event.offset.copyFrom(event.screen);\n    event.isTrusted = nativeEvent.isTrusted;\n    if (event.type === \"pointerleave\") {\n      event.type = \"pointerout\";\n    }\n    if (event.type.startsWith(\"mouse\")) {\n      event.type = event.type.replace(\"mouse\", \"pointer\");\n    }\n    if (event.type.startsWith(\"touch\")) {\n      event.type = TOUCH_TO_POINTER[event.type] || event.type;\n    }\n    return event;\n  }\n  transferMouseData(event, nativeEvent) {\n    event.isTrusted = nativeEvent.isTrusted;\n    event.srcElement = nativeEvent.srcElement;\n    event.timeStamp = performance.now();\n    event.type = nativeEvent.type;\n    event.altKey = nativeEvent.altKey;\n    event.button = nativeEvent.button;\n    event.buttons = nativeEvent.buttons;\n    event.client.x = nativeEvent.clientX;\n    event.client.y = nativeEvent.clientY;\n    event.ctrlKey = nativeEvent.ctrlKey;\n    event.metaKey = nativeEvent.metaKey;\n    event.movement.x = nativeEvent.movementX;\n    event.movement.y = nativeEvent.movementY;\n    event.page.x = nativeEvent.pageX;\n    event.page.y = nativeEvent.pageY;\n    event.relatedTarget = null;\n    event.shiftKey = nativeEvent.shiftKey;\n  }\n}\nEventSystem.extension = {\n  name: \"events\",\n  type: [ExtensionType.RendererSystem, ExtensionType.CanvasRendererSystem]\n};\nextensions.add(EventSystem);\nexport { EventSystem };","map":{"version":3,"mappings":"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","names":["MOUSE_POINTER_ID","TOUCH_TO_POINTER","touchstart","touchend","touchendoutside","touchmove","touchcancel","EventSystem","constructor","renderer","supportsTouchEvents","globalThis","domElement","resolution","EventBoundary","autoPreventDefault","eventsAdded","FederatedPointerEvent","FederatedWheelEvent","cursorStyles","default","pointer","onPointerDown","onPointerMove","onPointerUp","onPointerOverOut","onWheel","init","view","setTargetElement","resolutionChange","destroy","setCursor","mode","applyStyles","OffscreenCanvas","currentCursor","style","cursor","Object","assign","hasOwnProperty","nativeEvent","rootTarget","pointerType","events","isNormalized","cancelable","preventDefault","i","length","j","nativeEvent2","federatedEvent","bootstrapEvent","rootPointerEvent","mapEvent","normalizedEvents","event","target","composedPath","outside","type","wheelEvent","element","removeEvents","addEvents","navigator","msPointerEnabled","msContentZooming","msTouchAction","supportsPointerEvents","touchAction","document","addEventListener","passive","capture","removeEventListener","mapPositionToPoint","point","y","parentElement","rect","x","width","height","left","top","getBoundingClientRect","normalizeToPointerData","TouchEvent","li","changedTouches","touch","button","buttons","isPrimary","radiusX","radiusY","tiltX","tiltY","pointerId","identifier","pressure","force","twist","tangentialPressure","layerX","layerY","push","PointerEvent","tempEvent","normalizeWheelEvent","deltaX","deltaY","deltaZ","deltaMode","clientY","copyFrom","screen","originalEvent","isTrusted","startsWith","transferMouseData","srcElement","performance","now","altKey","ctrlKey","metaKey","relatedTarget","shiftKey","extension","name","ExtensionType","extensions","add"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/events/src/EventSystem.ts"],"sourcesContent":["import { extensions, ExtensionType } from '@pixi/core';\nimport { EventBoundary } from './EventBoundary';\nimport { FederatedPointerEvent } from './FederatedPointerEvent';\nimport { FederatedWheelEvent } from './FederatedWheelEvent';\n\nimport type { ExtensionMetadata, ICanvas, IPointData, IRenderableObject } from '@pixi/core';\nimport type { DisplayObject } from '@pixi/display';\nimport type { FederatedMouseEvent } from './FederatedMouseEvent';\n\nconst MOUSE_POINTER_ID = 1;\nconst TOUCH_TO_POINTER: Record<string, string> = {\n    touchstart: 'pointerdown',\n    touchend: 'pointerup',\n    touchendoutside: 'pointerupoutside',\n    touchmove: 'pointermove',\n    touchcancel: 'pointercancel',\n};\n\ninterface Renderer\n{\n    lastObjectRendered: IRenderableObject;\n    view: ICanvas;\n    resolution: number;\n    plugins: Record<string, any>;\n}\n\n/**\n * The system for handling UI events.\n * @memberof PIXI\n */\nexport class EventSystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'events',\n        type: [\n            ExtensionType.RendererSystem,\n            ExtensionType.CanvasRendererSystem\n        ],\n    };\n\n    /**\n     * The {@link PIXI.EventBoundary} for the stage.\n     *\n     * The {@link PIXI.EventBoundary#rootTarget rootTarget} of this root boundary is automatically set to\n     * the last rendered object before any event processing is initiated. This means the main scene\n     * needs to be rendered atleast once before UI events will start propagating.\n     *\n     * The root boundary should only be changed during initialization. Otherwise, any state held by the\n     * event boundary may be lost (like hovered & pressed DisplayObjects).\n     */\n    public readonly rootBoundary: EventBoundary;\n\n    /** Does the device support touch events https://www.w3.org/TR/touch-events/ */\n    public readonly supportsTouchEvents = 'ontouchstart' in globalThis;\n\n    /** Does the device support pointer events https://www.w3.org/Submission/pointer-events/ */\n    public readonly supportsPointerEvents = !!globalThis.PointerEvent;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     * @default true\n     */\n    public autoPreventDefault: boolean;\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for {@code domElement},\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     */\n    public cursorStyles: Record<string, string | ((mode: string) => void) | CSSStyleDeclaration>;\n\n    /**\n     * The DOM element to which the root event listeners are bound. This is automatically set to\n     * the renderer's {@link PIXI.Renderer#view view}.\n     */\n    public domElement: HTMLElement = null;\n\n    /** The resolution used to convert between the DOM client space into world space. */\n    public resolution = 1;\n\n    /** The renderer managing this {@link EventSystem}. */\n    public renderer: Renderer;\n\n    private currentCursor: string;\n    private rootPointerEvent: FederatedPointerEvent;\n    private rootWheelEvent: FederatedWheelEvent;\n    private eventsAdded: boolean;\n\n    /**\n     * @param {PIXI.Renderer} renderer\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n        this.rootBoundary = new EventBoundary(null);\n\n        this.autoPreventDefault = true;\n        this.eventsAdded = false;\n\n        this.rootPointerEvent = new FederatedPointerEvent(null);\n        this.rootWheelEvent = new FederatedWheelEvent(null);\n\n        this.cursorStyles = {\n            default: 'inherit',\n            pointer: 'pointer',\n        };\n\n        this.onPointerDown = this.onPointerDown.bind(this);\n        this.onPointerMove = this.onPointerMove.bind(this);\n        this.onPointerUp = this.onPointerUp.bind(this);\n        this.onPointerOverOut = this.onPointerOverOut.bind(this);\n        this.onWheel = this.onWheel.bind(this);\n    }\n\n    /**\n     * Runner init called, view is available at this point.\n     * @ignore\n     */\n    init(): void\n    {\n        const { view, resolution } = this.renderer;\n\n        this.setTargetElement(view as HTMLCanvasElement);\n        this.resolution = resolution;\n    }\n\n    /**\n     * Handle changing resolution.\n     * @ignore\n     */\n    resolutionChange(resolution: number): void\n    {\n        this.resolution = resolution;\n    }\n\n    /** Destroys all event listeners and detaches the renderer. */\n    destroy(): void\n    {\n        this.setTargetElement(null);\n        this.renderer = null;\n    }\n\n    /**\n     * Sets the current cursor mode, handling any callbacks or CSS style changes.\n     * @param mode - cursor mode, a key from the cursorStyles dictionary\n     */\n    public setCursor(mode: string): void\n    {\n        mode = mode || 'default';\n        let applyStyles = true;\n\n        // offscreen canvas does not support setting styles, but cursor modes can be functions,\n        // in order to handle pixi rendered cursors, so we can't bail\n        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas)\n        {\n            applyStyles = false;\n        }\n        // if the mode didn't actually change, bail early\n        if (this.currentCursor === mode)\n        {\n            return;\n        }\n        this.currentCursor = mode;\n        const style = this.cursorStyles[mode];\n\n        // only do things if there is a cursor style for it\n        if (style)\n        {\n            switch (typeof style)\n            {\n                case 'string':\n                    // string styles are handled as cursor CSS\n                    if (applyStyles)\n                    {\n                        this.domElement.style.cursor = style;\n                    }\n                    break;\n                case 'function':\n                    // functions are just called, and passed the cursor mode\n                    style(mode);\n                    break;\n                case 'object':\n                    // if it is an object, assume that it is a dictionary of CSS styles,\n                    // apply it to the interactionDOMElement\n                    if (applyStyles)\n                    {\n                        Object.assign(this.domElement.style, style);\n                    }\n                    break;\n            }\n        }\n        else if (applyStyles && typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode))\n        {\n            // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n            // for the mode, then assume that the dev wants it to be CSS for the cursor.\n            this.domElement.style.cursor = mode;\n        }\n    }\n\n    /**\n     * Event handler for pointer down events on {@link PIXI.EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private onPointerDown(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered as DisplayObject;\n\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && (nativeEvent as PointerEvent).pointerType === 'touch') return;\n\n        const events = this.normalizeToPointerData(nativeEvent);\n\n        /*\n         * No need to prevent default on natural pointer events, as there are no side effects\n         * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n         * so still need to be prevented.\n         */\n\n        // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n        if (this.autoPreventDefault && (events[0] as any).isNormalized)\n        {\n            const cancelable = nativeEvent.cancelable || !('cancelable' in nativeEvent);\n\n            if (cancelable)\n            {\n                nativeEvent.preventDefault();\n            }\n        }\n\n        for (let i = 0, j = events.length; i < j; i++)\n        {\n            const nativeEvent = events[i];\n            const federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent);\n\n            this.rootBoundary.mapEvent(federatedEvent);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer move events on on {@link PIXI.EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch events.\n     */\n    private onPointerMove(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered as DisplayObject;\n\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && (nativeEvent as PointerEvent).pointerType === 'touch') return;\n\n        const normalizedEvents = this.normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer up events on {@link PIXI.EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private onPointerUp(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered as DisplayObject;\n\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && (nativeEvent as PointerEvent).pointerType === 'touch') return;\n\n        let target = nativeEvent.target;\n\n        // if in shadow DOM use composedPath to access target\n        if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0)\n        {\n            target = nativeEvent.composedPath()[0];\n        }\n\n        const outside = target !== this.domElement ? 'outside' : '';\n        const normalizedEvents = this.normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n\n            event.type += outside;\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer over & out events on {@link PIXI.EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private onPointerOverOut(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered as DisplayObject;\n\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && (nativeEvent as PointerEvent).pointerType === 'touch') return;\n\n        const normalizedEvents = this.normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.\n     * @param nativeEvent - The native wheel event.\n     */\n    protected onWheel(nativeEvent: WheelEvent): void\n    {\n        const wheelEvent = this.normalizeWheelEvent(nativeEvent);\n\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered as DisplayObject;\n        this.rootBoundary.mapEvent(wheelEvent);\n    }\n\n    /**\n     * Sets the {@link PIXI.EventSystem#domElement domElement} and binds event listeners.\n     *\n     * To deregister the current DOM element without setting a new one, pass {@code null}.\n     * @param element - The new DOM element.\n     */\n    public setTargetElement(element: HTMLElement): void\n    {\n        this.removeEvents();\n        this.domElement = element;\n        this.addEvents();\n    }\n\n    /** Register event listeners on {@link PIXI.Renderer#domElement this.domElement}. */\n    private addEvents(): void\n    {\n        if (this.eventsAdded || !this.domElement)\n        {\n            return;\n        }\n\n        const style = this.domElement.style as CrossCSSStyleDeclaration;\n\n        if (style)\n        {\n            if ((globalThis.navigator as any).msPointerEnabled)\n            {\n                style.msContentZooming = 'none';\n                style.msTouchAction = 'none';\n            }\n            else if (this.supportsPointerEvents)\n            {\n                style.touchAction = 'none';\n            }\n        }\n\n        /*\n         * These events are added first, so that if pointer events are normalized, they are fired\n         * in the same order as non-normalized events. ie. pointer event 1st, mouse / touch 2nd\n         */\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.addEventListener('pointermove', this.onPointerMove, true);\n            this.domElement.addEventListener('pointerdown', this.onPointerDown, true);\n            // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n            // we already handle those, so for the purposes of what we do in onPointerOut, we only\n            // care about the pointerleave event\n            this.domElement.addEventListener('pointerleave', this.onPointerOverOut, true);\n            this.domElement.addEventListener('pointerover', this.onPointerOverOut, true);\n            // globalThis.addEventListener('pointercancel', this.onPointerCancel, true);\n            globalThis.addEventListener('pointerup', this.onPointerUp, true);\n        }\n        else\n        {\n            globalThis.document.addEventListener('mousemove', this.onPointerMove, true);\n            this.domElement.addEventListener('mousedown', this.onPointerDown, true);\n            this.domElement.addEventListener('mouseout', this.onPointerOverOut, true);\n            this.domElement.addEventListener('mouseover', this.onPointerOverOut, true);\n            globalThis.addEventListener('mouseup', this.onPointerUp, true);\n        }\n\n        // Always look directly for touch events so that we can provide original data\n        // In a future version we should change this to being just a fallback and rely solely on\n        // PointerEvents whenever available\n        if (this.supportsTouchEvents)\n        {\n            this.domElement.addEventListener('touchstart', this.onPointerDown, true);\n            // this.domElement.addEventListener('touchcancel', this.onPointerCancel, true);\n            this.domElement.addEventListener('touchend', this.onPointerUp, true);\n            this.domElement.addEventListener('touchmove', this.onPointerMove, true);\n        }\n\n        this.domElement.addEventListener('wheel', this.onWheel, {\n            passive: true,\n            capture: true,\n        });\n\n        this.eventsAdded = true;\n    }\n\n    /** Unregister event listeners on {@link PIXI.EventSystem#domElement this.domElement}. */\n    private removeEvents(): void\n    {\n        if (!this.eventsAdded || !this.domElement)\n        {\n            return;\n        }\n\n        const style = this.domElement.style as CrossCSSStyleDeclaration;\n\n        if ((globalThis.navigator as any).msPointerEnabled)\n        {\n            style.msContentZooming = '';\n            style.msTouchAction = '';\n        }\n        else if (this.supportsPointerEvents)\n        {\n            style.touchAction = '';\n        }\n\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.removeEventListener('pointermove', this.onPointerMove, true);\n            this.domElement.removeEventListener('pointerdown', this.onPointerDown, true);\n            this.domElement.removeEventListener('pointerleave', this.onPointerOverOut, true);\n            this.domElement.removeEventListener('pointerover', this.onPointerOverOut, true);\n            // globalThis.removeEventListener('pointercancel', this.onPointerCancel, true);\n            globalThis.removeEventListener('pointerup', this.onPointerUp, true);\n        }\n        else\n        {\n            globalThis.document.removeEventListener('mousemove', this.onPointerMove, true);\n            this.domElement.removeEventListener('mousedown', this.onPointerDown, true);\n            this.domElement.removeEventListener('mouseout', this.onPointerOverOut, true);\n            this.domElement.removeEventListener('mouseover', this.onPointerOverOut, true);\n            globalThis.removeEventListener('mouseup', this.onPointerUp, true);\n        }\n\n        if (this.supportsTouchEvents)\n        {\n            this.domElement.removeEventListener('touchstart', this.onPointerDown, true);\n            // this.domElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n            this.domElement.removeEventListener('touchend', this.onPointerUp, true);\n            this.domElement.removeEventListener('touchmove', this.onPointerMove, true);\n        }\n\n        this.domElement.removeEventListener('wheel', this.onWheel, true);\n\n        this.domElement = null;\n        this.eventsAdded = false;\n    }\n\n    /**\n     * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The\n     * resulting value is stored in the point. This takes into account the fact that the DOM\n     * element could be scaled and positioned anywhere on the screen.\n     * @param  {PIXI.IPointData} point - the point that the result will be stored in\n     * @param  {number} x - the x coord of the position to map\n     * @param  {number} y - the y coord of the position to map\n     */\n    public mapPositionToPoint(point: IPointData, x: number, y: number): void\n    {\n        let rect;\n\n        // IE 11 fix\n        if (!this.domElement.parentElement)\n        {\n            rect = {\n                x: 0,\n                y: 0,\n                width: (this.domElement as any).width,\n                height: (this.domElement as any).height,\n                left: 0,\n                top: 0\n            };\n        }\n        else\n        {\n            rect = this.domElement.getBoundingClientRect();\n        }\n\n        const resolutionMultiplier = 1.0 / this.resolution;\n\n        point.x = ((x - rect.left) * ((this.domElement as any).width / rect.width)) * resolutionMultiplier;\n        point.y = ((y - rect.top) * ((this.domElement as any).height / rect.height)) * resolutionMultiplier;\n    }\n\n    /**\n     * Ensures that the original event object contains all data that a regular pointer event would have\n     * @param event - The original event data from a touch or mouse event\n     * @returns An array containing a single normalized pointer event, in the case of a pointer\n     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n     */\n    private normalizeToPointerData(event: TouchEvent | MouseEvent | PointerEvent): PointerEvent[]\n    {\n        const normalizedEvents = [];\n\n        if (this.supportsTouchEvents && event instanceof TouchEvent)\n        {\n            for (let i = 0, li = event.changedTouches.length; i < li; i++)\n            {\n                const touch = event.changedTouches[i] as PixiTouch;\n\n                if (typeof touch.button === 'undefined') touch.button = 0;\n                if (typeof touch.buttons === 'undefined') touch.buttons = 1;\n                if (typeof touch.isPrimary === 'undefined')\n                {\n                    touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n                }\n                if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n                if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n                if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n                if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n                if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n                if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n                if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n                if (typeof touch.twist === 'undefined') touch.twist = 0;\n                if (typeof touch.tangentialPressure === 'undefined') touch.tangentialPressure = 0;\n                // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n                // support, and the fill ins are not quite the same\n                // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n                // left is not 0,0 on the page\n                if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n                if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n                // mark the touch as normalized, just so that we know we did it\n                touch.isNormalized = true;\n                touch.type = event.type;\n\n                normalizedEvents.push(touch);\n            }\n        }\n        // apparently PointerEvent subclasses MouseEvent, so yay\n        else if (!globalThis.MouseEvent\n            || (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))))\n        {\n            const tempEvent = event as PixiPointerEvent;\n\n            if (typeof tempEvent.isPrimary === 'undefined') tempEvent.isPrimary = true;\n            if (typeof tempEvent.width === 'undefined') tempEvent.width = 1;\n            if (typeof tempEvent.height === 'undefined') tempEvent.height = 1;\n            if (typeof tempEvent.tiltX === 'undefined') tempEvent.tiltX = 0;\n            if (typeof tempEvent.tiltY === 'undefined') tempEvent.tiltY = 0;\n            if (typeof tempEvent.pointerType === 'undefined') tempEvent.pointerType = 'mouse';\n            if (typeof tempEvent.pointerId === 'undefined') tempEvent.pointerId = MOUSE_POINTER_ID;\n            if (typeof tempEvent.pressure === 'undefined') tempEvent.pressure = 0.5;\n            if (typeof tempEvent.twist === 'undefined') tempEvent.twist = 0;\n            if (typeof tempEvent.tangentialPressure === 'undefined') tempEvent.tangentialPressure = 0;\n\n            // mark the mouse event as normalized, just so that we know we did it\n            tempEvent.isNormalized = true;\n\n            normalizedEvents.push(tempEvent);\n        }\n        else\n        {\n            normalizedEvents.push(event);\n        }\n\n        return normalizedEvents as PointerEvent[];\n    }\n\n    /**\n     * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.\n     *\n     * The returned {@link PIXI.FederatedWheelEvent} is a shared instance. It will not persist across\n     * multiple native wheel events.\n     * @param nativeEvent - The native wheel event that occurred on the canvas.\n     * @returns A federated wheel event.\n     */\n    protected normalizeWheelEvent(nativeEvent: WheelEvent): FederatedWheelEvent\n    {\n        const event = this.rootWheelEvent;\n\n        this.transferMouseData(event, nativeEvent);\n\n        // When WheelEvent is triggered by scrolling with mouse wheel, reading WheelEvent.deltaMode\n        // before deltaX/deltaY/deltaZ on Firefox will result in WheelEvent.DOM_DELTA_LINE (1),\n        // while reading WheelEvent.deltaMode after deltaX/deltaY/deltaZ on Firefox or reading\n        // in any order on other browsers will result in WheelEvent.DOM_DELTA_PIXEL (0).\n        // Therefore, we need to read WheelEvent.deltaMode after deltaX/deltaY/deltaZ in order to\n        // make its behavior more consistent across browsers.\n        // @see https://github.com/pixijs/pixijs/issues/8970\n        event.deltaX = nativeEvent.deltaX;\n        event.deltaY = nativeEvent.deltaY;\n        event.deltaZ = nativeEvent.deltaZ;\n        event.deltaMode = nativeEvent.deltaMode;\n\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);\n        event.offset.copyFrom(event.screen);\n\n        event.nativeEvent = nativeEvent;\n        event.type = nativeEvent.type;\n\n        return event;\n    }\n\n    /**\n     * Normalizes the {@code nativeEvent} into a federateed {@code FederatedPointerEvent}.\n     * @param event\n     * @param nativeEvent\n     */\n    private bootstrapEvent(event: FederatedPointerEvent, nativeEvent: PointerEvent): FederatedPointerEvent\n    {\n        event.originalEvent = null;\n        event.nativeEvent = nativeEvent;\n\n        event.pointerId = nativeEvent.pointerId;\n        event.width = nativeEvent.width;\n        event.height = nativeEvent.height;\n        event.isPrimary = nativeEvent.isPrimary;\n        event.pointerType = nativeEvent.pointerType;\n        event.pressure = nativeEvent.pressure;\n        event.tangentialPressure = nativeEvent.tangentialPressure;\n        event.tiltX = nativeEvent.tiltX;\n        event.tiltY = nativeEvent.tiltY;\n        event.twist = nativeEvent.twist;\n        this.transferMouseData(event, nativeEvent);\n\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);// global = screen for top-level\n        event.offset.copyFrom(event.screen);// EventBoundary recalculates using its rootTarget\n\n        event.isTrusted = nativeEvent.isTrusted;\n        if (event.type === 'pointerleave')\n        {\n            event.type = 'pointerout';\n        }\n        if (event.type.startsWith('mouse'))\n        {\n            event.type = event.type.replace('mouse', 'pointer');\n        }\n        if (event.type.startsWith('touch'))\n        {\n            event.type = TOUCH_TO_POINTER[event.type] || event.type;\n        }\n\n        return event;\n    }\n\n    /**\n     * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.\n     * @param event\n     * @param nativeEvent\n     */\n    private transferMouseData(event: FederatedMouseEvent, nativeEvent: MouseEvent): void\n    {\n        event.isTrusted = nativeEvent.isTrusted;\n        event.srcElement = nativeEvent.srcElement;\n        event.timeStamp = performance.now();\n        event.type = nativeEvent.type;\n\n        event.altKey = nativeEvent.altKey;\n        event.button = nativeEvent.button;\n        event.buttons = nativeEvent.buttons;\n        event.client.x = nativeEvent.clientX;\n        event.client.y = nativeEvent.clientY;\n        event.ctrlKey = nativeEvent.ctrlKey;\n        event.metaKey = nativeEvent.metaKey;\n        event.movement.x = nativeEvent.movementX;\n        event.movement.y = nativeEvent.movementY;\n        event.page.x = nativeEvent.pageX;\n        event.page.y = nativeEvent.pageY;\n        event.relatedTarget = null;\n        event.shiftKey = nativeEvent.shiftKey;\n    }\n}\n\ninterface CrossCSSStyleDeclaration extends CSSStyleDeclaration\n{\n    msContentZooming: string;\n    msTouchAction: string;\n}\n\ninterface PixiPointerEvent extends PointerEvent\n{\n    isPrimary: boolean;\n    width: number;\n    height: number;\n    tiltX: number;\n    tiltY: number;\n    pointerType: string;\n    pointerId: number;\n    pressure: number;\n    twist: number;\n    tangentialPressure: number;\n    isNormalized: boolean;\n    type: string;\n}\n\ninterface PixiTouch extends Touch\n{\n    button: number;\n    buttons: number;\n    isPrimary: boolean;\n    width: number;\n    height: number;\n    tiltX: number;\n    tiltY: number;\n    pointerType: string;\n    pointerId: number;\n    pressure: number;\n    twist: number;\n    tangentialPressure: number;\n    layerX: number;\n    layerY: number;\n    offsetX: number;\n    offsetY: number;\n    isNormalized: boolean;\n    type: string;\n}\n\nextensions.add(EventSystem);\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}