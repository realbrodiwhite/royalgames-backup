{"ast":null,"code":"import { ExtensionType, extensions } from '@pixi/extensions';\nimport { GLBuffer } from './GLBuffer.mjs';\nclass BufferSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.managedBuffers = {};\n    this.boundBufferBases = {};\n  }\n  destroy() {\n    this.renderer = null;\n  }\n  contextChange() {\n    this.disposeAll(true);\n    this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n  }\n  bind(buffer) {\n    const {\n      gl,\n      CONTEXT_UID\n    } = this;\n    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n    gl.bindBuffer(buffer.type, glBuffer.buffer);\n  }\n  unbind(type) {\n    const {\n      gl\n    } = this;\n    gl.bindBuffer(type, null);\n  }\n  bindBufferBase(buffer, index) {\n    const {\n      gl,\n      CONTEXT_UID\n    } = this;\n    if (this.boundBufferBases[index] !== buffer) {\n      const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n      this.boundBufferBases[index] = buffer;\n      gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n    }\n  }\n  bindBufferRange(buffer, index, offset) {\n    const {\n      gl,\n      CONTEXT_UID\n    } = this;\n    offset = offset || 0;\n    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);\n  }\n  update(buffer) {\n    const {\n      gl,\n      CONTEXT_UID\n    } = this;\n    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n    if (buffer._updateID === glBuffer.updateID) {\n      return;\n    }\n    glBuffer.updateID = buffer._updateID;\n    gl.bindBuffer(buffer.type, glBuffer.buffer);\n    if (glBuffer.byteLength >= buffer.data.byteLength) {\n      gl.bufferSubData(buffer.type, 0, buffer.data);\n    } else {\n      const drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n      glBuffer.byteLength = buffer.data.byteLength;\n      gl.bufferData(buffer.type, buffer.data, drawType);\n    }\n  }\n  dispose(buffer, contextLost) {\n    if (!this.managedBuffers[buffer.id]) {\n      return;\n    }\n    delete this.managedBuffers[buffer.id];\n    const glBuffer = buffer._glBuffers[this.CONTEXT_UID];\n    const gl = this.gl;\n    buffer.disposeRunner.remove(this);\n    if (!glBuffer) {\n      return;\n    }\n    if (!contextLost) {\n      gl.deleteBuffer(glBuffer.buffer);\n    }\n    delete buffer._glBuffers[this.CONTEXT_UID];\n  }\n  disposeAll(contextLost) {\n    const all = Object.keys(this.managedBuffers);\n    for (let i = 0; i < all.length; i++) {\n      this.dispose(this.managedBuffers[all[i]], contextLost);\n    }\n  }\n  createGLBuffer(buffer) {\n    const {\n      CONTEXT_UID,\n      gl\n    } = this;\n    buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());\n    this.managedBuffers[buffer.id] = buffer;\n    buffer.disposeRunner.add(this);\n    return buffer._glBuffers[CONTEXT_UID];\n  }\n}\nBufferSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"buffer\"\n};\nextensions.add(BufferSystem);\nexport { BufferSystem };","map":{"version":3,"mappings":";;AA2BO,MAAMA,YACb;EAqBIC,YAAYC,QACZ;IACI,KAAKA,QAAW;IAChB,KAAKC,iBAAiB,EAAC;IACvB,KAAKC,mBAAmB,EAAC;EAAA;EAM7BC,OACAA;IACI,KAAKH,QAAW;EAAA;EAIpBI,aACAA;IACI,KAAKC,WAAW,IAAI;IAEf,UAAK,KAAKL,QAAS;IAGnB,mBAAc,KAAKA,QAAS;EAAA;EAOrCM,KAAKC,MACL;IACU;MAAEC;MAAIC;IAAgB;IAE5B,MAAMC,WAAWH,MAAO,YAAWE,WAAgB,UAAKE,eAAeJ,MAAM;IAE7EC,GAAGI,UAAW,QAAOC,IAAM,WAASN,MAAM;EAAA;EAG9CO,OAAOD,IACP;IACI,MAAM;MAAEL;IAAO;IAEZA,cAAWK,MAAM,IAAI;EAAA;EAU5BE,eAAeR,QAAgBS,KAC/B;IACU;MAAER;MAAIC;IAAgB;IAExB,SAAKP,gBAAiB,YAAWK,MACrC;MACI,MAAMG,WAAWH,MAAO,YAAWE,WAAgB,UAAKE,eAAeJ,MAAM;MAE7E,KAAKL,iBAAiBc,KAAS;MAE/BR,GAAGO,cAAe,IAAGE,cAAgB,SAAOP,SAASH,MAAM;IAAA;EAC/D;EAUJW,gBAAgBX,MAAgB,SAAgBY,MAChD;IACU;MAAEX;MAAIC;IAAgB;IAE5BU,SAASA,MAAU;IAEnB,MAAMT,WAAWH,MAAO,YAAWE,WAAgB,UAAKE,eAAeJ,MAAM;IAE1EC,mBAAgBA,GAAGS,cAAgB,WAAS,GAAGP,QAAS,SAAQS,MAAS,QAAK,GAAG;EAAA;EAOxFC,OAAOb,MACP;IACU;MAAEC;MAAIC;IAAgB;IAE5B,MAAMC,WAAWH,MAAO,YAAWE,WAAgB,UAAKE,eAAeJ,MAAM;IAEzE,WAAOc,SAAc,cAASC,QAClC;MACI;IAAA;IAGJZ,SAASY,WAAWf,MAAO;IAE3BC,GAAGI,UAAW,QAAOC,IAAM,WAASN,MAAM;IAE1C,IAAIG,QAAS,eAAcH,MAAO,MAAKgB,UACvC;MAEIf,GAAGgB,aAAc,QAAOX,IAAM,KAAGN,OAAOkB,IAAI;IAAA,CAGhD;MACI,MAAMC,QAAW,UAAOC,MAAS,MAAGC,cAAcpB,EAAG;MAE5CE,sBAAaH,OAAOkB,IAAK;MAClCjB,GAAGqB,UAAW,QAAOhB,IAAM,SAAOY,MAAMC,QAAQ;IAAA;EACpD;EAQJI,QAAQvB,QAAgBwB,WACxB;IACI,IAAI,CAAC,KAAK9B,cAAe,QAAO+B,EAChC;MACI;IAAA;IAGG,YAAK/B,eAAeM,MAAO;IAE5B,iBAAWA,MAAO,YAAW,IAAK;IACxC,MAAMC,KAAK,IAAK;IAETD,qBAAc0B,OAAO,IAAI;IAEhC,IAAI,CAACvB,QACL;MACI;IAAA;IAGJ,IAAI,CAACqB,WACL;MACOvB,gBAAaE,SAASH,MAAM;IAAA;IAG5B,cAAO2B,WAAW,IAAK;EAAA;EAOlC7B,WAAW0B,WACX;IACI,MAAMI,GAAkB,UAAOC,IAAK,MAAKnC,cAAc;IAEvD,SAASoC,CAAI,MAAGA,CAAI,OAAIC,QAAQD,CAChC;MACI,KAAKP,OAAQ,MAAK7B,cAAe,KAAIoC,KAAKN,WAAW;IAAA;EACzD;EAQMpB,eAAeJ,MACzB;IACU;MAAEE;MAAaD;IAAO;IAE5BD,OAAO2B,WAAWzB,WAAe,QAAI8B,QAAS,IAAGC,cAAc;IAE1D,oBAAejC,OAAOyB,EAAM;IAE1BzB,qBAAckC,IAAI,IAAI;IAE7B,OAAOlC,OAAO2B,UAAW;EAAA;AAEjC;AA3MapC,aAGF4C,SAA+B;EAClC7B,MAAM8B,aAAc;EACpBC,IAAM;AACV;AAuMJC,WAAWJ,IAAI3C,YAAY","names":["BufferSystem","constructor","renderer","managedBuffers","boundBufferBases","destroy","contextChange","disposeAll","bind","buffer","gl","CONTEXT_UID","glBuffer","createGLBuffer","bindBuffer","type","unbind","bindBufferBase","index","UNIFORM_BUFFER","bindBufferRange","offset","update","_updateID","updateID","byteLength","bufferSubData","data","drawType","static","STATIC_DRAW","bufferData","dispose","contextLost","id","remove","_glBuffers","all","keys","i","length","GLBuffer","createBuffer","add","extension","ExtensionType","name","extensions"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/core/src/geometry/BufferSystem.ts"],"sourcesContent":["import { extensions, ExtensionType } from '@pixi/extensions';\nimport { GLBuffer } from './GLBuffer';\n\nimport type { BUFFER_TYPE } from '@pixi/constants';\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { IRenderingContext } from '../IRenderer';\nimport type { Renderer } from '../Renderer';\nimport type { ISystem } from '../system/ISystem';\nimport type { Buffer } from './Buffer';\n\n/**\n * System plugin to the renderer to manage buffers.\n *\n * WebGL uses Buffers as a way to store objects to the GPU.\n * This system makes working with them a lot easier.\n *\n * Buffers are used in three main places in WebGL\n * - geometry information\n * - Uniform information (via uniform buffer objects - a WebGL 2 only feature)\n * - Transform feedback information. (WebGL 2 only feature)\n *\n * This system will handle the binding of buffers to the GPU as well as uploading\n * them. With this system, you never need to work directly with GPU buffers, but instead work with\n * the PIXI.Buffer class.\n * @class\n * @memberof PIXI\n */\nexport class BufferSystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'buffer',\n    };\n\n    CONTEXT_UID: number;\n    gl: IRenderingContext;\n\n    /** Cache for all buffers by id, used in case renderer gets destroyed or for profiling */\n    readonly managedBuffers: {[key: number]: Buffer};\n\n    /** Cache keeping track of the base bound buffer bases */\n    readonly boundBufferBases: {[key: number]: Buffer};\n\n    private renderer: Renderer;\n\n    /**\n     * @param {PIXI.Renderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n        this.managedBuffers = {};\n        this.boundBufferBases = {};\n    }\n\n    /**\n     * @ignore\n     */\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        this.disposeAll(true);\n\n        this.gl = this.renderer.gl;\n\n        // TODO fill out...\n        this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n    }\n\n    /**\n     * This binds specified buffer. On first run, it will create the webGL buffers for the context too\n     * @param buffer - the buffer to bind to the renderer\n     */\n    bind(buffer: Buffer): void\n    {\n        const { gl, CONTEXT_UID } = this;\n\n        const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n\n        gl.bindBuffer(buffer.type, glBuffer.buffer);\n    }\n\n    unbind(type: BUFFER_TYPE): void\n    {\n        const { gl } = this;\n\n        gl.bindBuffer(type, null);\n    }\n\n    /**\n     * Binds an uniform buffer to at the given index.\n     *\n     * A cache is used so a buffer will not be bound again if already bound.\n     * @param buffer - the buffer to bind\n     * @param index - the base index to bind it to.\n     */\n    bindBufferBase(buffer: Buffer, index: number): void\n    {\n        const { gl, CONTEXT_UID } = this;\n\n        if (this.boundBufferBases[index] !== buffer)\n        {\n            const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n\n            this.boundBufferBases[index] = buffer;\n\n            gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n        }\n    }\n\n    /**\n     * Binds a buffer whilst also binding its range.\n     * This will make the buffer start from the offset supplied rather than 0 when it is read.\n     * @param buffer - the buffer to bind\n     * @param index - the base index to bind at, defaults to 0\n     * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc\n     */\n    bindBufferRange(buffer: Buffer, index?: number, offset?: number): void\n    {\n        const { gl, CONTEXT_UID } = this;\n\n        offset = offset || 0;\n\n        const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n\n        gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);\n    }\n\n    /**\n     * Will ensure the data in the buffer is uploaded to the GPU.\n     * @param {PIXI.Buffer} buffer - the buffer to update\n     */\n    update(buffer: Buffer): void\n    {\n        const { gl, CONTEXT_UID } = this;\n\n        const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n\n        if (buffer._updateID === glBuffer.updateID)\n        {\n            return;\n        }\n\n        glBuffer.updateID = buffer._updateID;\n\n        gl.bindBuffer(buffer.type, glBuffer.buffer);\n\n        if (glBuffer.byteLength >= buffer.data.byteLength)\n        {\n            // offset is always zero for now!\n            gl.bufferSubData(buffer.type, 0, buffer.data);\n        }\n        else\n        {\n            const drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n\n            glBuffer.byteLength = buffer.data.byteLength;\n            gl.bufferData(buffer.type, buffer.data, drawType);\n        }\n    }\n\n    /**\n     * Disposes buffer\n     * @param {PIXI.Buffer} buffer - buffer with data\n     * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    dispose(buffer: Buffer, contextLost?: boolean): void\n    {\n        if (!this.managedBuffers[buffer.id])\n        {\n            return;\n        }\n\n        delete this.managedBuffers[buffer.id];\n\n        const glBuffer = buffer._glBuffers[this.CONTEXT_UID];\n        const gl = this.gl;\n\n        buffer.disposeRunner.remove(this);\n\n        if (!glBuffer)\n        {\n            return;\n        }\n\n        if (!contextLost)\n        {\n            gl.deleteBuffer(glBuffer.buffer);\n        }\n\n        delete buffer._glBuffers[this.CONTEXT_UID];\n    }\n\n    /**\n     * dispose all WebGL resources of all managed buffers\n     * @param {boolean} [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n     */\n    disposeAll(contextLost?: boolean): void\n    {\n        const all: Array<any> = Object.keys(this.managedBuffers);\n\n        for (let i = 0; i < all.length; i++)\n        {\n            this.dispose(this.managedBuffers[all[i]], contextLost);\n        }\n    }\n\n    /**\n     * creates and attaches a GLBuffer object tied to the current context.\n     * @param buffer\n     * @protected\n     */\n    protected createGLBuffer(buffer: Buffer): GLBuffer\n    {\n        const { CONTEXT_UID, gl } = this;\n\n        buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());\n\n        this.managedBuffers[buffer.id] = buffer;\n\n        buffer.disposeRunner.add(this);\n\n        return buffer._glBuffers[CONTEXT_UID];\n    }\n}\n\nextensions.add(BufferSystem);\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}