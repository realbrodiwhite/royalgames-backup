{"ast":null,"code":"import { Runner } from '@pixi/runner';\nimport { Program } from './Program.mjs';\nimport { UniformGroup } from './UniformGroup.mjs';\nclass Shader {\n  constructor(program, uniforms) {\n    this.uniformBindCount = 0;\n    this.program = program;\n    if (uniforms) {\n      if (uniforms instanceof UniformGroup) {\n        this.uniformGroup = uniforms;\n      } else {\n        this.uniformGroup = new UniformGroup(uniforms);\n      }\n    } else {\n      this.uniformGroup = new UniformGroup({});\n    }\n    this.disposeRunner = new Runner(\"disposeShader\");\n  }\n  checkUniformExists(name, group) {\n    if (group.uniforms[name]) {\n      return true;\n    }\n    for (const i in group.uniforms) {\n      const uniform = group.uniforms[i];\n      if (uniform.group) {\n        if (this.checkUniformExists(name, uniform)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  destroy() {\n    this.uniformGroup = null;\n    this.disposeRunner.emit(this);\n    this.disposeRunner.destroy();\n  }\n  get uniforms() {\n    return this.uniformGroup.uniforms;\n  }\n  static from(vertexSrc, fragmentSrc, uniforms) {\n    const program = Program.from(vertexSrc, fragmentSrc);\n    return new Shader(program, uniforms);\n  }\n}\nexport { Shader };","map":{"version":3,"mappings":";;;AAUO,MAAMA,MACb;EAiBIC,YAAYC,SAAkBC,QAC9B;IATmB;IAUf,KAAKD,OAAU;IAIf,IAAIC,QACJ;MACI,IAAIA,oBAAoBC,YACxB;QACI,KAAKC,YAAe;MAAA,CAGxB;QACS,oBAAe,IAAID,aAAaD,QAAQ;MAAA;IACjD,CAGJ;MACI,KAAKE,YAAe,OAAID,YAAa,GAAE;IAAA;IAGtC,qBAAgB,IAAIE,OAAO,eAAe;EAAA;EAInDC,mBAAmBC,MAAcC,KACjC;IACQ,UAAMN,SAASK,IACnB;MACW;IAAA;IAGA,gBAAKC,MAAMN,QACtB;MACU,gBAAUM,MAAMN,QAAS;MAE/B,IAAIO,QAAQD,KACZ;QACI,IAAI,IAAK,oBAAmBD,IAAM,SAAO,CACzC;UACW;QAAA;MACX;IACJ;IAGG;EAAA;EAGXG,OACAA;IAGI,KAAKN,YAAe;IAEf,mBAAcO,KAAK,IAAI;IAC5B,KAAKC,cAAcF,OAAQ;EAAA;EAO/B,IAAIR,QACJA;IACI,OAAO,KAAKE,YAAa;EAAA;EAU7B,OAAOS,KAAKC,SAAoB,eAAsBZ,QACtD;IACI,MAAMD,OAAU,WAAQY,IAAK,YAAWE,WAAW;IAE5C,WAAIhB,MAAO,UAASG,QAAQ;EAAA;AAE3C","names":["Shader","constructor","program","uniforms","UniformGroup","uniformGroup","Runner","checkUniformExists","name","group","uniform","destroy","emit","disposeRunner","from","vertexSrc","fragmentSrc"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/core/src/shader/Shader.ts"],"sourcesContent":["import { Runner } from '@pixi/runner';\nimport { Program } from './Program';\nimport { UniformGroup } from './UniformGroup';\n\nimport type { Dict } from '@pixi/utils';\n\n/**\n * A helper class for shaders.\n * @memberof PIXI\n */\nexport class Shader\n{\n    /** Program that the shader uses. */\n    public program: Program;\n    public uniformGroup: UniformGroup;\n\n    /**\n     * Used internally to bind uniform buffer objects.\n     * @ignore\n     */\n    uniformBindCount = 0;\n\n    disposeRunner: Runner;\n\n    /**\n     * @param program - The program the shader will use.\n     * @param uniforms - Custom uniforms to use to augment the built-in ones.\n     */\n    constructor(program: Program, uniforms?: Dict<any>)\n    {\n        this.program = program;\n\n        // lets see whats been passed in\n        // uniforms should be converted to a uniform group\n        if (uniforms)\n        {\n            if (uniforms instanceof UniformGroup)\n            {\n                this.uniformGroup = uniforms;\n            }\n            else\n            {\n                this.uniformGroup = new UniformGroup(uniforms);\n            }\n        }\n        else\n        {\n            this.uniformGroup = new UniformGroup({});\n        }\n\n        this.disposeRunner = new Runner('disposeShader');\n    }\n\n    // TODO move to shader system..\n    checkUniformExists(name: string, group: UniformGroup): boolean\n    {\n        if (group.uniforms[name])\n        {\n            return true;\n        }\n\n        for (const i in group.uniforms)\n        {\n            const uniform = group.uniforms[i];\n\n            if (uniform.group)\n            {\n                if (this.checkUniformExists(name, uniform))\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    destroy(): void\n    {\n        // usage count on programs?\n        // remove if not used!\n        this.uniformGroup = null;\n\n        this.disposeRunner.emit(this);\n        this.disposeRunner.destroy();\n    }\n\n    /**\n     * Shader uniform values, shortcut for `uniformGroup.uniforms`.\n     * @readonly\n     */\n    get uniforms(): Dict<any>\n    {\n        return this.uniformGroup.uniforms;\n    }\n\n    /**\n     * A short hand function to create a shader based of a vertex and fragment shader.\n     * @param vertexSrc - The source of the vertex shader.\n     * @param fragmentSrc - The source of the fragment shader.\n     * @param uniforms - Custom uniforms to use to augment the built-in ones.\n     * @returns A shiny new PixiJS shader!\n     */\n    static from(vertexSrc?: string, fragmentSrc?: string, uniforms?: Dict<any>): Shader\n    {\n        const program = Program.from(vertexSrc, fragmentSrc);\n\n        return new Shader(program, uniforms);\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}