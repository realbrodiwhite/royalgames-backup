{"ast":null,"code":"import { Texture, BaseTexture } from '@pixi/core';\nimport '../utils/index.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\nclass CacheClass {\n  constructor() {\n    this._parsers = [];\n    this._cache = /* @__PURE__ */new Map();\n    this._cacheMap = /* @__PURE__ */new Map();\n  }\n  reset() {\n    this._cacheMap.clear();\n    this._cache.clear();\n  }\n  has(key) {\n    return this._cache.has(key);\n  }\n  get(key) {\n    const result = this._cache.get(key);\n    if (!result) {\n      console.warn(\"[Assets] Asset id \".concat(key, \" was not found in the Cache\"));\n    }\n    return result;\n  }\n  set(key, value) {\n    const keys = convertToList(key);\n    let cacheableAssets;\n    for (let i = 0; i < this.parsers.length; i++) {\n      const parser = this.parsers[i];\n      if (parser.test(value)) {\n        cacheableAssets = parser.getCacheableAssets(keys, value);\n        break;\n      }\n    }\n    if (!cacheableAssets) {\n      cacheableAssets = {};\n      keys.forEach(key2 => {\n        cacheableAssets[key2] = value;\n      });\n    }\n    const cacheKeys = Object.keys(cacheableAssets);\n    const cachedAssets = {\n      cacheKeys,\n      keys\n    };\n    keys.forEach(key2 => {\n      this._cacheMap.set(key2, cachedAssets);\n    });\n    cacheKeys.forEach(key2 => {\n      if (this._cache.has(key2) && this._cache.get(key2) !== value) {\n        console.warn(\"[Cache] already has key:\", key2);\n      }\n      this._cache.set(key2, cacheableAssets[key2]);\n    });\n    if (value instanceof Texture) {\n      const texture = value;\n      keys.forEach(key2 => {\n        if (texture.baseTexture !== Texture.EMPTY.baseTexture) {\n          BaseTexture.addToCache(texture.baseTexture, key2);\n        }\n        Texture.addToCache(texture, key2);\n      });\n    }\n  }\n  remove(key) {\n    this._cacheMap.get(key);\n    if (!this._cacheMap.has(key)) {\n      console.warn(\"[Assets] Asset id \".concat(key, \" was not found in the Cache\"));\n      return;\n    }\n    const cacheMap = this._cacheMap.get(key);\n    const cacheKeys = cacheMap.cacheKeys;\n    cacheKeys.forEach(key2 => {\n      this._cache.delete(key2);\n    });\n    cacheMap.keys.forEach(key2 => {\n      this._cacheMap.delete(key2);\n    });\n  }\n  get parsers() {\n    return this._parsers;\n  }\n}\nconst Cache = new CacheClass();\nexport { Cache };","map":{"version":3,"mappings":";;;AAoBA,MAAMA,UACN;EADAC;IAEI,KAAQC,WAA0B,EAAC;IAElB,iCAA+BC,GAAI;IACnC,oCAGRA,GAAI;EAAA;EAGbC,KACAA;IACI,KAAKC,UAAUC,KAAM;IACrB,KAAKC,OAAOD,KAAM;EAAA;EAOfE,IAAIC,GACX;IACW,YAAKF,MAAO,KAAIE,GAAG;EAAA;EAOvBC,IAAaD,GACpB;IACI,MAAME,MAAS,QAAKJ,MAAO,KAAIE,GAAG;IAElC,IAAI,CAACE,MACL;MAEYC,yCAA0BH,GAAgC;IAAA;IAI/D;EAAA;EAQJI,GAAIA,MAAwBC,KACnC;IACU,aAAOC,cAAsBN,GAAG;IAElC;IAEJ,SAASO,IAAI,CAAG,MAAI,IAAK,SAAQC,QAAQD,CACzC;MACU,eAAS,KAAKE,OAAQ;MAExB,WAAOC,IAAK,MAAK,CACrB;QACsBC,yBAAOC,kBAAmB,OAAMP,KAAK;QAEvD;MAAA;IACJ;IAGJ,IAAI,CAACM,eACL;MACIA,kBAAkB,EAAC;MAEdE,aAASC,IACd;QACIH,gBAAgBG,IAAO;MAAA,CAC1B;IAAA;IAGC,kBAAYC,MAAO,MAAKJ,eAAe;IAE7C,MAAMK,YAAe;MACjBC;MACAJ;IAAA,CACJ;IAGKA,aAASC,IACd;MACS,eAAUV,GAAI,OAAKY,YAAY;IAAA,CACvC;IAESC,kBAASH,IACnB;MACQ,SAAKhB,MAAO,KAAIgB,IAAG,KAAK,KAAKhB,MAAO,KAAIgB,IAAG,MAAMT,KACrD;QAEYF,aAAK,4BAA4BW,IAAG;MAAA;MAIhD,KAAKhB,MAAO,KAAIgB,IAAK,kBAAgBA,IAAI;IAAA,CAC5C;IAGD,IAAIT,iBAAiBa,OACrB;MACI,MAAMC,OAAmB;MAEpBN,aAASC,IACd;QACI,IAAIK,OAAQ,iBAAgBD,OAAQ,OAAME,WAC1C;UACgBC,uBAAWF,OAAQ,cAAaL,IAAG;QAAA;QAG3CI,mBAAWC,SAASL,IAAG;MAAA,CAClC;IAAA;EACL;EASGQ,OAAOtB,GACd;IACS,eAAUC,IAAID,GAAG;IAEtB,IAAI,CAAC,KAAKJ,SAAU,KAAII,GAAG,CAC3B;MAEYG,yCAA0BH,GAAgC;MAGlE;IAAA;IAGJ,MAAMuB,QAAW,QAAK3B,SAAU,KAAII,GAAG;IAEvC,MAAMiB,YAAYM,QAAS;IAEjBN,kBAASH,IACnB;MACS,YAAOU,OAAOV,IAAG;IAAA,CACzB;IAEQS,cAAKE,OAAQ,CAACX,IACvB;MACS,eAAUU,OAAOV,IAAG;IAAA,CAC5B;EAAA;EAIL,IAAWL,OACXA;IACI,OAAO,IAAK;EAAA;AAEpB;AAEa,cAAQ,IAAIlB,UAAW","names":["CacheClass","constructor","_parsers","Map","reset","_cacheMap","clear","_cache","has","key","get","result","console","set","value","convertToList","i","length","parsers","test","cacheableAssets","getCacheableAssets","keys","key2","Object","cachedAssets","cacheKeys","Texture","texture","baseTexture","BaseTexture","remove","cacheMap","delete","forEach"],"sources":["/workspaces/royalgames/royalgamesclient-main/node_modules/@pixi/assets/src/cache/Cache.ts"],"sourcesContent":["import { BaseTexture, Texture } from '@pixi/core';\nimport { convertToList } from '../utils';\n\nimport type { CacheParser } from './CacheParser';\n\n/**\n * A single Cache for all assets.\n *\n * When assets are added to the cache via set they normally are added to the cache as key-value pairs.\n *\n * With this cache, you can add parsers that will take the object and convert it to a list of assets that can be cached.\n * for example a cacheSprite Sheet parser will add all of the textures found within its sprite sheet directly to the cache.\n *\n * This gives devs the flexibility to cache any type of object however we want.\n *\n * It is not intended that this class is created by developers - it is part of the Asset package.\n * This is the first major system of PixiJS' main Assets class.\n * @memberof PIXI\n * @class Cache\n */\nclass CacheClass\n{\n    private _parsers: CacheParser[] = [];\n\n    private readonly _cache: Map<string, any> = new Map();\n    private readonly _cacheMap: Map<string, {\n        keys: string[],\n        cacheKeys: string[],\n    }> = new Map();\n\n    /** Clear all entries. */\n    public reset(): void\n    {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n\n    /**\n     * Check if the key exists\n     * @param key - The key to check\n     */\n    public has(key: string): boolean\n    {\n        return this._cache.has(key);\n    }\n\n    /**\n     * Fetch entry by key\n     * @param key - The key of the entry to get\n     */\n    public get<T = any>(key: string): T\n    {\n        const result = this._cache.get(key);\n\n        if (!result)\n        {\n            // #if _DEBUG\n            console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n        }\n\n        return result as T;\n    }\n\n    /**\n     * Set a value by key or keys name\n     * @param key - The key or keys to set\n     * @param value - The value to store in the cache or from which cacheable assets will be derived.\n     */\n    public set(key: string | string[], value: unknown): void\n    {\n        const keys = convertToList<string>(key);\n\n        let cacheableAssets: Record<string, any>;\n\n        for (let i = 0; i < this.parsers.length; i++)\n        {\n            const parser = this.parsers[i];\n\n            if (parser.test(value))\n            {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n\n                break;\n            }\n        }\n\n        if (!cacheableAssets)\n        {\n            cacheableAssets = {};\n\n            keys.forEach((key) =>\n            {\n                cacheableAssets[key] = value;\n            });\n        }\n\n        const cacheKeys = Object.keys(cacheableAssets);\n\n        const cachedAssets = {\n            cacheKeys,\n            keys\n        };\n\n        // this is so we can remove them later..\n        keys.forEach((key) =>\n        {\n            this._cacheMap.set(key, cachedAssets);\n        });\n\n        cacheKeys.forEach((key) =>\n        {\n            if (this._cache.has(key) && this._cache.get(key) !== value)\n            {\n                // #if _DEBUG\n                console.warn('[Cache] already has key:', key);\n                // #endif\n            }\n\n            this._cache.set(key, cacheableAssets[key]);\n        });\n\n        // temporary to keep compatible with existing texture caching.. until we remove them!\n        if (value instanceof Texture)\n        {\n            const texture: Texture = value;\n\n            keys.forEach((key) =>\n            {\n                if (texture.baseTexture !== Texture.EMPTY.baseTexture)\n                {\n                    BaseTexture.addToCache(texture.baseTexture, key);\n                }\n\n                Texture.addToCache(texture, key);\n            });\n        }\n    }\n\n    /**\n     * Remove entry by key\n     *\n     * This function will also remove any associated alias from the cache also.\n     * @param key - The key of the entry to remove\n     */\n    public remove(key: string): void\n    {\n        this._cacheMap.get(key);\n\n        if (!this._cacheMap.has(key))\n        {\n            // #if _DEBUG\n            console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n\n            return;\n        }\n\n        const cacheMap = this._cacheMap.get(key);\n\n        const cacheKeys = cacheMap.cacheKeys;\n\n        cacheKeys.forEach((key) =>\n        {\n            this._cache.delete(key);\n        });\n\n        cacheMap.keys.forEach((key: string) =>\n        {\n            this._cacheMap.delete(key);\n        });\n    }\n\n    /** All loader parsers registered */\n    public get parsers(): CacheParser[]\n    {\n        return this._parsers;\n    }\n}\n\nexport const Cache = new CacheClass();\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}